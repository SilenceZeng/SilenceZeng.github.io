
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  
    <title>HTML5学习总结 | 欢迎来到曾安的博客</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=3, minimum-scale=1">
    
    <meta name="author" content="angus-Zeng">
    
    <meta name="description" content="html5与html4区别语法的改变DOCTYPE声明：&amp;amp;lt!DOCTYPE html&amp;amp;gt
指定字符编码：&amp;amp;ltmeta charset=”UTF-8”&amp;amp;gt,HTML5开始推荐UTF-8
所谓的字符是对各种文字和符号的总称，涵盖了各国文字、标点符号、图形符号和数">
    
    
    
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/pacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/pacman.jpg">
    
    
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.4.0"></head>

  <body>
    <header>
      <div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.svg" alt="欢迎来到曾安的博客" title="欢迎来到曾安的博客"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="欢迎来到曾安的博客">欢迎来到曾安的博客</a></h1>
				<h2 class="blog-motto">最简单的在心头挥之不去</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
					<li>
					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="text" id="search" name="q" autocomplete="off" maxlength="20" placeholder="搜索" />
						<input type="hidden" name="q" value="site:example.com">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>

    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2021/10/06/HTML5学习总结/" title="HTML5学习总结" itemprop="url">HTML5学习总结</a>
  </h1>
  <p class="article-author">By
    
      <a href="http://example.com" title="angus-Zeng">angus-Zeng</a>
    </p>
  <p class="article-time">
    <time datetime="2021-10-06T10:11:04.141Z" itemprop="datePublished">2021-10-06</time>
    更新日期:<time datetime="2021-10-06T10:11:04.142Z" itemprop="dateModified">2021-10-06</time>
    
  </p>
</header>
	<div class="article-content">
		
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">文章目录</strong>
		<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#html5%E4%B8%8Ehtml4%E5%8C%BA%E5%88%AB"><span class="toc-number">1.</span> <span class="toc-text">html5与html4区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95%E7%9A%84%E6%94%B9%E5%8F%98"><span class="toc-number">1.1.</span> <span class="toc-text">语法的改变</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B0%E5%A2%9E%E7%9A%84%E5%85%83%E7%B4%A0%E5%92%8C%E5%BA%9F%E9%99%A4%E7%9A%84%E5%85%83%E7%B4%A0"><span class="toc-number">1.2.</span> <span class="toc-text">新增的元素和废除的元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B0%E5%A2%9E%E7%9A%84%E5%B1%9E%E6%80%A7%E5%92%8C%E5%BA%9F%E9%99%A4%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="toc-number">1.3.</span> <span class="toc-text">新增的属性和废除的属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%B1%9E%E6%80%A7"><span class="toc-number">1.4.</span> <span class="toc-text">全局属性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#html5-%E7%BB%93%E6%9E%84"><span class="toc-number">2.</span> <span class="toc-text">html5 结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B0%E5%A2%9E%E7%9A%84%E4%B8%BB%E4%BD%93%E7%BB%93%E6%9E%84%E5%85%83%E7%B4%A0"><span class="toc-number">2.1.</span> <span class="toc-text">新增的主体结构元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B0%E5%A2%9E%E7%9A%84%E9%9D%9E%E4%B8%BB%E4%BD%93%E7%BB%93%E6%9E%84%E5%85%83%E7%B4%A0"><span class="toc-number">2.2.</span> <span class="toc-text">新增的非主体结构元素</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A8%E5%8D%95%E4%B8%8E%E6%96%87%E4%BB%B6"><span class="toc-number">3.</span> <span class="toc-text">表单与文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B0%E5%A2%9E%E5%85%83%E7%B4%A0%E5%92%8C%E5%B1%9E%E6%80%A7"><span class="toc-number">3.1.</span> <span class="toc-text">新增元素和属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A8%E5%8D%95%E9%AA%8C%E8%AF%81"><span class="toc-number">3.2.</span> <span class="toc-text">表单验证</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTML5%E8%A1%A8%E5%8D%95%E9%AA%8C%E8%AF%81%E6%8F%92%E4%BB%B6"><span class="toc-number">3.3.</span> <span class="toc-text">HTML5表单验证插件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A2%9E%E5%BC%BA%E7%9A%84%E9%A1%B5%E9%9D%A2%E5%85%83%E7%B4%A0"><span class="toc-number">3.4.</span> <span class="toc-text">增强的页面元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6API"><span class="toc-number">3.5.</span> <span class="toc-text">文件API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%96%E6%94%BEAPI"><span class="toc-number">3.6.</span> <span class="toc-text">拖放API</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E6%80%A7%E4%B8%8EModernizr%E5%BA%93"><span class="toc-number">4.</span> <span class="toc-text">处理浏览器兼容性与Modernizr库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E6%80%A7"><span class="toc-number">4.1.</span> <span class="toc-text">处理浏览器兼容性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Modernizr%E5%BA%93%E6%A6%82%E8%BF%B0"><span class="toc-number">4.2.</span> <span class="toc-text">Modernizr库概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Modernizr%E5%BA%93CSS%E7%9A%84%E6%96%B0%E5%A2%9Eclass"><span class="toc-number">4.3.</span> <span class="toc-text">Modernizr库CSS的新增class</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Modernizr%E5%BA%93JavaScript%E4%BE%A6%E6%B5%8B"><span class="toc-number">4.4.</span> <span class="toc-text">Modernizr库JavaScript侦测</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Modernizr%E5%BA%93%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">4.5.</span> <span class="toc-text">Modernizr库加载器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%98%E5%88%B6%E5%9B%BE%E5%BD%A2"><span class="toc-number">5.</span> <span class="toc-text">绘制图形</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#canvas%E5%85%83%E7%B4%A0%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">5.1.</span> <span class="toc-text">canvas元素的基础知识</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E8%B7%AF%E5%BE%84"><span class="toc-number">5.2.</span> <span class="toc-text">使用路径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%98%E5%88%B6%E6%B8%90%E5%8F%98%E5%9B%BE%E5%BD%A2"><span class="toc-number">5.3.</span> <span class="toc-text">绘制渐变图形</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%98%E5%88%B6%E5%8F%98%E5%BD%A2%E5%9B%BE%E5%BD%A2"><span class="toc-number">5.4.</span> <span class="toc-text">绘制变形图形</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E5%BD%A2%E7%BB%84%E5%90%88"><span class="toc-number">5.5.</span> <span class="toc-text">图形组合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%99%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E9%98%B4%E5%BD%B1"><span class="toc-number">5.6.</span> <span class="toc-text">给图形绘制阴影</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9B%BE%E5%83%8F"><span class="toc-number">5.7.</span> <span class="toc-text">使用图像</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%98%E5%88%B6%E6%96%87%E5%AD%97"><span class="toc-number">5.8.</span> <span class="toc-text">绘制文字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A5%E5%85%85%E7%9F%A5%E8%AF%86"><span class="toc-number">5.9.</span> <span class="toc-text">补充知识</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E7%9B%B8%E5%85%B3"><span class="toc-number">5.10.</span> <span class="toc-text">其他相关</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AA%92%E4%BD%93%E6%92%AD%E6%94%BE"><span class="toc-number">6.</span> <span class="toc-text">媒体播放</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8"><span class="toc-number">7.</span> <span class="toc-text">本地存储</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Web-Storage"><span class="toc-number">7.1.</span> <span class="toc-text">Web Storage</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">7.2.</span> <span class="toc-text">本地数据库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SQLLite"><span class="toc-number">7.3.</span> <span class="toc-text">SQLLite</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#indexedDB"><span class="toc-number">7.4.</span> <span class="toc-text">indexedDB</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A6%BB%E7%BA%BF%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F"><span class="toc-number">8.</span> <span class="toc-text">离线应用程序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98%E5%92%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="toc-number">8.1.</span> <span class="toc-text">本地缓存和浏览器缓存的区别：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0HTML5%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%BC%93%E5%AD%98"><span class="toc-number">8.2.</span> <span class="toc-text">实现HTML5应用程序缓存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#applicationCache%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%96%B9%E6%B3%95"><span class="toc-number">8.3.</span> <span class="toc-text">applicationCache的两个方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#applicationCache%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BA%8B%E4%BB%B6"><span class="toc-number">8.4.</span> <span class="toc-text">applicationCache对象的事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%9C%A8%E7%BA%BF%E8%BF%98%E6%98%AF%E7%A6%BB%E7%BA%BF%E7%8A%B6%E6%80%81%EF%BC%9F"><span class="toc-number">8.5.</span> <span class="toc-text">如何判断在线还是离线状态？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E4%BF%A1API"><span class="toc-number">9.</span> <span class="toc-text">通信API</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%A8%E6%96%87%E6%A1%A3%E6%B6%88%E6%81%AF%E4%BC%A0%E8%BE%93"><span class="toc-number">9.1.</span> <span class="toc-text">跨文档消息传输</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#XMLHttpRequest-Level-2"><span class="toc-number">9.2.</span> <span class="toc-text">XMLHttpRequest Level 2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Web-Socket%E9%80%9A%E4%BF%A1"><span class="toc-number">9.3.</span> <span class="toc-text">Web Socket通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Socket-IO%E9%80%9A%E4%BF%A1%E6%A1%86%E6%9E%B6"><span class="toc-number">9.4.</span> <span class="toc-text">Socket.IO通信框架</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Web-Workers"><span class="toc-number">10.</span> <span class="toc-text">Web Workers</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%9C%B0%E7%90%86%E4%BD%8D%E7%BD%AE"><span class="toc-number">11.</span> <span class="toc-text">获取地理位置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E5%93%AA%E4%BA%9B%E5%AE%9A%E4%BD%8D%E6%95%B0%E6%8D%AE"><span class="toc-number">11.1.</span> <span class="toc-text">有哪些定位数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Geolocation-API%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86"><span class="toc-number">11.2.</span> <span class="toc-text">Geolocation API的基本知识</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AE%E6%95%B0%E6%8D%AE"><span class="toc-number">12.</span> <span class="toc-text">微数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#History-API"><span class="toc-number">13.</span> <span class="toc-text">History API</span></a></li></ol>
		</div>
		
		<h2 id="html5与html4区别"><a href="#html5与html4区别" class="headerlink" title="html5与html4区别"></a>html5与html4区别</h2><h3 id="语法的改变"><a href="#语法的改变" class="headerlink" title="语法的改变"></a>语法的改变</h3><p>DOCTYPE声明：&amp;lt!DOCTYPE html&amp;gt</p>
<p>指定字符编码：&amp;ltmeta charset=”UTF-8”&amp;gt,HTML5开始推荐UTF-8</p>
<p>所谓的字符是对各种文字和符号的总称，涵盖了各国文字、标点符号、图形符号和数字等。字符集是对多个字符的集合，常用的字符集有ASCII、GB2312、Unicode、ISO等。科学家为了让计算机准确处理各种字符集，需要对字符进行编码，以便计算机能够识别和存储各种文字。</p>
<p>在HTML5出现之前，浏览器会根据三种方式确认页面的编码方式，按优先级排列如下：<br>1)获取HTTP请求头中的Content-Type字符对于的值。<br>2)使用meta标签声明，语法格式如下：</p>
<pre><code>&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=utf-8&quot;&gt;
</code></pre>
<p>3)外链资源使用charset属性声明编码格式，如在script标签中使用语法格式如下：</p>
<pre><code>&lt;script type=&quot;text/javascript&quot; src=&quot;myscript.js&quot; charset=&quot;UTF-8&quot;&gt;&lt;/script&gt;
</code></pre>
<p>HTML5出现后，对字符集的使用做了大量的简化，可以使用以下语法进行字符声明：</p>
<pre><code>&lt;meta charset=&quot;utf-8&quot;&gt;
</code></pre>
<p>对于日常网站开发，结合HTML5的字符集使用，建议：<br>1)最优先使用HTTP请求头指定编码。<br>2)统一全站字符集编码，HTML5推荐使用UTF-8字符集。<br>3)使用meta标签确认字符集编码，尽可能放在html标签的第一个子元素位置<br>4)第三方引用的脚本，在不确认字符编码时，加上charset属性设置编码格式</p>
<p>为什么会产生乱码？<br>乱码产生的根本原因是你保存的编码格式和浏览器解析时的解码格式不匹配导致的。<br>乱码一般是英文以外的字符才会出现。</p>
<p>可以省略标记的元素：<br>1)不允许写结束标记的元素有：area、base、br、col、command、embed、hr、img、input、keygen、link、meta、param、source、track、wbr<br>2)可以省略结束标记的元素有：li、dt、dd、p、rt、rp、optgroup、option、colgroup、thead、tbody、bfoot、tr、td、th<br>3)可以省略全部标记的元素有：html、head、body、colgroup、tbody。</p>
<p>具有boolean值的属性：对于具有boolean之的属性，例如disabled与readonly等，当只写属性而不指定属性值时，表示属性值为true，如果想要将属性值设为false，可以不使用该属性值。</p>
<p>属性值可以省略引号</p>
<h3 id="新增的元素和废除的元素"><a href="#新增的元素和废除的元素" class="headerlink" title="新增的元素和废除的元素"></a>新增的元素和废除的元素</h3><p>新增的元素：section、article、aside、header、hgroup、footer、nav、figure、vedio、audio、embed、mark、progress、time、ruby、rt、rp、wbr、canvas、command、details、datalist、datagrid、keygen、output、source、menu</p>
<p>新增的input类型：email、url、number、range、Date Pickers</p>
<p>废除的元素：<br>1)能用css替代的元素：basefont、big、center、font、s、strike、tt、u<br>2)不再使用frame框架，只支持iframe框架<br>3)只有部分浏览器支持的元素：applet、bgsound、blink、marquee<br>4)其他废除的元素：rb、acronym、dir、isindex、listing、xmp、nextid、plaintext</p>
<h3 id="新增的属性和废除的属性"><a href="#新增的属性和废除的属性" class="headerlink" title="新增的属性和废除的属性"></a>新增的属性和废除的属性</h3><p>新增的属性：<br>1)表单相关的属性：autofocus、placeholder、form、required、autocomplete、min、max、multiple、pattern、step、formaction、formenctype、formmethod、formnovalidate、formtarget、novalidate<br>2)链接相关的属性：<br>为a与area元素增加了media属性<br>为area元素增加了hreflang和rel属性，主要目的是保持与a元素、link元素的一致性<br>为link元素增加了新属性sizes。该属性可以与icon元素结合使用（通过rel属性），该属性指定关联图标（icon元素）的大小<br>为base元素增加了target属性，主要目的是保持与a元素的一致性<br>a元素还有download属性<br>3)其他属性<br>为ol元素增加了reversed属性<br>为meta元素增加了charset属性<br>为munu元素增加了type与label<br>为style元素增加了scoped属性<br>为script元素增加了async属性<br>为html元素增加了manifest属性<br>为iframe增加了sandbox、seamless、srcdoc属性</p>
<p>废除的属性：很多，略</p>
<h3 id="全局属性"><a href="#全局属性" class="headerlink" title="全局属性"></a>全局属性</h3><p>1)contentEditable<br>2)designMode: on或off<br>3)hidden属性<br>4)spellcheck: 必须声明属性值为true或false<br>5)tabindex</p>
<h2 id="html5-结构"><a href="#html5-结构" class="headerlink" title="html5 结构"></a>html5 结构</h2><h3 id="新增的主体结构元素"><a href="#新增的主体结构元素" class="headerlink" title="新增的主体结构元素"></a>新增的主体结构元素</h3><p>article元素<br>article元素代表文档、页面或应用程序中独立的、完整的可以被外部引用的内容。article元素也可以用来表示插件，它的作用是使插件看起来好像内嵌在页面中一样。<br>section元素<br>section元素用于对网站或应用程序中页面上的内容进行分块。在HTML5中，article元素可以看成是一种特殊种类的section元素，它比section元素更强调独立性。即section元素强调分段或分块，而article元素强调独立性。<br>section元素使用禁忌：<br>1）不要将section元素用作设置样式的页面容器，那是div的工作；<br>2）如果article元素、aside元素或nav元素更符合使用条件，不要使用section元素；<br>3）不要为没有标题的内容区块使用section元素。<br>nav元素<br>nav元素是一个可以用作页面导航的链接组<br>aside元素<br>aside元素用来表示当前页面或文章的附属信息部分。典型应用是侧边栏<br>time元素和微格式<br>pubdate属性</p>
<h3 id="新增的非主体结构元素"><a href="#新增的非主体结构元素" class="headerlink" title="新增的非主体结构元素"></a>新增的非主体结构元素</h3><p>header元素<br>hgroup元素<br>footer元素<br>address元素</p>
<h2 id="表单与文件"><a href="#表单与文件" class="headerlink" title="表单与文件"></a>表单与文件</h2><h3 id="新增元素和属性"><a href="#新增元素和属性" class="headerlink" title="新增元素和属性"></a>新增元素和属性</h3><p>新增属性<br>1)form属性<br>当一个input元素被用于多个元素时，可以在form属性上将各表单id值以空格符分隔开来<br>2)formaction属性<br>3)formmethod属性<br>4)placeholder属性<br>5)autofocus属性<br>6)autocomplete属性<br>autocomplete属性规定输入字段是否应该启用自动完成功能。<br>自动完成允许浏览器预测对字段的输入。当用户在字段开始键入时，浏览器基于之前键入过的值，应该显示出在字段中填写的选项。<br>注释：autocomplete属性适用于form，以及下面的input类型：text,search,url,telephone,email,password,datepickers,range以及color。</p>
<p>大幅度增加和改良的input种类<br>1)url类型<br>2)email类型<br>3)date类型<br>4)time类型<br>5)datetime类型<br>6)datetime-local类型<br>7)month类型<br>8)week类型<br>9)number类型<br>10)range类型<br>11)search类型<br>12)tel类型<br>13)color类型</p>
<p>output元素的追加</p>
<h3 id="表单验证"><a href="#表单验证" class="headerlink" title="表单验证"></a>表单验证</h3><p>自动验证: required pattern min和max step<br>显示验证：checkValidity()方法<br>取消验证：<br>1)form的novalidate属性<br>2)input元素或submit元素的formnovalidate属性</p>
<h3 id="HTML5表单验证插件"><a href="#HTML5表单验证插件" class="headerlink" title="HTML5表单验证插件"></a>HTML5表单验证插件</h3><p><a target="_blank" rel="noopener" href="http://www.zhangxinxu.com/wordpress/2012/12/jquery-html5validate-html5-form-validate-plugin/">html5Validate</a><br>自定义错误信息：setCustomValidity()方法</p>
<h3 id="增强的页面元素"><a href="#增强的页面元素" class="headerlink" title="增强的页面元素"></a>增强的页面元素</h3><p>新增的figure元素和figcaption元素<br>新增的details元素和summary元素<br>input和datalist</p>
<pre><code>&lt;input type=&quot;text&quot; list=&quot;province&quot;&gt;
    &lt;datalist id=&quot;province&quot;&gt;
        &lt;option value=&quot;北京&quot;&gt;&lt;/option&gt;
        &lt;option value=&quot;上海&quot;&gt;&lt;/option&gt;
        &lt;option value=&quot;浙江&quot;&gt;&lt;/option&gt;
    &lt;/datalist&gt;
</code></pre>
<p>新增的mark元素：用来在搜索结果中高亮关键词，也常用来文章引用后加的标示，与em（）、strong不同<br>新增的progess元素：表示任务的进度，如Windows系统中软件的安装、文件的复制等场景的进度。<br>新增的meter元素：表示某种计量，适用于温度、重量、金额等量化的表现。<br>新增的menu和command元素: menu在html4被弃用，在html5中重定义，command为html5新增，这两个标签目前基本没有浏览器支持<br>改良的ol列表：新增了start属性和reversed属性<br>改良的dl列表：html4为定义列表(definition lists)，html5为描述列表(description list)<br>加以严格限制的cite元素：定义引用。可使用该标签对参考文献的引用进行定义，比如书籍或杂志的标题。不用来表示作者，除非标题是作者<br>重新定义的small元素：The small element represents side comments such as small print.而非通用展示性元素，通常用在诸如免责声明、注意事项、法律法规、版权声明等声明文字中，不应该应用在页面主体内容中</p>
<h3 id="文件API"><a href="#文件API" class="headerlink" title="文件API"></a>文件API</h3><p>FileList对象和file对象：files返回一个FileList对象<br>Blob对象：Blob对象有两个属性，size属性表示一个Blob对象的字节长度，type属性表示MIME类型，file对象也继承了这个对象<br>FilReader接口：FileReader接口有4个方法，其中3个用来读取文件，一个用来中断读取。无论读取成功还是失败，方法不返回读取结果，结果保存在result属性中。<br>4个接口方法：readAsDataURL、readAsBinaryString、readAsText、abort<br>FileReader接口事件：onabort、onerror、onloadstart、onprogress、onload、onloadend<br>FileSystem<br>在使用FileSystem对象的相关应用接口时，首先要获得对沙箱文件系统的访问权限。<br>通过这个接口，可以进行文件的新建、修改、删除。</p>
<pre><code>//获取兼容文件请求对象
window.requestFileSystem = window.requestFileSystem || window.webkitRequestFileSystem;
//请求获取浏览器沙箱文件系统
//window.webkitStorageInfo.requestQuota is deprecated
 navigator.webkitPersistentStorage.requestQuota(5*1024*1024,function(bytes)&#123;
     window.requestFileSystem(window.PERSISTENT,bytes,function(file_system)&#123;
     console.log(file_system);
 &#125;,function()&#123;&#125;);
 &#125;,function(e)&#123;
     console.log(&#39;Error&#39;,e);
 &#125;);
</code></pre>
<p>目前只有chrome支持，需启动本地服务。安装chrome扩展程序HTML5 FileSystem Explorer进行查看验证。</p>
<h3 id="拖放API"><a href="#拖放API" class="headerlink" title="拖放API"></a>拖放API</h3><p>实现拖放的步骤<br>在HTML5中要实现拖放操作，至少要经过以下两个步骤：<br>1)将想要拖放的对象元素的draggable属性设为true(draggable=”true”)。这样才能将元素进行拖放。另外img元素与a元素（必须指定href）默认拖放。<br>2)编写与拖放有关的事件处理代码。拖放的几个事件：<br>dragstart：被拖放的元素<br>drag：被拖放的元素<br>dragenter：拖放过程中鼠标经过的元素<br>dragover：拖放过程中鼠标经过的元素<br>dragleave：拖放过程中鼠标经过的元素<br>drop：拖放的目标元素<br>dragend：拖放的目标元素</p>
<pre><code>&lt;h2&gt;drag示例&lt;/h2&gt;
&lt;div id=&quot;dragme&quot; draggable=&quot;true&quot; style=&quot;width:200px;height:200px;border: 1px solid;&quot;&gt;请拖放&lt;/div&gt;
&lt;div id=&quot;text&quot; style=&quot;width:200px;height:200px;border: 1px solid;&quot;&gt;&lt;/div&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
    function init()&#123;
        //自定义图标
        var dragIcon = document.createElement(&#39;img&#39;);
        dragIcon.src = &#39;http://www.iconpng.com/png/miui-fruitsugar/twelvekeydialer.png&#39;;
        var source = document.getElementById(&#39;dragme&#39;);
        var dest = document.getElementById(&#39;text&#39;);
        //(1)拖放开始
        source.addEventListener(&#39;dragstart&#39;,function(e)&#123;
            //向dataTransfer对象追加数据
            var dt = e.dataTransfer;
            dt.effectAllowed = &#39;all&#39;;
            dt.setDragImage(dragIcon,-10,-10);
            dt.setData(&#39;text/plain&#39;,&#39;你好&#39;); //setData一般采用两种两种数据格式，用于文本数据存储的&quot;text/plain&quot;和用于URL信息存储的&quot;text/uri-list&quot;
        &#125;,false);
        //(2)拖放事件
        dest.addEventListener(&#39;drop&#39;,function(e)&#123;
            var dt = e.dataTransfer;
            var text = dt.getData(&#39;text/plain&#39;);
            dest.textContent += text;
        &#125;,false);
        //(3)不执行默认处理（拒绝被拖放）
        dest.addEventListener(&#39;dragover&#39;,function(e)&#123;
            e.preventDefault(); //必须，阻止默认行为
        &#125;,false);
    &#125;
    init();
&lt;/script&gt;
</code></pre>
<h2 id="处理浏览器兼容性与Modernizr库"><a href="#处理浏览器兼容性与Modernizr库" class="headerlink" title="处理浏览器兼容性与Modernizr库"></a>处理浏览器兼容性与Modernizr库</h2><h3 id="处理浏览器兼容性"><a href="#处理浏览器兼容性" class="headerlink" title="处理浏览器兼容性"></a>处理浏览器兼容性</h3><p>一般较为常见的安全检测手段有4种：<br>1)检测全局对象，如window、navigator是否拥有指定的属性，如离线存储、地址位置信息等<br>2)通过创建新元素，检查元素对象上是否拥有指定的属性，如Canvas等。<br>3)通过创建新元素，检查元素对象上是否拥有指定的方法，同时调用该方法，并判断返回值，如检查video元素支持的视频格式<br>4)通过创建新元素，设置元素对象上的指定属性值，并判断设定后的值是否被保留。</p>
<h3 id="Modernizr库概述"><a href="#Modernizr库概述" class="headerlink" title="Modernizr库概述"></a>Modernizr库概述</h3><p>随着HTML5和CSS3加入越来越多的模块，检查各种浏览器是否支持这些模块，成了一大难题。Modernizr就是用来解决这个问题的一个JavaScript库。<br>首先，从modernizr.com下载这个库。下载的时候，可以选择所需要的模块。然后，将它插入HTML页面的头部，放在head标签之中。</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html class=&quot;no-js&quot; lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;utf-8&quot;&gt;
  &lt;script src=&quot;js/modernizr.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;/html&gt;
</code></pre>
<h3 id="Modernizr库CSS的新增class"><a href="#Modernizr库CSS的新增class" class="headerlink" title="Modernizr库CSS的新增class"></a>Modernizr库CSS的新增class</h3><p>使用Modernizr以后，首先会把html元素的class替换掉。以chrome浏览器为例，新增的class大概是下面的样子。</p>
<pre><code>&lt;html class=&quot;js no-touch postmessage history multiplebgs boxshadow opacity cssanimations csscolumns cssgradients csstransforms csstransitions fontface localstorage sessionstorage svg inlinesvg blobbuilder blob bloburls download formdata&quot;&gt;
</code></pre>
<p>IE 7则是这样：</p>
<pre><code>&lt;html class=&quot;js no-touch postmessage no-history no-multiplebgs no-boxshadow no-opacity no-cssanimations no-csscolumns no-cssgradients no-csstransforms no-csstransitions fontface localstorage sessionstorage no-svg no-inlinesvg wf-loading no-blobbuilder no-blob no-bloburls no-download no-formdata&quot;&gt;
</code></pre>
<p>然后，就可以针对不同的CSS class，指定不同的样式。</p>
<pre><code>.button &#123;
   background: #000;
   opacity: 0.75;
&#125;

.no-opacity .button &#123;
   background: #444;
&#125;
</code></pre>
<h3 id="Modernizr库JavaScript侦测"><a href="#Modernizr库JavaScript侦测" class="headerlink" title="Modernizr库JavaScript侦测"></a>Modernizr库JavaScript侦测</h3><p>除了提供新增的CSS class，Modernizr还提供JavaScript方法，用来侦测浏览器是否支持某个功能。</p>
<pre><code>Modernizr.cssgradients; //True in Chrome, False in IE7

Modernizr.fontface; //True in Chrome, True in IE7

Modernizr.geolocation; //True in Chrome, False in IE7

if (Modernizr.canvas)&#123;
    // 支持canvas
&#125; else &#123;
   // 不支持canvas
&#125;

if (Modernizr.touch)&#123;
    // 支持触摸屏
&#125; else &#123;
   // 不支持触摸屏
&#125;
</code></pre>
<h3 id="Modernizr库加载器"><a href="#Modernizr库加载器" class="headerlink" title="Modernizr库加载器"></a>Modernizr库加载器</h3><p>Modernizr允许根据Javascript侦测的不同结果，加载不同的脚本文件。</p>
<pre><code>Modernizr.load(&#123;
  test :        Modernizr.localstorage,
  yep  :        &#39;localStorage.js&#39;,
  nope :        &#39;alt-storageSystem.js&#39;,
  complete :    function () &#123; enableStorgeSaveUI();&#125;
&#125;);
</code></pre>
<p>Modernizr.load方法用来加载脚本。它的属性如下：<br>test：用来测试浏览器是否支持某个属性。<br>yep：如果浏览器支持该属性，加载的脚本。<br>nope：如果浏览器不支持该属性，加载的脚本。<br>complete：加载完成后，运行的JavaScript代码。<br>可以指定在支持某个功能的情况，所要加载的JavaScript脚本和CSS样式。</p>
<pre><code>Modernizr.load(&#123;
  test : Modernizr.touch,
  yep :  [&#39;js/touch.js&#39;, &#39;css/touchStyles.css&#39;]
&#125;);
</code></pre>
<p>本章Modernizr部分来自阮一峰的JavaScript标准参考教程的<a target="_blank" rel="noopener" href="http://javascript.ruanyifeng.com/library/modernizr.html">Modernizr</a></p>
<h2 id="绘制图形"><a href="#绘制图形" class="headerlink" title="绘制图形"></a>绘制图形</h2><h3 id="canvas元素的基础知识"><a href="#canvas元素的基础知识" class="headerlink" title="canvas元素的基础知识"></a>canvas元素的基础知识</h3><p>canvas：画布<br>检测Canvas强化版：</p>
<pre><code>function isSupportCanvas()&#123;
    var cvs = document.createElement(&#39;canvas&#39;);
    // 首先判断getContext方法是否存在
    if(!cvs.getContext)&#123;
        return false;
    &#125;
    // 判断是否含有fillText方法
    return typeof cvs.getContext(&#39;2d&#39;).fillText == &#39;function&#39;;
&#125;
</code></pre>
<p>绘制矩形<br>用canvas绘制图形时，需要经过几道步骤：<br>1)取得canvas元素<br>2)取得上下文(context)：getContent方法<br>3)设定绘图样式(style)：fillStyle、strokeStyle<br>4)指定线宽：lineWidth<br>5)context.fillRect(x,y,width,height)<br>context.strokeRect(x,y,width,height)<br>context.clearRect(x,y,width,height)<br>填充(fill)和绘制边框(stroke)</p>
<h3 id="使用路径"><a href="#使用路径" class="headerlink" title="使用路径"></a>使用路径</h3><p>绘制圆形<br>开始创建路径：beginPath方法<br>创建图形的路径：context.arc(x,y,radius,startAngle,endAngle,anticlockwise)<br>路径创建完成后关闭路径: closePath方法<br>设定绘制样式，调用绘制方法，绘制路径。</p>
<p>如果路径没有关闭：已经创建的路径会永远保留着，即使绘制完毕后，因此会进行重叠绘制，因此要对路径进行管理</p>
<p>moveTo(x,y)和lineTo(x,y)</p>
<p>使用bezierCurveTo绘制曲线：context.bezierCurveTo(cp1x,cp1y,cp2x,cp2y,x,y);<br>二次样条曲线：context.quadraticCurveTo(in float cpx,in float cpy,in float x,in float y);</p>
<h3 id="绘制渐变图形"><a href="#绘制渐变图形" class="headerlink" title="绘制渐变图形"></a>绘制渐变图形</h3><p>绘制线性渐变：context.createLinearGradient(xStart,ySTart,xEnd,yEnd)<br>设定渐变颜色：context.addColorStop(offset,color)，渐变起点offset为0,渐变结束点为1。然后将style设定为LinearGradient对象。<br>绘制径向渐变：context.createRadialGradient(xStart,yStart,radiusStart,xEnd,yEnd,radiusEnd);</p>
<h3 id="绘制变形图形"><a href="#绘制变形图形" class="headerlink" title="绘制变形图形"></a>绘制变形图形</h3><p>坐标变换</p>
<ol>
<li>平移：context.translate(x,y);</li>
<li>缩放：context.scale(x,y);</li>
<li>旋转：context.rotate(angle);<br>坐标变换与路径的结合使用：另外写一个创建路径的函数，然后在坐标变换的同时调用该函数</li>
</ol>
<p>矩阵变换<br>context.transform(a,b,c,d,e,f);<br>这个方法与css3 matrix方法差不多<br>1)矩阵与translate(x,y)：(1,0,0,1,x,y)<br>2)矩阵与scale(x,y)：(x,0,0,y,0,0)<br>3)矩阵与rotate(angle)：(Math.cos(angle * Math.PI / 180),Math.sin(angle * Math.PI / 180),-Math.cos(angle * Math.PI / 180),Math.sin(angle * Math.PI / 180),0,0)<br>4)矩阵与skew(anglex,angley)：(1,Math.tan(angley * Math.PI / 180),Math.tan(anglex * Math.PI / 180),1,0,0)（css3 非context方法）</p>
<p>矩阵是一种高级应用，可以做一些没有提供的效果，比如镜像对称效果：((1-k<em>k) / (1+k</em>k), 2k / (1 + k<em>k), 2k / (1 + k</em>k), (k<em>k - 1) / (1+k</em>k), 0, 0)</p>
<p>可以用setTransform(a,b,c,d,e,f)方法来重置变换矩阵</p>
<h3 id="图形组合"><a href="#图形组合" class="headerlink" title="图形组合"></a>图形组合</h3><p>context.globalCompositeOperation = type;<br>type值：”source-over”,”destination-over”,”source-in”,”destination-in”,”souce-out”,”destination-out”,”source-atop”,”destination-atop”,”lighter”,”copy”,”xor”</p>
<h3 id="给图形绘制阴影"><a href="#给图形绘制阴影" class="headerlink" title="给图形绘制阴影"></a>给图形绘制阴影</h3><p>shadowOffsetX(),shadowOffsetY(),shadowColor(),shadowBlur()。如果想要后面的图形不再有阴影，只要把shadowColor设定为rgba(0,0,0,0)就可以了。</p>
<h3 id="使用图像"><a href="#使用图像" class="headerlink" title="使用图像"></a>使用图像</h3><p>绘制图像</p>
<pre><code>context.drawImage(image,x,y)
context.drawImage(image,x,y,w,h)
context.drawImage(image,sx,sy,sw,sh,dx,dy,dw,dh)
var image = new Image();
image.src = &quot;img/17.jpg&quot;;
image.onload = function()&#123;&#125;;
</code></pre>
<p> 图像平铺<br>一是使用drawImage方法循环处理，二是使用context.createPattern(image,type);<br>type: no-repeat,repeat-x,repeat-y,repeat<br>使用createPattern方法创建填充样式，然后将该样式指定给图形上下文对象的fillStyle属性，最后再填充画布。</p>
<p>图像裁剪<br>使用图形上下文不带参数的clip方法来实现canvas元素的图像裁剪功能。该方法使用路径来对canvas画布设置一个裁剪区域。因此先创建路径，设置裁剪区域，再绘制图像。<br>如何取消裁剪区域：使用绘制状态的保存和恢复功能。save方法和restore方法。</p>
<p>像素处理<br>反显：</p>
<pre><code>var imagedata;
var i;
var n = imagedata.data.length;
context.drawImage(image,0,0);
imagedata = context.getImageData(0,0,image.width,image.height);
for( i = 0; i &lt; n; i += 4)&#123;
    imagedata.data[i] = 255 - imagedata.data[i];
    imagedata.data[i+1] = 255 - imagedata.data[i+1];
    imagedata.data[i+2] = 255 - imagedata.data[i+2];
&#125;
context.putImageData(imagedata,0,0);
</code></pre>
<h3 id="绘制文字"><a href="#绘制文字" class="headerlink" title="绘制文字"></a>绘制文字</h3><p>fillText(text,x,y,[maxWidth]);<br>strokeText(text,x,y,[maxWidth]);<br>font属性、fontAlign属性、fontBaseline属性<br>context.measureText(text);</p>
<h3 id="补充知识"><a href="#补充知识" class="headerlink" title="补充知识"></a>补充知识</h3><p>保存与恢复状态<br>图形上下文对象的当前状态的保存与恢复可以应用在以下场合：<br>1)图像或图形变形<br>2)图像裁剪<br>3)改变图形上下文以下属性时：<br>fillStyle<br>font<br>globalAlpha<br>globalCompositionOperation<br>lineCap<br>lineJoin<br>lineWidth<br>miterLimit<br>shadowBlur<br>shadowColor<br>shadowOffsetX<br>shadowOffsetY<br>strokeStyle<br>textAlign<br>textBaseline<br>clipping区域<br>转换矩阵等<br>最后保存的最先还原</p>
<p>保存文件<br>canvas API保存文件的原理实际上是把当前的绘画状态输出到一个data URL地址所指向的数据中的过程。<br>canvas.toDataURL(type);<br>type表示输出数据的MIME类型</p>
<p>简单动画的制作<br>1)预先编写好用来绘图的函数，在改函数中先用clearRect方法将画布整体或局部擦除<br>2)使用setInterval方法设置动画的间隔时间</p>
<p>canvas动画学习参考：<br>1.<a target="_blank" rel="noopener" href="https://www.pureweber.com/article/html5-cavas-animation/">HTML5-Canvas动画原理</a><br>2.<a target="_blank" rel="noopener" href="http://taobaofed.org/blog/2016/02/22/canvas-performance/">Canvas 最佳实践（性能篇）</a></p>
<h3 id="其他相关"><a href="#其他相关" class="headerlink" title="其他相关"></a>其他相关</h3><p>SVG<br>SVG是Scalable Vecotor Graphics的缩写，即可缩放矢量图形，是基于XML(可扩展标记语言)用来描述二维矢量图形的一种图形格式。<br>SVG有如下优点：<br>1.基于XML，继承了XML的扩平台和可扩展的特性<br>2.采用文本描述图形对象，利用搜索引擎通过文本内容搜索图片信息<br>3.良好的交互和动态特性，可以在其中嵌入动画，通过脚本收缩、旋转调整图形<br>4.对DOM支持完整，可以通过脚本获取元素，监听元素事件<br>5.体积小下载快，在互联网上传输有明显优势<br>WebGL</p>
<h2 id="媒体播放"><a href="#媒体播放" class="headerlink" title="媒体播放"></a>媒体播放</h2><pre><code>&lt;video id=&quot;player&quot; width=&quot;600&quot; height=&quot;450&quot; controls preload&gt;您的浏览器不支持HTML5
    &lt;source src=&quot;./videos/echo-hereweare.mp4&quot;&gt;&lt;/source&gt;  &lt;!-- 提供默认的播放视频  --&gt;
&lt;/video&gt;
</code></pre>
<p>1)video播放相关API</p>
<p>只读属性：<br>video.duration：整个媒体文件的播放时长，单位s<br>video.paused ：如果媒体文件被暂停，则返回true；如果还没开始播放，默认返回true<br>video.ended ：如果媒体文件播放完毕，则返回true</p>
<p>可写属性：<br>video.currentTime：以s为单位返回从开始播放到现在所用的时间。在播放过程中，设置currentTime来进行搜索，并定位到媒体文件的特定位置<br>video.volume ：在0.0到1.0之间设置音频音量的相对值，或者查询当前音量相对值<br>video.muted ：检测当前是否为静音，是则为true；为文件设置静音或消除静音</p>
<p>控制函数：<br>video.play() ：播放视频文件<br>video.pause() ：暂停处于播放状态的视频文件<br>video.canPlayType() ：测试video元素是否支持给定MIME类型的文件</p>
<p>监听事件：<br>ontimeupdate ：当video.currentTime发生改变时触发该事件</p>
<p>2)全屏控制API<br>说明：这里只给出webkit的全屏API，本代码没有做兼容性处理，主要应用了webkit的一些高级API和chrome的伪元素，所以前面请大家用chrome打开演示地址。</p>
<p>video.webkitRequestFullScreen()：全屏显示<br>document.webkitCancelFullScreen()：退出全屏<br>document.webkitIsFullScreen：如果当前处于全屏状态，则返回true,否则返回false<br>document.addEventListener(‘webkitfullscreenchange’, handler)：当在全屏和非全屏状态切换时，触发该事件</p>
<p>3)本地文件读取API<br>说明：我的这个视频播放器支持从本地添加视频文件播放，支持的格式在webkit浏览器支持的html5视频播放标准范围内。本地文件读取API是html5的新标准。</p>
<p>window.URL.createObjectURL(file)：file为文件对象，该函数返回指向文件的对象URL，通过该URL可以访问文件。</p>
<p>video.src = window.URL.createObjectURL(file);</p>
<p>音视频的实时通信：WebRTC技术，该技术主要用于支持浏览器进行实时的语音对话和视频通信。</p>
<p>视频播放学习参考：<br>1.<a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000000380064">打造自己的html5视频播放器</a><br>2.<a target="_blank" rel="noopener" href="http://taobaofed.org/blog/2016/05/23/video-player/">视频播放的那些事</a></p>
<h2 id="本地存储"><a href="#本地存储" class="headerlink" title="本地存储"></a>本地存储</h2><h3 id="Web-Storage"><a href="#Web-Storage" class="headerlink" title="Web Storage"></a>Web Storage</h3><p>cookie会带来什么问题：<br>1)cookie大小限制在4k左右，不适合存业务数据<br>2)cookie每次随HTTP事务一起发送，浪费带宽<br>localstorage可以说是对cookie的优化，使用它可以方便在客户端存储数据，并且不会随着HTTP传输，但也不是没有问题：</p>
<p>1)localstorage大小限制在5m左右，各个浏览器不一致<br>2)localstorage在隐私模式下不可读取<br>3)localstorage本质是在读写文件，数据多的话会比较卡（firefox会一次性将数据导入内存，想想就觉得吓人啊）<br>4)localstorage不能被爬虫爬取，不要用它完全取代URL传参</p>
<p>sessionStorage：<br>保存数据：sessionStorage.setItem(key,value);<br>读取数据：sessionStorege.getItem(key);<br>localStorage:<br>保存数据：localStorage.setItem(key,value);<br>读取数据：localStorege.getItem(key);<br>localStorage.length<br>localStorage.key(index)<br>localStorage.clear()</p>
<h3 id="本地数据库"><a href="#本地数据库" class="headerlink" title="本地数据库"></a>本地数据库</h3><h3 id="SQLLite"><a href="#SQLLite" class="headerlink" title="SQLLite"></a>SQLLite</h3><p>要使用SQLLite数据库，有两个必要的步骤：<br>1)创建访问数据库的对象<br>2)使用事务处理<br>var db = openDatabase(‘mydb’,’1.0’,’Test DB’,2 * 1024 *1024);<br>db.transaction(function(tx){<br>    tx.executeSql(‘CREATE TABLE IF EXISTS LOGS (id unique Log)’);<br>});<br>transaction方法中的处理<br>1)追加数据<br>tx.executeSql(‘INSERT INFO MsgData VALUES(?,?,?)’,[name,message,time],function(tx,rs){},function(tx,error));<br>2)创建数据表<br>tx.executeSql(‘CREATE TABLE IF NOT EXISTS MsgData(name TEXT,message TEXT,tiem INTEGER)’,[]);<br>3)获取全部数据<br>tx.ececuteSql(‘SELECT * FROM MsgData’,[],…);</p>
<h3 id="indexedDB"><a href="#indexedDB" class="headerlink" title="indexedDB"></a>indexedDB</h3><p>indexedDb是HTML5推出的一种轻量级的NoSQL数据库，即常说的非关系型数据库。比起传统的关系型数据库，NoSQL数据库具有易扩展、读写快速、成本低廉等特点。HTML5的IndexedDB还包含了常见的数据库构造，如事务、索引、游标等，在API的使用上分为同步和异步两种形态。</p>
<pre><code>// 创建一个数据库
var request = indexedDB.open(&#39;Html5IndexedDB&#39;,2);
request.onerror = function(e)&#123;
    console.log(e);
&#125;;
//监听事务事件
request.onupgradeneeded = function(e)&#123;
    // 获取数据库对象
    var db = e.target.result;
    // 创建对象存储空间存放用户信息
    objectStore = db.createObjectStore(&#39;users&#39;,&#123;keyPath:&quot;html5&quot;&#125;);
    // 创建索引来通过name搜索客户
    objectStore.createIndex(&#39;name&#39;,&#39;name&#39;,&#123;unique:false&#125;);
    objectStore.createIndex(&#39;id&#39;,&#39;id&#39;,&#123;unique:true&#125;);
    objectStore.add(&#123;html5:&#39;1&#39;,name:&#39;小王&#39;,sex:&#39;女&#39;,id:&#39;3323&#39;,age:23&#125;);
&#125;
</code></pre>
<h2 id="离线应用程序"><a href="#离线应用程序" class="headerlink" title="离线应用程序"></a>离线应用程序</h2><p>离线Web应用程序是指：当客户端本地与Web应用程序的服务器没有建立连接时，也能正常在客户端使用该Web应用程序进行有关操作。</p>
<h3 id="本地缓存和浏览器缓存的区别："><a href="#本地缓存和浏览器缓存的区别：" class="headerlink" title="本地缓存和浏览器缓存的区别："></a>本地缓存和浏览器缓存的区别：</h3><p>1)本地缓存为整个web应用程序服务的，而浏览器的网页缓存只服务于单个网页。任何网页都具有网页缓存。而本地缓存至缓存那些指定的缓存的页面。</p>
<p>2)网页缓存不安全不可靠，因为我们不知道在网站中到底缓存了哪些网页，以及缓存了网页上的哪些资源。而本地缓存可靠，我们可以控制对哪些内容进行缓存，不对哪些内容进行缓存，开发人员还可以利用编程的手段来控制缓存的更新，利用缓存对象的各种属性、状态和事件来开发出更加强大的离线应用程序。</p>
<p>3)（有些）浏览器会主动保存自己的缓存文件以加快网站加载速度。但是要实现浏览器缓存必须要满足一个前提，那就是网络必须要保持连接。如果网络没有连接，即使浏览器启用了对一个站点的缓存，依然无法打开这个站点。只会收到一条错误信息。而使用离线web应用，我们可以主动告诉浏览器应该从网站服务器中获取或缓存哪些文件，并且在网络离线状态下依然能够访问这个网站。</p>
<h3 id="实现HTML5应用程序缓存"><a href="#实现HTML5应用程序缓存" class="headerlink" title="实现HTML5应用程序缓存"></a>实现HTML5应用程序缓存</h3><p>实现HTML5应用程序缓存非常简单，只需三步，并且不需要任何API。只需要告诉浏览器需要离线缓存的文件，并对服务器和网页做一些简单的设置即可实现。<br>1)创建一个 cache.manifest 文件，并确保文件具有正确的内容。<br>2)在服务器上设置内容类型。<br>3)所有的HTML文件都指向 cache.manifest。</p>
<p>具体实现：<br>首先我们建立一个名为cache.manifest的文件，Windows平台下用记事本即可（也可用其他的IDE）。文件内容如下：</p>
<pre><code>CACHE MANIFEST
#version1
CACHE:
index.html
404.html
favicon.ico
robots.txt
humans.txt
apple-touch-icon.png
css/normalize.min.css
css/main.css
css/bootmetro-icons.min.css
img/pho-cat.jpg
img/pho-huangshan.jpg
 
FALLBACK:
online.js local.js
 
NETWORK:
*
</code></pre>
<p>注意事项：<br>1)第一行必须是”CACHE DMANIFEST”文字，以把本文件的作用告知浏览器，即对本地缓存中的资源文件进行具体设置。<br>2)在manifest文件中，可以加上注释来进行一些必要说明或解释。注释行以”#”文字开头。<br>3)在CACHE之后的部分为列出我们需要缓存的文件。<br>4)在FALLBACK之后的部分每一行中指定两个资源文件，第一个资源文件为能够在线访问时使用的资源文件，第二个资源文件为不能在线访问时使用的备用资源文件。<br>5)在NETWORK之后可以指定在线白名单，即列出我们不希望离线存储的文件，因为通常它们的内容需要互联网访问才有意义。另外，在此部分我们可以使用快捷方式：通配符*。这将告诉浏览器，应用服务器中获取没有在显示部分中提到的任何文件或URL。</p>
<p>服务器上设置内容类型。<br>真正运行或测试离线web应用程序的时候，需要对服务器进行配置，让服务器支持text/cache-manifest这个MIME类型（在h5中规定manifest文件的MIME类型是text/cache-manifest）。例如对Apache服务器进行配置的时候，需要找到｛apache_home｝/conf/mime.type这个文件(.htaccess)，并在文件最后添加如下所示代码：</p>
<pre><code>text/cache-manifest .manifest 
</code></pre>
<p>在微软的IIS服务器中的步骤如下所示：<br>(1).右键选择默认网站或需要添加类型的网站，弹出属性对话框<br>(2).选择”http头”标签<br>(3).在MIME映射下，单击文件类型按钮<br>(4).在打开的MIME类型对话框中单击新建按钮<br>(5).在关联扩展名文本中输入”manifest”，在内容类型文本框中输入”text/cache-manifest”,然后点击确定按钮。</p>
<p>设置HTML文件的指向。<br>完成这一步后，就完成了web离线缓存的所有步骤。由于浏览的文件内容都没有更改且存储在本地，因此现在网页的打开速度会更快（即使是在线状态也如此）。</p>
<p>注意事项：<br>1)网站的每一个html页面都必须设置html元素的manifest属性。<br>2)在你的整个网站应用中，只能有一个cache.manifest文件（建议放在网站根目录下）；<br>3)部分浏览器（如IE8-）不支持HTML5离线缓存；<br>4)“#” 开头的注释行可满足其他用途。应用的缓存会在其manifest文件更改时被更新。如果您编辑了一幅图片，或者修改了一个JavaScript 函数，这些改变都不会被重新缓存。更新注释行中的日期和版本号是一种使浏览器重新缓存文件的办法。</p>
<h3 id="applicationCache的两个方法"><a href="#applicationCache的两个方法" class="headerlink" title="applicationCache的两个方法"></a>applicationCache的两个方法</h3><p>applicationCache的update方法<br>显式调用了更新缓存算法以检测是否有最新版本的的应用程序。这导致浏览器检测同一个清单文件（并触发相同的事件），这和第一次载入应用程序时的效果是一样的。<br>applicationCache的swapCache方法：<br>它告诉浏览器可以弃用老缓存，所有的请求都从新缓存中获取。注意，这并不会重新载入应用程序：所有已经载入的html文件、图片、脚本等资源都不会改变。但是，之后的请求将从最新的缓存中获取。这会导致“版本错乱”的问题，因此一般不推荐使用，除非应用程序设计得很好，确保这样的方式没有问题。只有ApplicationCache.UPDATEREADY和ApplicationCache.ABSOLETE 时调用swapCache()才有意义（当状态OBSOLETE时，调用它可以立即弃用废弃的缓存，让之后所有的请求都通过网络获取）。如果状态属性是其他数值的时候调用swapCache()方法，它就会抛出异常。</p>
<pre><code>function init()&#123;
    setInterval(function()&#123;
        //手工检查是否更新
        applicationCache.update();
    &#125;,5000);
    applicationCache.addEventListener(&#39;updateready&#39;,function()&#123;
        if( confirm(&quot;本地缓存已被更新，需要刷新页面来获取应用程序最新版本，是否刷新？&quot;) )&#123;
            // 手工更新本地缓存
            applicationCache.swapCache();
            // 重置画面
            location.reload();
        &#125;
    &#125;,true);
&#125;
init();
</code></pre>
<h3 id="applicationCache对象的事件"><a href="#applicationCache对象的事件" class="headerlink" title="applicationCache对象的事件"></a>applicationCache对象的事件</h3><p>1.checking事件<br>2.downloading事件<br>3.progress事件<br>4.cached事件<br>5.noupdate事件<br>6.updateready事件<br>7.obsolete事件<br>8.error事件</p>
<p>(1).没有可用更新<br>如果应用程序已经缓存并且清单文件没有动，则浏览器会触发noupdate事件<br>(2).有可用更新<br>如果应用程序已经缓存并且清单元件有改动，则浏览器会触发downloading事件并开始下载和缓存清单文件中列举的所有资源。随着下载过程的进行浏览器还会触发”progress”事件，在下载完成后，会触发”updateready”事件。<br>(3).首次载入新的应用程序<br>如果还未缓存应用程序，如上所述downloading，progress事件都会触发。但是，当下载完成后，浏览器会触发”cached”事件而不是updateready事件<br>(4).浏览器处于离线状态<br>如果浏览器处于离线状态，它无法检查清单文件，同时它会触发“error”事件。如果一个未缓存的应用程序引用了不存的清单文件，浏览器也会触发该事件<br>(5).清单文件不存在<br>如果浏览器处理在线状态，应用程序也已经缓存起来，但是清单文件不存在，浏览器会触发obsolete事件，并将该应用程序从缓存中移除。</p>
<h3 id="如何判断在线还是离线状态？"><a href="#如何判断在线还是离线状态？" class="headerlink" title="如何判断在线还是离线状态？"></a>如何判断在线还是离线状态？</h3><p>navigator.onLine是HTML5定义用来检测设备是在线还是离线。对应的值为false或true。<br>HTML5定义了online和offline事件用于监听网络状态变化。</p>
<pre><code>window.addEventListener(&#39;online&#39;, callback); // 离线到上线
window.addEventListener(&#39;offline&#39;, callback); // 上线到离线
</code></pre>
<h2 id="通信API"><a href="#通信API" class="headerlink" title="通信API"></a>通信API</h2><h3 id="跨文档消息传输"><a href="#跨文档消息传输" class="headerlink" title="跨文档消息传输"></a>跨文档消息传输</h3><p>跨文档消息传递（Cross Document Messaging），有时候简称XDM。指的是来自不同域的页面间传递消息。比如：abc.com与内联框架中的efg.com进行通信。</p>
<p>XDM的核心是postMessage()方法，这是HTML5规范的api，意思就是向另一个地方发送消息，除了XDM中有postMessage()方法，在HTML5规范中，其他地方也有相同的方法名，比如web worker中、WebSockets以及Server-SentEvents中。但目的都是向另一个地方发送数据，只不过在XDM中，另一个地方指的是页面中的iframe框架，或者由当前页面弹出的窗口。</p>
<p>postMessage()方法</p>
<p>postMessage()方法接收两个参数：postMessage(message, targetOrigin):</p>
<p>message：传递的消息，可以是任意的数据类型，不过为了保证兼容性，最好只传递字符串（部分浏览器智能处理字符串），对于对象的数据，可以先用JSON.stingify()方法转成字符串，然后再通过JSON.parse()方法转成对象。在低版本的浏览器中，可以使用json2.js实现相同的效果。<br>targetOrigin：消息接收方的域（URL地址）。postMessage会将message发送到该窗口，如果不指定目标源，可以设置成*，表示消息发送到任意窗口。第二个参数对保障安全通信非常重要，可以防止浏览器把消息传递到不安全的地方。</p>
<p>postMessage()方法实践</p>
<p>本地建立一个html文件：</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;postMessage&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;input type=&quot;text&quot; id=&quot;message&quot;&gt;&lt;button&gt;发送消息&lt;/button&gt;
&lt;iframe src=&quot;http://localhost:63342/post%20text/iframe.html&quot; id=&quot;iframe1&quot;&gt;&lt;/iframe&gt;
&lt;script&gt;
    window.onload = function()&#123;
        var message = document.getElementById(&quot;message&quot;),
                btn = document.getElementsByTagName(&quot;button&quot;)[0],
                iframe = document.getElementById(&quot;iframe1&quot;);

        var iWin = iframe.contentWindow;

        btn.onclick = function()&#123;
            iWin.postMessage(message.value,&quot;http://localhost:63342/post%20text/test.html&quot;);
        &#125;
    &#125;
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>iframe页面</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head lang=&quot;en&quot;&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;script&gt;
        window.onmessage = function(e)&#123;
            console.log(e);
            document.body.innerHTML = &quot;&quot;;
            document.body.innerHTML = e.data;
        &#125;
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>这样，当我在文本框中输入内容并且点击发送的时候，框架就可以获取到我发送的信息，从而可以进行相应的操作。</p>
<p>onmessage事件<br>当接收到XDM消息时，触发window对象的onmessage事件，这个事件是以异步形式触发的。onmessage事件有三个重要的参数：data，origin，source。</p>
<p>data：postMessage传递进来的值<br>origin：发送消息的文档所在的域<br>source：发送消息文档的window对象的代理，如果是来自同一个域，则该对象就是window，可以使用其所有方法，如果是不同的域，则该window是不能使用的，除了调用postMessage()方法之外。<br>接收到消息后，验证消息的来源是很重要的，就像给postMessage()方法指定第二个参数，以确保浏览器不会把消息发送给其他框架一样。判断其origin即可判断来源：</p>
<pre><code>//iframe页面
window.onmessage = function(e)&#123;
    if(e.origin === &#39;http://sandbox.runjs.cn&#39;)&#123;
        //处理数据
        //接收相应
        e.source.postMessage(&quot;已经收到信息！&quot;, &quot;http://localhost:63342/post%20text/test.html&quot;&quot;);
    &#125;
&#125;
</code></pre>
<p>浏览器兼容性<br>就像localStorage一样，IE8也支持。</p>
<p>总结</p>
<p>postMessage方法进行跨文档信息传递简单方便<br>在不同域时，event.source中的window对象为代理window对象，只能调用postMessage()方法<br>onmessage事件是window对象上得事件，在使用时注意IE的事件处理程序，attachEvent </p>
<p>原文：<a target="_blank" rel="noopener" href="http://youthol.top/2016/01/19/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%93%8D%E4%BD%9Ciframe-postmessage%E8%B7%A8%E6%96%87%E6%A1%A3%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92/">操作iframe–postMessage跨文档消息传递</a></p>
<h3 id="XMLHttpRequest-Level-2"><a href="#XMLHttpRequest-Level-2" class="headerlink" title="XMLHttpRequest Level 2"></a>XMLHttpRequest Level 2</h3><p>XMLHttpRequest Level 2是早期XMLHttpRquest的升级版，最初的XMLHttpRquest被设计为仅限于同源通信，不能跨域进行数据传输，导致后续演变出JSONP方法。XMLHttpRquest Level 2对同源策略进行了修改，允许跨域的数据请求，同时还添加了progress事件用于监听请求进度，返回进度信息。XMLHttpRquest Level 2要求所有跨域的请求都要使用HTTP协议中的origin信息头，同时数据接收服务器需要具备CORS策略，各种服务器的CORS策略设置可以参考网站<a target="_blank" rel="noopener" href="http://enable-cors.org/">http://enable-cors.org/</a><br>兼容性：IE10+<br>客户端：</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    数据：&lt;input type=&quot;text&quot;&gt;&lt;button&gt;获取&lt;/button&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
        document.querySelector(&#39;button&#39;).addEventListener(&#39;click&#39;,function(e)&#123;
            e.preventDefault()
            var xhr = new XMLHttpRequest()
            if( typeof xhr.withCredentials == undefined)&#123;
                console.log(&#39;浏览器不支持html5 XMLHttpRequst Level 2的跨域请求支持&#39;)
            &#125;else&#123;
                xhr.onload = function()&#123;
                    var data = JSON.parse(xhr.responseText)
                    document.querySelector(&#39;input&#39;).value = data.data
                &#125;
                xhr.onerror = function(e)&#123;console.log(e)&#125;
                xhr.open(&#39;GET&#39;,&#39;http://localhost:8080&#39;,true);
                xhr.send();
            &#125;
        &#125;,false);
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>服务端(nodejs)：</p>
<pre><code>var http = require(&#39;http&#39;)
http.createServer(function(req,res)&#123;
    res.setHeader(&#39;Access-Control-Allow-Origin&#39;,&#39;http://localhost:63342&#39;)
    res.setHeader(&#39;Access-Control-Allow-Methods&#39;,&#39;GET&#39;,&#39;POST&#39;)
    req.setEncoding(&#39;utf-8&#39;)
    res.end(JSON.stringify(&#123;data:&#39;Hello World!&#39;&#125;))
&#125;).listen(8080,function()&#123;
    console.log(&#39;listing on http://localhost:8080&#39;)
&#125;)
</code></pre>
<p>XMLHttpRequest Level 2对远端请求的服务器有一定的要求，需要在服务器端返回的HTTP信息头中指明支持的域名。如果想对所有请求都通过处理，可以设置为”*”号。如果要指定多个，一般会认为使用以下写法：</p>
<pre><code>res.setHeader(&#39;Access-Control-Allow-Origin&#39;,&#39;http://localhost,http://test.com&#39;); //域名之间使用逗号
res.setHeader(&#39;Access-Control-Allow-Origin&#39;,&#39;http://localhost http://test.com&#39;); //域名之间使用空格
</code></pre>
<p>非常不幸的是，浏览器无法识别这两种返回头，推荐先对请求域名做判断，如果符合业务要求，再设置对于域名的Access-Control-Allow-Origin头信息。</p>
<h3 id="Web-Socket通信"><a href="#Web-Socket通信" class="headerlink" title="Web Socket通信"></a>Web Socket通信</h3><p>在讲Websocket之前，先讲讲long poll和ajax轮询的原理。<br>首先是ajax轮询，ajax轮询的原理非常简单，让浏览器隔个几秒就发送一次请求，询问服务器是否有新信息。<br>long poll其实原理跟ajax轮询差不多，都是采用轮询的方式，不过采取的是阻塞模型（一直打电话，没收到就不挂电话），也就是说，客户端发起连接后，如果没消息，就一直不返回Response给客户端。直到有消息才返回，返回完之后，客户端再次建立连接，周而复始。<br>从上面可以看出其实这两种方式，都是在不断地建立HTTP连接，然后等待服务端处理，可以体现HTTP协议的另外一个特点，被动性。<br>何为被动性呢，其实就是，服务端不能主动联系客户端，只能有客户端发起。<br>通过上面这个例子，我们可以看出，这两种方式都不是最好的方式，需要很多资源。<br>一种需要更快的速度，一种需要更多的’电话’。这两种都会导致’电话’的需求越来越高。<br>哦对了，忘记说了HTTP还是一个无状态协议。</p>
<p>所以在这种情况下出现了，Websocket出现了。<br>他解决了HTTP的这几个难题。<br>首先，被动性，当服务器完成协议升级后（HTTP-&gt;Websocket），服务端就可以主动推送信息给客户端啦。<br>就变成了这样，只需要经过一次HTTP请求，就可以做到源源不断的信息传送了。（在程序设计中，这种设计叫做回调，即：你有信息了再来通知我，而不是我傻乎乎的每次跑来问你）<br>这样的协议解决了上面同步有延迟，而且还非常消耗资源的这种情况。<br>同时，在传统的方式上，要不断的建立，关闭HTTP协议，由于HTTP是非状态性的，每次都要重新传输identity info（鉴别信息），来告诉服务端你是谁。<br>同时由客户主动询问，转换为服务器（推送）有信息的时候就发送（当然客户端还是等主动发送信息过来的。。），没有信息的时候就交给接线员（Nginx），不需要占用本身速度就慢的客服（Handler）了<br><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/20215561">知乎参考</a><br><a target="_blank" rel="noopener" href="http://javascript.ruanyifeng.com/htmlapi/websocket.html">进一步学习</a></p>
<h3 id="Socket-IO通信框架"><a href="#Socket-IO通信框架" class="headerlink" title="Socket.IO通信框架"></a>Socket.IO通信框架</h3><p>Socket.IO是Guillermo Rauch开发的基于Node.js的应用项目，以实现跨浏览器和跨平台应用为目标。Socket.IO针对不同的浏览器会做自动优雅降级，选择当前浏览器最合适的实现方式，如在一些不支持HTML5 WebSocket的浏览器上，会使用长连接的Ajax技术。同时Socket.IO提供了一套平台统一的应用程序接口，开发者在使用时完全不用考虑浏览器的兼容问题。</p>
<h2 id="Web-Workers"><a href="#Web-Workers" class="headerlink" title="Web Workers"></a>Web Workers</h2><p>JavaScript语言采用的是单线程模型，也就是说，所有任务排成一个队列，一次只能做一件事。随着电脑计算能力的增强，尤其是多核CPU的出现，这一点带来很大的不便，无法充分发挥JavaScript的潜力。</p>
<p>Web Worker的目的，就是为JavaScript创造多线程环境，允许主线程将一些任务分配给子线程。在主线程运行的同时，子线程在后台运行，两者互不干扰。等到子线程完成计算任务，再把结果返回给主线程。因此，每一个子线程就好像一个“工人”（worker），默默地完成自己的工作。这样做的好处是，一些高计算量或高延迟的工作，被worker线程负担了，所以主进程（通常是UI进程）就会很流畅，不会被阻塞或拖慢。<br>在现实开发中Web Worker常常被用于处理大型密集型数据任务，可以有效的避免阻塞主UI线程渲染交互。</p>
<p>Worker线程分成好几种。<br>1)普通的Worker：只能与创造它们的主进程通信。<br>2)Shared Worker：能被所有同源的进程获取（比如来自不同的浏览器窗口、iframe窗口和其他Shared worker），它们必须通过一个端口通信。<br>3)ServiceWorker：实际上是一个在网络应用与浏览器或网络层之间的代理层。它可以拦截网络请求，使得离线访问成为可能。</p>
<p>Web Worker有以下几个特点：<br>1)同域限制。子线程加载的脚本文件，必须与主线程的脚本文件在同一个域。<br>2)DOM限制。子线程所在的全局对象，与主进程不一样，它无法读取网页的DOM对象，即document、window、parent这些对象，子线程都无法得到。（但是，navigator对象和location对象可以获得。）<br>3)脚本限制。子线程无法读取网页的全局变量和函数，也不能执行alert和confirm方法，不过可以执行setInterval和setTimeout，以及使用XMLHttpRequest对象发出AJAX请求。<br>4)文件限制。子线程无法读取本地文件，即子线程无法打开本机的文件系统（file://），它所加载的脚本，必须来自网络。</p>
<p>注意线程嵌套在chrome中有bug</p>
<p>线程中可用的变量、函数与类：<br>self：self关键词用来表示本线程范围内的作用域<br>postMessage(message)：向创建线程的源窗口发送信息<br>worker.postMessage()：向子线程中提交信息<br>onmessage：获取接收信息的事件句柄<br>importScripts(urls)：导入其他JavaScript脚本文件importScript(‘script1.js’,’scripts\script2.js’,’scripts\script3.js’);<br>navigator对象<br>sessionStorage、localStorage<br>XMLHttpRequest<br>Web Workers<br>setTimeout()/setInterval()<br>close：可用结束本线程<br>eval()、isNaN()、escape()等，可以使用所有JavaScript核心函数<br>object：可以创建和使用本地对象<br>WebSockets：可以使用WebSockets API来向服务器发送和接收信息</p>
<h2 id="获取地理位置"><a href="#获取地理位置" class="headerlink" title="获取地理位置"></a>获取地理位置</h2><h3 id="有哪些定位数据"><a href="#有哪些定位数据" class="headerlink" title="有哪些定位数据"></a>有哪些定位数据</h3><p>1.IP地址<br>2.GPS(Global Positioning System)<br>3.RFID(Radio Frequency IDentification，即射频识别)<br>4.Wi-Fi地址<br>5.GSM或CDMA手机的ID<br>6.用户自定义的地理位置数据</p>
<h3 id="Geolocation-API的基本知识"><a href="#Geolocation-API的基本知识" class="headerlink" title="Geolocation API的基本知识"></a>Geolocation API的基本知识</h3><p>获取当前的地理位置</p>
<pre><code>navigator.geolocation.getCurrentPosition(success,error,options);
</code></pre>
<p>第一个参数为获取当前地理位置成功时所执行的回调函数，第二个参数为获取失败时所执行的回调函数，第三个参数为一些可选属性的列表。<br>若成功，则getCurrentPosition()方法返回对象。始终会返回latitude、longitude以及accuracy属性。如果可用，则会返回其他下面的属性。<br>coords.latitude    十进制数的纬度<br>coords.longitude    十进制数的经度<br>coords.accuracy    位置精度<br>coords.altitude    海拔，海平面以上以米计<br>coords.altitudeAccuracy    位置的海拔精度<br>coords.heading    方向，从正北开始以度计<br>coords.speed    速度，以米/每秒计<br>timestamp    响应的日期/时间</p>
<p>获取当前地理位置失败<br>该回调函数使用一个error对象作为参数，这个参数具有以下两个属性：<br>code属性：<br>用户拒绝了位置服务（属性值为1）<br>获取不到位置信息（属性值为2）<br>获取信息超时错误（属性值为3）<br>message属性<br>message属性为一个字符串，在该字符串中包含了错误信息</p>
<p>getCurrentPosition方法中的第三个参数可以省略，它是一些可先属性的列表：<br>enableHighAccuracy：是否要求高精度的地理位置信息。在很多设备上设置了都没用，多数情况下把该属性设为默认。<br>timeout：超时设置<br>maximumAge：对地理位置信息进行缓存的有效时间。</p>
<p>持续监视当前地理位置信息</p>
<pre><code>watchCurrentPosition(onSuccess,onError,options);
</code></pre>
<p>停止获取用户的当前地理位置信息<br>    clearWatch(watchId)<br>使用方法和clearTimeout差不多</p>
<h2 id="微数据"><a href="#微数据" class="headerlink" title="微数据"></a>微数据</h2><p>HTML5微数据规范是一种标记内容以描述特定类型的信息，例如评论、人物信息或事件。每种信息都描述特定类型的项，例如人物、事件或评论。例如，事件可以包含venue、starting time、name和category属性。<br>微数据使用HTML标记（常为span或div）中的简单属性为项和属性指定简要的描述性名称。<br><a target="_blank" rel="noopener" href="http://www.zhangxinxu.com/wordpress/2011/12/html5%E6%89%A9%E5%B1%95-%E5%BE%AE%E6%95%B0%E6%8D%AE-%E4%B8%B0%E5%AF%8C%E7%BD%91%E9%A1%B5%E6%91%98%E8%A6%81/">HTML5扩展之微数据与丰富网页摘要</a></p>
<h2 id="History-API"><a href="#History-API" class="headerlink" title="History API"></a>History API</h2><p>HTML5中给History新增了两个方法，允许开发者逐条地添加和修改历史记录，方法如下：<br>pushState：在历史堆栈的顶部添加一条记录，history.pushState({}, “页面标题”, “xxx.html”);<br>replaceState：更改当前页面的历史记录，参数同pushState方法<br>在HTML5 History出现之前，要记录页面状态和浏览器记录只能通过Hash和iFrame两种方式。可以借助第三方类库History.js进行兼容。</p>
  
	</div>
		<footer class="article-footer clearfix">

  <div class="article-tags">
  
  <span></span> <a href="/tags/计算机/">计算机</a><a href="/tags/前端/">前端</a><a href="/tags/积累/">积累</a><a href="/tags/HTML5/">HTML5</a>
  </div>


<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</a>
</div>



<div class="article-share" id="share">

  <div data-url="http://example.com/2021/10/06/HTML5%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/" data-title="HTML5学习总结 | 欢迎来到曾安的博客" data-tsina="" class="share clearfix">
  </div>

</div>
</footer>   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/2021/10/06/JavaScript常见封装方法/" title="JavaScript常见封装方法">
  <strong>PREVIOUS:</strong><br/>
  <span>
  JavaScript常见封装方法</span>
</a>
</div>


<div class="next">
<a href="/2021/10/06/Flexbox学习总结/"  title="Flexbox学习总结">
 <strong>NEXT:</strong><br/> 
 <span>Flexbox学习总结
</span>
</a>
</div>

</nav>

	
</div>  
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">文章目录</strong>
  <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#html5%E4%B8%8Ehtml4%E5%8C%BA%E5%88%AB"><span class="toc-number">1.</span> <span class="toc-text">html5与html4区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95%E7%9A%84%E6%94%B9%E5%8F%98"><span class="toc-number">1.1.</span> <span class="toc-text">语法的改变</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B0%E5%A2%9E%E7%9A%84%E5%85%83%E7%B4%A0%E5%92%8C%E5%BA%9F%E9%99%A4%E7%9A%84%E5%85%83%E7%B4%A0"><span class="toc-number">1.2.</span> <span class="toc-text">新增的元素和废除的元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B0%E5%A2%9E%E7%9A%84%E5%B1%9E%E6%80%A7%E5%92%8C%E5%BA%9F%E9%99%A4%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="toc-number">1.3.</span> <span class="toc-text">新增的属性和废除的属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%B1%9E%E6%80%A7"><span class="toc-number">1.4.</span> <span class="toc-text">全局属性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#html5-%E7%BB%93%E6%9E%84"><span class="toc-number">2.</span> <span class="toc-text">html5 结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B0%E5%A2%9E%E7%9A%84%E4%B8%BB%E4%BD%93%E7%BB%93%E6%9E%84%E5%85%83%E7%B4%A0"><span class="toc-number">2.1.</span> <span class="toc-text">新增的主体结构元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B0%E5%A2%9E%E7%9A%84%E9%9D%9E%E4%B8%BB%E4%BD%93%E7%BB%93%E6%9E%84%E5%85%83%E7%B4%A0"><span class="toc-number">2.2.</span> <span class="toc-text">新增的非主体结构元素</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A8%E5%8D%95%E4%B8%8E%E6%96%87%E4%BB%B6"><span class="toc-number">3.</span> <span class="toc-text">表单与文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B0%E5%A2%9E%E5%85%83%E7%B4%A0%E5%92%8C%E5%B1%9E%E6%80%A7"><span class="toc-number">3.1.</span> <span class="toc-text">新增元素和属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A8%E5%8D%95%E9%AA%8C%E8%AF%81"><span class="toc-number">3.2.</span> <span class="toc-text">表单验证</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTML5%E8%A1%A8%E5%8D%95%E9%AA%8C%E8%AF%81%E6%8F%92%E4%BB%B6"><span class="toc-number">3.3.</span> <span class="toc-text">HTML5表单验证插件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A2%9E%E5%BC%BA%E7%9A%84%E9%A1%B5%E9%9D%A2%E5%85%83%E7%B4%A0"><span class="toc-number">3.4.</span> <span class="toc-text">增强的页面元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6API"><span class="toc-number">3.5.</span> <span class="toc-text">文件API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%96%E6%94%BEAPI"><span class="toc-number">3.6.</span> <span class="toc-text">拖放API</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E6%80%A7%E4%B8%8EModernizr%E5%BA%93"><span class="toc-number">4.</span> <span class="toc-text">处理浏览器兼容性与Modernizr库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E6%80%A7"><span class="toc-number">4.1.</span> <span class="toc-text">处理浏览器兼容性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Modernizr%E5%BA%93%E6%A6%82%E8%BF%B0"><span class="toc-number">4.2.</span> <span class="toc-text">Modernizr库概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Modernizr%E5%BA%93CSS%E7%9A%84%E6%96%B0%E5%A2%9Eclass"><span class="toc-number">4.3.</span> <span class="toc-text">Modernizr库CSS的新增class</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Modernizr%E5%BA%93JavaScript%E4%BE%A6%E6%B5%8B"><span class="toc-number">4.4.</span> <span class="toc-text">Modernizr库JavaScript侦测</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Modernizr%E5%BA%93%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">4.5.</span> <span class="toc-text">Modernizr库加载器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%98%E5%88%B6%E5%9B%BE%E5%BD%A2"><span class="toc-number">5.</span> <span class="toc-text">绘制图形</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#canvas%E5%85%83%E7%B4%A0%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">5.1.</span> <span class="toc-text">canvas元素的基础知识</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E8%B7%AF%E5%BE%84"><span class="toc-number">5.2.</span> <span class="toc-text">使用路径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%98%E5%88%B6%E6%B8%90%E5%8F%98%E5%9B%BE%E5%BD%A2"><span class="toc-number">5.3.</span> <span class="toc-text">绘制渐变图形</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%98%E5%88%B6%E5%8F%98%E5%BD%A2%E5%9B%BE%E5%BD%A2"><span class="toc-number">5.4.</span> <span class="toc-text">绘制变形图形</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E5%BD%A2%E7%BB%84%E5%90%88"><span class="toc-number">5.5.</span> <span class="toc-text">图形组合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%99%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E9%98%B4%E5%BD%B1"><span class="toc-number">5.6.</span> <span class="toc-text">给图形绘制阴影</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9B%BE%E5%83%8F"><span class="toc-number">5.7.</span> <span class="toc-text">使用图像</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%98%E5%88%B6%E6%96%87%E5%AD%97"><span class="toc-number">5.8.</span> <span class="toc-text">绘制文字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A5%E5%85%85%E7%9F%A5%E8%AF%86"><span class="toc-number">5.9.</span> <span class="toc-text">补充知识</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E7%9B%B8%E5%85%B3"><span class="toc-number">5.10.</span> <span class="toc-text">其他相关</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AA%92%E4%BD%93%E6%92%AD%E6%94%BE"><span class="toc-number">6.</span> <span class="toc-text">媒体播放</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8"><span class="toc-number">7.</span> <span class="toc-text">本地存储</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Web-Storage"><span class="toc-number">7.1.</span> <span class="toc-text">Web Storage</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">7.2.</span> <span class="toc-text">本地数据库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SQLLite"><span class="toc-number">7.3.</span> <span class="toc-text">SQLLite</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#indexedDB"><span class="toc-number">7.4.</span> <span class="toc-text">indexedDB</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A6%BB%E7%BA%BF%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F"><span class="toc-number">8.</span> <span class="toc-text">离线应用程序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98%E5%92%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="toc-number">8.1.</span> <span class="toc-text">本地缓存和浏览器缓存的区别：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0HTML5%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%BC%93%E5%AD%98"><span class="toc-number">8.2.</span> <span class="toc-text">实现HTML5应用程序缓存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#applicationCache%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%96%B9%E6%B3%95"><span class="toc-number">8.3.</span> <span class="toc-text">applicationCache的两个方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#applicationCache%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BA%8B%E4%BB%B6"><span class="toc-number">8.4.</span> <span class="toc-text">applicationCache对象的事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%9C%A8%E7%BA%BF%E8%BF%98%E6%98%AF%E7%A6%BB%E7%BA%BF%E7%8A%B6%E6%80%81%EF%BC%9F"><span class="toc-number">8.5.</span> <span class="toc-text">如何判断在线还是离线状态？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E4%BF%A1API"><span class="toc-number">9.</span> <span class="toc-text">通信API</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%A8%E6%96%87%E6%A1%A3%E6%B6%88%E6%81%AF%E4%BC%A0%E8%BE%93"><span class="toc-number">9.1.</span> <span class="toc-text">跨文档消息传输</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#XMLHttpRequest-Level-2"><span class="toc-number">9.2.</span> <span class="toc-text">XMLHttpRequest Level 2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Web-Socket%E9%80%9A%E4%BF%A1"><span class="toc-number">9.3.</span> <span class="toc-text">Web Socket通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Socket-IO%E9%80%9A%E4%BF%A1%E6%A1%86%E6%9E%B6"><span class="toc-number">9.4.</span> <span class="toc-text">Socket.IO通信框架</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Web-Workers"><span class="toc-number">10.</span> <span class="toc-text">Web Workers</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%9C%B0%E7%90%86%E4%BD%8D%E7%BD%AE"><span class="toc-number">11.</span> <span class="toc-text">获取地理位置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E5%93%AA%E4%BA%9B%E5%AE%9A%E4%BD%8D%E6%95%B0%E6%8D%AE"><span class="toc-number">11.1.</span> <span class="toc-text">有哪些定位数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Geolocation-API%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86"><span class="toc-number">11.2.</span> <span class="toc-text">Geolocation API的基本知识</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AE%E6%95%B0%E6%8D%AE"><span class="toc-number">12.</span> <span class="toc-text">微数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#History-API"><span class="toc-number">13.</span> <span class="toc-text">History API</span></a></li></ol>
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  
<div class="categorieslist">
	<p class="asidetitle">分类</p>
		<ul>
		
			<li><a href="/categories/前端/" title="前端">前端<sup>3</sup></a></li>
		
			<li><a href="/categories/生活琐事/" title="生活琐事">生活琐事<sup>1</sup></a></li>
		
			<li><a href="/categories/计算机/" title="计算机">计算机<sup>20</sup></a></li>
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
		
			<li><a href="/tags/CSS/" title="CSS">CSS<sup>1</sup></a></li>
		
			<li><a href="/tags/ES6/" title="ES6">ES6<sup>3</sup></a></li>
		
			<li><a href="/tags/HTML5/" title="HTML5">HTML5<sup>1</sup></a></li>
		
			<li><a href="/tags/SASS/" title="SASS">SASS<sup>1</sup></a></li>
		
			<li><a href="/tags/css/" title="css">css<sup>6</sup></a></li>
		
			<li><a href="/tags/css3/" title="css3">css3<sup>1</sup></a></li>
		
			<li><a href="/tags/fiddler/" title="fiddler">fiddler<sup>1</sup></a></li>
		
			<li><a href="/tags/git/" title="git">git<sup>1</sup></a></li>
		
			<li><a href="/tags/jQuery/" title="jQuery">jQuery<sup>2</sup></a></li>
		
			<li><a href="/tags/javascript/" title="javascript">javascript<sup>11</sup></a></li>
		
			<li><a href="/tags/webpack/" title="webpack">webpack<sup>1</sup></a></li>
		
			<li><a href="/tags/webstorm/" title="webstorm">webstorm<sup>1</sup></a></li>
		
			<li><a href="/tags/前端/" title="前端">前端<sup>22</sup></a></li>
		
			<li><a href="/tags/生活/" title="生活">生活<sup>1</sup></a></li>
		
			<li><a href="/tags/积累/" title="积累">积累<sup>5</sup></a></li>
		
			<li><a href="/tags/翻译/" title="翻译">翻译<sup>1</sup></a></li>
		
			<li><a href="/tags/计算机/" title="计算机">计算机<sup>20</sup></a></li>
		
			<li><a href="/tags/计算机基础/" title="计算机基础">计算机基础<sup>1</sup></a></li>
		
			<li><a href="/tags/调试/" title="调试">调试<sup>1</sup></a></li>
		
		</ul>
</div>


  <div class="rsspart">
	<a href="" target="_blank" title="rss">RSS 订阅</a>
</div>

</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<div class="social-font clearfix">
		
		
		
		
		
	</div>
		<p class="copyright">Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/A-limon/pacman" target="_blank" title="Pacman">Pacman</a> © 2021 
		
		<a href="http://example.com" target="_blank" title="angus-Zeng">angus-Zeng</a>
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.1.0.min.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else
    {
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      h  = $('article h2')
      ah = $('article h2'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  if(ah.length==0){
    t.css('display','none');
  }else{
    c.click(function(){
      ta.css('display', 'block').addClass('fadeIn');
    });
    o.click(function(){
      ta.css('display', 'none');
    });
    $(window).scroll(function(){
      ta.css("top",Math.max(140,320-$(this).scrollTop()));
    });
  };
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina');
  var html = [
  '<a href="#" class="overlay" id="qrcode"></a>',
  '<div class="qrcode clearfix"><span>扫描二维码分享到微信朋友圈</span><a class="qrclose" href="#share"></a><strong>Loading...Please wait</strong><img id="qrcode-pic" data-src="http://s.jiathis.com/qrcode.php?url=' + encodedUrl + '"/></div>',
  '<a href="#textlogo" class="article-back-to-top" title="Top"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="QRcode"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="Weibo"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);
  $('.article-share-qrcode').click(function(){
    var imgSrc = $('#qrcode-pic').attr('data-src');
    $('#qrcode-pic').attr('src', imgSrc);
    $('#qrcode-pic').load(function(){
        $('.qrcode strong').text(' ');
    });
  });
});     
</script>






  </body>
</html>
