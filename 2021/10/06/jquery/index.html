
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  
    <title>jQuery API学习总结 | 欢迎来到曾安的博客</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=3, minimum-scale=1">
    
    <meta name="author" content="angus-Zeng">
    
    <meta name="description" content="jQuery，在工作中很常用，但是很多API或者使用这些API的注意事项也经常会忘记，因此写个博客总结一下，这样也能复习一下jQuery API。主要参考了jQuery中文文档,适用于jQuery1.9~3.1版本。
jQuery API主要分为选择器、属性/CSS相关（属性、CSS、尺寸、位置）、">
    
    
    
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/pacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/pacman.jpg">
    
    
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.4.0"></head>

  <body>
    <header>
      <div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.svg" alt="欢迎来到曾安的博客" title="欢迎来到曾安的博客"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="欢迎来到曾安的博客">欢迎来到曾安的博客</a></h1>
				<h2 class="blog-motto">最简单的在心头挥之不去</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
					<li>
					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="text" id="search" name="q" autocomplete="off" maxlength="20" placeholder="搜索" />
						<input type="hidden" name="q" value="site:example.com">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>

    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2021/10/06/jquery/" title="jQuery API学习总结" itemprop="url">jQuery API学习总结</a>
  </h1>
  <p class="article-author">By
    
      <a href="http://example.com" title="angus-Zeng">angus-Zeng</a>
    </p>
  <p class="article-time">
    <time datetime="2021-10-06T10:11:04.150Z" itemprop="datePublished">2021-10-06</time>
    更新日期:<time datetime="2021-10-06T10:11:04.152Z" itemprop="dateModified">2021-10-06</time>
    
  </p>
</header>
	<div class="article-content">
		
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">文章目录</strong>
		<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E5%99%A8"><span class="toc-number">1.</span> <span class="toc-text">选择器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%AD%9B%E9%80%89"><span class="toc-number">1.1.</span> <span class="toc-text">基本筛选</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AE%B9%E7%AD%9B%E9%80%89"><span class="toc-number">1.2.</span> <span class="toc-text">内容筛选</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E8%A7%81%E6%80%A7%E7%AD%9B%E9%80%89"><span class="toc-number">1.3.</span> <span class="toc-text">可见性筛选</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A8%E5%8D%95"><span class="toc-number">1.4.</span> <span class="toc-text">表单</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7-CSS%E7%9B%B8%E5%85%B3"><span class="toc-number">2.</span> <span class="toc-text">属性&#x2F;CSS相关</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7"><span class="toc-number">2.1.</span> <span class="toc-text">属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CSS"><span class="toc-number">2.2.</span> <span class="toc-text">CSS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%BA%E5%AF%B8"><span class="toc-number">2.3.</span> <span class="toc-text">尺寸</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%8D%E7%BD%AE"><span class="toc-number">2.4.</span> <span class="toc-text">位置</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AEdata"><span class="toc-number">3.</span> <span class="toc-text">数据data</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DOM%E6%93%8D%E4%BD%9C"><span class="toc-number">4.</span> <span class="toc-text">DOM操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%B7%E8%B4%9D"><span class="toc-number">4.1.</span> <span class="toc-text">拷贝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DOM-%E6%8F%92%E5%85%A5-%E5%8C%85%E8%A3%B9"><span class="toc-number">4.2.</span> <span class="toc-text">DOM 插入, 包裹</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DOM-%E6%8F%92%E5%85%A5-%E5%86%85%E9%83%A8%E6%8F%92%E5%85%A5"><span class="toc-number">4.3.</span> <span class="toc-text">DOM 插入, 内部插入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DOM-%E6%8F%92%E5%85%A5-%E5%A4%96%E9%83%A8%E6%8F%92%E5%85%A5"><span class="toc-number">4.4.</span> <span class="toc-text">DOM 插入, 外部插入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DOM-%E7%A7%BB%E9%99%A4"><span class="toc-number">4.5.</span> <span class="toc-text">DOM 移除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DOM-%E6%9B%BF%E6%8D%A2"><span class="toc-number">4.6.</span> <span class="toc-text">DOM 替换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%81%8D%E5%8E%86"><span class="toc-number">5.</span> <span class="toc-text">遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AD%9B%E9%80%89"><span class="toc-number">5.1.</span> <span class="toc-text">筛选</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%84%E7%A7%8D%E9%81%8D%E5%8E%86"><span class="toc-number">5.2.</span> <span class="toc-text">各种遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E9%81%8D%E5%8E%86"><span class="toc-number">5.3.</span> <span class="toc-text">树遍历</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6"><span class="toc-number">6.</span> <span class="toc-text">事件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BA%8B%E4%BB%B6"><span class="toc-number">6.1.</span> <span class="toc-text">浏览器事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E6%A1%A3%E5%8A%A0%E8%BD%BD"><span class="toc-number">6.2.</span> <span class="toc-text">文档加载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A"><span class="toc-number">6.3.</span> <span class="toc-text">事件绑定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A8%E5%8D%95%E4%BA%8B%E4%BB%B6"><span class="toc-number">6.4.</span> <span class="toc-text">表单事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%AE%E7%9B%98%E4%BA%8B%E4%BB%B6"><span class="toc-number">6.5.</span> <span class="toc-text">键盘事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%BC%A0%E6%A0%87%E4%BA%8B%E4%BB%B6"><span class="toc-number">6.6.</span> <span class="toc-text">鼠标事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1"><span class="toc-number">6.7.</span> <span class="toc-text">事件对象</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%88%E6%9E%9C"><span class="toc-number">7.</span> <span class="toc-text">效果</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80"><span class="toc-number">7.1.</span> <span class="toc-text">基础</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89"><span class="toc-number">7.2.</span> <span class="toc-text">自定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B8%90%E5%8F%98"><span class="toc-number">7.3.</span> <span class="toc-text">渐变</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BB%91%E5%8A%A8"><span class="toc-number">7.4.</span> <span class="toc-text">滑动</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Ajax"><span class="toc-number">8.</span> <span class="toc-text">Ajax</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E5%B1%80Ajax%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F"><span class="toc-number">8.1.</span> <span class="toc-text">全局Ajax事件处理程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%85%E5%8A%A9%E5%87%BD%E6%95%B0"><span class="toc-number">8.2.</span> <span class="toc-text">辅助函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%95%E5%B1%82%E6%8E%A5%E5%8F%A3"><span class="toc-number">8.3.</span> <span class="toc-text">底层接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ajax"><span class="toc-number">8.3.1.</span> <span class="toc-text">.ajax()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#jqXHR-%E5%AF%B9%E8%B1%A1"><span class="toc-number">8.3.2.</span> <span class="toc-text">jqXHR 对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Data-Types%EF%BC%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%89"><span class="toc-number">8.3.3.</span> <span class="toc-text">Data Types（数据类型）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Sending-Data-to-the-Server%EF%BC%88%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%89"><span class="toc-number">8.3.4.</span> <span class="toc-text">Sending Data to the Server（发送数据到服务器）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Advanced-Options%EF%BC%88%E9%AB%98%E7%BA%A7%E9%80%89%E9%A1%B9%EF%BC%89"><span class="toc-number">8.3.5.</span> <span class="toc-text">Advanced Options（高级选项）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Using-Converters%EF%BC%88%E4%BD%BF%E7%94%A8%E8%BD%AC%E6%8D%A2%E5%99%A8%EF%BC%89"><span class="toc-number">8.3.6.</span> <span class="toc-text">Using Converters（使用转换器）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E6%8D%B7%E6%96%B9%E6%B3%95"><span class="toc-number">8.4.</span> <span class="toc-text">快捷方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Loading-Page-Fragments%EF%BC%88%E5%8A%A0%E8%BD%BD%E9%A1%B5%E9%9D%A2%E7%89%87%E6%AE%B5%EF%BC%89"><span class="toc-number">8.4.1.</span> <span class="toc-text">Loading Page Fragments（加载页面片段）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#jQuery%E6%A0%B8%E5%BF%83"><span class="toc-number">9.</span> <span class="toc-text">jQuery核心</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#jQuery%E6%9D%82%E9%A1%B9"><span class="toc-number">10.</span> <span class="toc-text">jQuery杂项</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#DOM-%E5%85%83%E7%B4%A0%E6%96%B9%E6%B3%95"><span class="toc-number">10.1.</span> <span class="toc-text">DOM 元素方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E6%9E%84%E4%BB%B6"><span class="toc-number">10.2.</span> <span class="toc-text">内部构件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7"><span class="toc-number">11.</span> <span class="toc-text">实用工具</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BB%B6%E8%BF%9F%E5%AF%B9%E8%B1%A1%EF%BC%88deferred%E5%AF%B9%E8%B1%A1%EF%BC%89"><span class="toc-number">12.</span> <span class="toc-text">延迟对象（deferred对象）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E8%B0%83%E5%AF%B9%E8%B1%A1"><span class="toc-number">13.</span> <span class="toc-text">回调对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%AF%E6%8C%81%E7%9A%84-Flags"><span class="toc-number">13.1.</span> <span class="toc-text">支持的 Flags</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Callbacks-%E6%94%AF%E6%8C%81%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">13.2.</span> <span class="toc-text">$.Callbacks() 支持的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Callbacks-Deferred-and-Pub-Sub"><span class="toc-number">13.3.</span> <span class="toc-text">$.Callbacks, $.Deferred and Pub&#x2F;Sub</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#use-JQuery-Callbacks"><span class="toc-number">13.4.</span> <span class="toc-text">use JQuery.Callbacks</span></a></li></ol></li></ol>
		</div>
		
		<p>jQuery，在工作中很常用，但是很多API或者使用这些API的注意事项也经常会忘记，因此写个博客总结一下，这样也能复习一下jQuery API。主要参考了<a target="_blank" rel="noopener" href="http://www.css88.com/jqapi-1.9/">jQuery中文文档</a>,适用于jQuery1.9~3.1版本。</p>
<p>jQuery API主要分为选择器、属性/CSS相关（属性、CSS、尺寸、位置）、数据data、DOM操作、遍历和筛选、事件、效果、Ajax、jQuery核心、实用工具、延迟对象、回调对象和其他一些杂项。</p>
<h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><p>基本选择、层级选择、属性选择、子元素筛选这些和CSS基本一致。jQuery还支持这些选择器：</p>
<h3 id="基本筛选"><a href="#基本筛选" class="headerlink" title="基本筛选"></a>基本筛选</h3><p>:animated  </p>
<p><em>注意事项1:  如果您使用一个自定义的jQuery绑定一个没有效果模块，:animated选择器会抛出一个错误；</em></p>
<p><em>注意事项2: 因为:animated是一个jQuery延伸出来的选择器，并不是的CSS规范的一部分，使用:animated查询不能充分利用原生DOM提供的querySelectorAll() 方法来提高性能。为了当使用:animated 的时候在现代浏览器上获得更佳的性能，首先使用纯CSS选择器选择元素，然后使用.filter(“:animated”)，其他非CSS规范选择器同理。</em></p>
<p>:eq(index)  </p>
<p>要匹配元素的索引值，从0开始计数（由于JavaScript数组使用基于0的索引，而:nth-child(n)是基于1的索引的，以符合CSS规范），支持负值</p>
<p>:even </p>
<p>这是基于0的索引，所以:even选择器是选择第一个元素，第三个元素，依此类推在匹配</p>
<p>:first</p>
<p>:first伪类选择器相当于:eq(0)。它也可以写为:lt(1)。虽然:first只匹配一个单独的元素，但是:first-child选择器可以匹配多个：即为每个父级元素匹配第一个子元素。</p>
<p>:gt()</p>
<p>:header</p>
<p>选择所有标题元素</p>
<p>:lang()</p>
<p>选择指定语言的所有元素。</p>
<p>:last</p>
<p>:lt()</p>
<p>:not()</p>
<p>.not()方法可以让代码更易读。而使用 :not() 通常会构建出一个非常复杂的选择器。所以大多数情况下，推荐使用 .not()方法。</p>
<p>:odd</p>
<p>:root</p>
<p>在HTML中，文档的根元素，和$(“:root”)选择的元素一样，永远是&lt;html&gt;元素</p>
<p>:target</p>
<p>如果文档的URI包含一个格式化的标识符，或hash（哈希），然后:target选择器将匹配ID和标识符相匹配的元素。例如，给定的URI <a href="http://example.com/#foo%EF%BC%8C">http://example.com/#foo，</a> $( “p:target” )，将选择&lt;p id=”foo”&gt;元素。</p>
<h3 id="内容筛选"><a href="#内容筛选" class="headerlink" title="内容筛选"></a>内容筛选</h3><p>:contains()</p>
<p>选择所有包含指定文本的元素。</p>
<p>:empty</p>
<p>选择所有没有子元素的元素（包括文本节点）。</p>
<p><em>注意：W3C的建议p元素都至少有一个子节点，即使这个子节点是文字（见 <a target="_blank" rel="noopener" href="http://www.w3.org/TR/html401/struct/text.html%EF%BC%83edef-P%EF%BC%89%E3%80%82%E5%8F%A6%E4%B8%80%E6%96%B9%E9%9D%A2%EF%BC%8C%E5%85%B6%E4%BB%96%E4%B8%80%E4%BA%9B%E5%85%83%E7%B4%A0%E5%A7%8B%E7%BB%88%E6%98%AF%E7%A9%BA%E7%9A%84%EF%BC%88%E5%8D%B3%E6%B2%A1%E6%9C%89%E5%AD%90%E8%8A%82%E7%82%B9%EF%BC%89%EF%BC%9A%E4%BE%8B%E5%A6%82input,img,br%E5%92%8Chr%E3%80%82">http://www.w3.org/TR/html401/struct/text.html＃edef-P）。另一方面，其他一些元素始终是空的（即没有子节点）：例如input,img,br和hr。</a></em></p>
<p>:has()</p>
<p>选择元素其中至少包含指定选择器匹配的一个/种元素。</p>
<p>:parent</p>
<p>选择所有含有子元素或者文本的父级元素。这个正好和 :empty相反。</p>
<h3 id="可见性筛选"><a href="#可见性筛选" class="headerlink" title="可见性筛选"></a>可见性筛选</h3><p>:hidden</p>
<p>:visible</p>
<p>元素可以被认为是隐藏的几个情况：</p>
<ul>
<li>他们的CSS display值是none。</li>
<li>他们是type=”hidden”的表单元素。</li>
<li>它们的宽度和高度都显式设置为0。</li>
<li>一个祖先元素是隐藏的，因此该元素是不会在页面上显示。</li>
</ul>
<p>元素visibility:hidden或opacity:0被认为是可见的，因为他们仍然占据布局空间。在动画，隐藏一个元素，该元素被认为是可见的直到动画结束。<br>不在文档中的元素是被认为是不可见的;如果当他们被插入到文档中，jQuery没有办法知道他们是否是可见的，因为元素可见性依赖于适用的样式。<br>jQuery 3稍微修改了:hidden (以及:visible)的含义。 这个版本开始，如果一个元素没有任何布局盒子，那么它将被视为:hidden。例如，br 元素和没有内容的内联元素将不能通过:hidden选择器被选择。</p>
<h3 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h3><p>:button</p>
<p>:checkbox</p>
<p>:checked</p>
<p>:disabled</p>
<p>:enabled</p>
<p>:focus</p>
<p>:file</p>
<p>:image</p>
<p>:input</p>
<p>:password</p>
<p>:radio</p>
<p>:reset</p>
<p>:selected</p>
<p>:submit</p>
<p>:text</p>
<h2 id="属性-CSS相关"><a href="#属性-CSS相关" class="headerlink" title="属性/CSS相关"></a>属性/CSS相关</h2><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>属性有.attr()，.prop()，.removeAttr()，.removeProp()，.val()这5个方法。</p>
<p>1 .attr()</p>
<p>获取匹配的元素集合中的第一个元素的属性的值  或 设置每一个匹配元素的一个或多个属性。</p>
<p><em>jQuery的很多方法都是默认获取的时候为第一个元素的值，而写入或设置的时候为修改所有匹配的元素</em></p>
<p>1.1 .attr( attributeName )</p>
<p>获取匹配的元素集合中的第一个元素的属性的值。</p>
<p>根据W3C的表单规范 ，checked属性是一个布尔属性，这意味着,如果这个属性（attribute）是目前存在，即使，该属性没有对应的值，或者被设置为空字符串值，或甚至是”false”，相应的属性（property）为true。这才是真正的所有布尔属性（attributes）。<br>checked特性（attribute）值不会因为复选框的状态而改变，而checked属性（property）会因为复选框的状态而改变。因此，跨浏览器兼容的方法来确定一个复选框是否被选中，是使用该属性（property）：</p>
<pre><code>if ( elem.checked )
if ( $(elem).prop(&quot;checked&quot;) )
if ( $(elem).is(&quot;:checked&quot;) )
</code></pre>
<p><em>除了checked，对于其他的动态属性selected，disabled和value也应该使用prop()方法</em></p>
<p><em>在Internet Explorer 9之前的版本，使用.prop()设置DOM元素的属性进行赋值时，若所赋值的类型不是基本类型(number, string, 或 boolean)，而且也没有在DOM元素从文档中被移除之前使用 .removeProp() 方法。为了安全的在 DOM 对象上进行赋值而不用担心内存泄露问题，请使用 .data()方法。</em></p>
<p>1.2 .attr( attributeName, value )</p>
<p>value类型: String or Number or Null。如果为null， 指定的属性将被删除（就像.removeAttr()一样）</p>
<p>1.3 .attr( attributes )</p>
<p>attributes类型: PlainObject，一个要设置的属性-值集合对象</p>
<p>1.4 .attr( attributeName, function(Integer index, String attr) )</p>
<p>这个函数返回用来设置的值。this指向当前的元素。接收该元素在集合中索引位置（index）和 原来属性值（attr）作为参数。</p>
<p><em>注意 如果setter函数没有返回任何数据（例如：function(index, attr){})，属性的当前值返回值是undefined，作为一个getter行为。实际上，如果不进行任何更改的setter函数不返回的东西。</em></p>
<p><em>警告： 当设置样式名（“class”）属性时，必须使用引号！</em></p>
<p><em>注意: 试图改变 由document.createElement()创建的input 或 button 的type属性，在Internet Explorer 8或更老的版本中将抛出一个例外。</em></p>
<p>2 .prop()</p>
<p>参见attr().</p>
<p>禁用页面所有复选框</p>
<pre><code>&lt;script&gt;
$(&quot;input[type=&#39;checkbox&#39;]&quot;).prop(&#123;
  disabled: true
&#125;);
&lt;/script&gt;
</code></pre>
<p>3 .removeAttr( attributeName )</p>
<p>attributeName类型: String，要移除的属性名,从1.7版本开始，它可以是一个空格分隔的属性列表。</p>
<p><em>注意: Internet Explorer 8， 9 ，和11中，使用.removeAttr()<br>删除一个内联onclick事件处理程序不会达到预期的效果，为了避免潜在的问题，使用 .prop()代替：</em></p>
<pre><code>$element.prop(&quot;onclick&quot;, null);
console.log(&quot;onclick property: &quot;, $element[0].onclick);
</code></pre>
<p>4 .removeProp( propertyName )</p>
<p>若尝试移除 DOM 元素或 window 对象上一些内建的 属性（ property ） ，浏览器可能会产生错误。如果真的那么做了，那么 jQuery 首先会将 属性（ property ） 设置成 undefined ，然后忽略任何浏览器产生的错误。一般来说,只需要移除自定义的 属性（ property ） ，而不是移除内建的（原生的）属性（ property ）。</p>
<p><em>注意: 不要使用此方法来删除原生的属性（ property ），比如checked, disabled, 或者selected。这将完全移除该属性，一旦移除，不能再次被添加到元素上。使用.prop()来设置这些属性设置为false代替。</em></p>
<p>5 .val()</p>
<p>5.1 .val()</p>
<p>当该集合中第一个元素是一个select-multiple（即select元素设置了multiple属性），.val()返回一个包含每个选择项值的数组。在jQuery 3.0中， 如果没有选项被选中，它将返回一个空数组；在jQuery 3.0之前的版本中， 它将返回null。</p>
<pre><code>function displayVals() &#123;
  var singleValues = $(&quot;#single&quot;).val();
  var multipleValues = $(&quot;#multiple&quot;).val() || []; //确保没有选项被选中时为[]
  $(&quot;p&quot;).html(&quot;&lt;b&gt;Single:&lt;/b&gt; &quot; +
              singleValues +
              &quot; &lt;b&gt;Multiple:&lt;/b&gt; &quot; +
              multipleValues.join(&quot;, &quot;));
&#125;

$(&quot;select&quot;).change(displayVals);
displayVals();
</code></pre>
<p>对于选择框（select），复选框（checkbox）和单选按钮（radio button），您也可以使用:selected 和 :checked选择器来获取值。</p>
<p><em>注意: 通过 .val() 方法从 &lt;textarea&gt; 元素中获取的值是不含有回车（\r）字符的。但是如果该值是通过 XHR 传递给服务器的，回车（\r）字符会被保留（或者是被浏览器添加的，但是在原始数据中并不包含回车（\r））。可以使用下面的 valHook 方法解决这个问题：</em></p>
<pre><code>$.valHooks.textarea = &#123;
  get: function( elem ) &#123;
    return elem.value.replace( /\r?\n/g, &quot;\r\n&quot; );
  &#125;
&#125;;
</code></pre>
<p>5.2 .val( value )</p>
<p>value类型: String or Number or Array，一个文本字符串,一个数字，或一个以字符串形式的数组来设定每个匹配元素的值。</p>
<p>val() 允许你传递一个元素值的数组。当使用在包含像<input type="checkbox">, <input type="radio">, 和<select>中的 <option>元素的jQuery对象上的时候是非常有用的。在这种情况下，input和option的value与数组元素相匹配的情况下将被选中（checked）或选定（selected），而那些与数组元素值不匹配的value是未选中（unchecked）或未被选（unselected），这取决于元素类型。对于 <input type="radio"> 属于一个单选按钮组 ，还有<select>的其他元素都将被取消选中。</p>
<pre><code>&lt;select id=&quot;single&quot;&gt;
  &lt;option&gt;Single&lt;/option&gt;
  &lt;option&gt;Single2&lt;/option&gt;
&lt;/select&gt;
 
&lt;select id=&quot;multiple&quot; multiple=&quot;multiple&quot;&gt;
  &lt;option selected=&quot;selected&quot;&gt;Multiple&lt;/option&gt;
  &lt;option&gt;Multiple2&lt;/option&gt;
  &lt;option selected=&quot;selected&quot;&gt;Multiple3&lt;/option&gt;
&lt;/select&gt;&lt;br/&gt;
&lt;input type=&quot;checkbox&quot; name=&quot;checkboxname&quot; value=&quot;check1&quot;/&gt; check1
&lt;input type=&quot;checkbox&quot; name=&quot;checkboxname&quot; value=&quot;check2&quot;/&gt; check2
&lt;input type=&quot;radio&quot;  name=&quot;r&quot; value=&quot;radio1&quot;/&gt; radio1
&lt;input type=&quot;radio&quot;  name=&quot;r&quot; value=&quot;radio2&quot;/&gt; radio2
&lt;script&gt;
 
    $(&quot;#single&quot;).val(&quot;Single2&quot;);
    $(&quot;#multiple&quot;).val([&quot;Multiple2&quot;, &quot;Multiple3&quot;]);
    $(&quot;input&quot;).val([&quot;check1&quot;,&quot;check2&quot;, &quot;radio1&quot; ]);
 
&lt;/script&gt;
</code></pre>
<p>使用这个方法（或使用原生的value属性（property））设置值，不会触发change事件。为此，相关的事件处理程序不会被执行。如果要执行它们，你应该在设置值之后调用 .trigger( “change” )</p>
<p>5.3 .val( function( Integer index, String value )  )</p>
<pre><code>$(&#39;input:text.items&#39;).val(function( index, value ) &#123;
  return value + &#39; &#39; + this.className;
&#125;);
</code></pre>
<h3 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h3><p>CSS主要有以下一些方法：</p>
<p>.addClass()</p>
<p>.css()</p>
<p>jQuery.cssHooks</p>
<p>jQuery.cssNumber</p>
<p>jQuery.escapeSelector()</p>
<p>.hasClass()</p>
<p>.removeClass()</p>
<p>.toggleClass()</p>
<p>1 .addClass()</p>
<p>1.1 .addClass( className )</p>
<p>1.2 .addClass( function(index, currentClass) )</p>
<p>在jQuery 1.12/2.2 版本之前， .addClass()方法操纵是选定元素的className特性（property），不是class属性（attribute）。一旦特性（property）改变，浏览器就会更新相应地的属性（attribute）。此行为的一个言外之意是，这种方法只适用于HTML DOM语义的文档（例如，不是纯XML文档）。</p>
<p>在jQuery1.12/2.2中，改变了这种行为以改善对XML文档，包括SVG的支持。从这个版本开始，class 属性（attribute）被替换（愚人码头注：这个版本开始，.addClass()方法操作的是class 属性（attribute），而不是className特性（property））。因此，.addClass()可以在XML或SVG文档中使用。</p>
<p>对所有匹配的元素可以一次添加多个用空格隔开的样式类名。</p>
<p>2 .hasClass( className )</p>
<p>在 jQuery 1.12/2.2 中, 这个方法支持 XML 文档, 包括 SVG。</p>
<p>3 .removeClass()</p>
<p>如果一个样式类名作为一个参数,只有这样式类会被从匹配的元素集合中删除 。 如果没有样式名作为参数，那么所有的样式类将被移除。</p>
<p>4 .toggleClass()</p>
<p>4.1 .toggleClass( className )</p>
<p>4.2 .toggleClass( className, state )</p>
<p>state类型: Boolean,一个布尔值（不止是真值/假值），用于判断样式是否应该被添加或移除。</p>
<p>4.3 .toggleClass( function( Integer index, String className, Boolean state ) [, state ] )</p>
<p>5 .css()</p>
<p>.css( propertyName )</p>
<p>.css( propertyNames )</p>
<p>.css( propertyName, value )</p>
<p>.css( propertyName, function(index, value) )</p>
<p>.css( properties )</p>
<p>5.1 从jQuery 1.9开始, 传递一个CSS的样式属性的数组给.css()将返回 属性 - 值 配对的对象。例如，要获取元素4个边距宽度值border-width，你可以使用$( elem ).css([ “borderTopWidth”, “borderRightWidth”, “borderBottomWidth”, “borderLeftWidth” ]).</p>
<p>5.2 当一个数只被作为值（value）的时候， jQuery会将其转换为一个字符串，并添在字符串的结尾处添加px(愚人码头注：.css(“width”,50})，.css(“width”,”50”})，.css(“width”,’50px’})这3条语句是等价的，具体可以查看 <a target="_blank" rel="noopener" href="http://jsfiddle.net/feiwen8772/b78mgmdd/)%E3%80%82">http://jsfiddle.net/feiwen8772/b78mgmdd/)。</a> 如果属性值需要非px的其他单位，请使用添加了合适单位的字符串（愚人码头注：例如，’12em’）</p>
<p>5.3 样式属性的值设置为空字符串 — 例如，$(‘#mydiv’).css(‘color’, ‘’) — 那么会从元素上移除该属性（若该属性存在的话）， 该属性之前可能是通过 jQuery 的 .css() 方法设置的 HTML style 属性，也有可能是通过直接对 style 属性进行 DOM 操作而被设置的。 因此，该属性的元素样式将恢复到之前应用的任何值。</p>
<p><em>注意: .css()忽略了!important声明！ 因此，语句$( “p” ).css( “color”, “red !important” )，不会将页面中所有段落颜色转变为红色。 强烈建议使用类（class）来代替; 否则请使用jQuery插件。</em></p>
<p>5.4 从jQuery1.6开始，.css()接受类似于.animate()的相对值。相对值时以+= 或者 -=开头的字符串，表示递增或递减当前的值。 例如，如果一个元素的左边填充（padding-left）是10px的，.css( “padding-left”, “+=15” )将返回总的左填充（padding-left ）为55px。</p>
<p>5.5 <em>注意: 如果设置函数没有返回任何东西(例如. function(index, style){})，或者如果返回undefined，当前的值不会改变。只有当某些条件得到满足，选择性的设定值的时后是有用的。</em></p>
<p>6 jQuery.cssHooks</p>
<p>直接向 jQuery 中添加钩子，用于覆盖设置或获取特定 CSS 属性时的方法，目的是为了标准化 CSS 属性名或创建自定义属性。</p>
<pre><code>(function($) &#123;
  if ( !$.cssHooks ) &#123;
    throw(&quot;jQuery 1.4.3+ is needed for this plugin to work&quot;);
    return;
  &#125;
 
  function styleSupport( prop ) &#123;
    var vendorProp, supportedProp,
        capProp = prop.charAt(0).toUpperCase() + prop.slice(1),
        prefixes = [ &quot;Moz&quot;, &quot;Webkit&quot;, &quot;O&quot;, &quot;ms&quot; ],
        div = document.createElement( &quot;div&quot; );
 
    if ( prop in div.style ) &#123;
      supportedProp = prop;
    &#125; else &#123;
      for ( var i = 0; i &lt; prefixes.length; i++ ) &#123;
        vendorProp = prefixes[i] + capProp;
        if ( vendorProp in div.style ) &#123;
          supportedProp = vendorProp;
          break;
        &#125;
      &#125;
    &#125;
 
    div = null;
    $.support[ prop ] = supportedProp
    return supportedProp;
  &#125;
 
  var borderRadius = styleSupport( &quot;borderRadius&quot; );
 
  // Set cssHooks only for browsers that
  // support a vendor-prefixed border radius
  if ( borderRadius &amp;&amp; borderRadius !== &quot;borderRadius&quot; ) &#123;
    $.cssHooks.borderRadius = &#123;
      get: function( elem, computed, extra ) &#123;
        return $.css( elem, borderRadius );
      &#125;,
      set: function( elem, value) &#123;
        elem.style[ borderRadius ] = value;
      &#125;
    &#125;;
  &#125;
&#125;)(jQuery);
</code></pre>
<p>7 jQuery.cssNumber</p>
<p>一个对象，这个包含所有可以不使用单位的CSS属性。.css() 方法使用这个对象来确定是否可能附加px到无单位的值。</p>
<p>jQuery.cssNumber.someCSSProp = true;</p>
<p>默认情况下，这个对象包含以下属性：</p>
<ul>
<li>zIndex</li>
<li>fontWeight</li>
<li>opacity</li>
<li>zoom</li>
<li>lineHeight</li>
<li>widows (jQuery 1.6开始添加)</li>
<li>orphans (jQuery 1.6开始添加)</li>
<li>fillOpacity (jQuery 1.6.2开始添加)</li>
<li>columnCount (jQuery 1.9开始添加)</li>
<li>order (jQuery 1.10.2开始添加)</li>
<li>flexGrow (jQuery 1.11.1开始添加)</li>
<li>flexShrink (jQuery 1.11.1开始添加)</li>
</ul>
<p>8 jQuery.escapeSelector()</p>
<p>转义CSS选择器中任何具有特殊的含义字符。</p>
<p>添加版本: 3.0</p>
<p>此方法对于一个CSS类名或一个ID包含的字符在CSS中具有特殊含义的情况下非常有用，如点或分号。</p>
<p>该方法本质上是<a target="_blank" rel="noopener" href="https://drafts.csswg.org/cssom/#the-css.escape()-method">CSS工作组CSS.escape()方法</a>的shim（垫片）。 主要的区别在于，$.escapeSelector() 可以可靠地使用在所有jQuery支持的浏览器中。</p>
<p>转义包含hash的ID.</p>
<pre><code>$.escapeSelector( &quot;#target&quot; ); // &quot;\#target&quot;
</code></pre>
<p>选择在一个div内，所有类名为.box的元素。</p>
<pre><code>$( &quot;div&quot; ).find( &quot;.&quot; + $.escapeSelector( &quot;.box&quot; ) );
</code></pre>
<h3 id="尺寸"><a href="#尺寸" class="headerlink" title="尺寸"></a>尺寸</h3><p>主要有.height()，.width()，.innerHeight()，.innerWidth()，.outerHeight()，.outerWidth()</p>
<p>1 .height()</p>
<p>1.1 .height()</p>
<p>.css(‘height’) 和 .height()之间的区别是后者返回一个没有单位的数值（例如，400），前者是返回带有完整单位的字符串（例如，400px）。当一个元素的高度需要数学计算的时候推荐使用.height() 方法 。</p>
<p><em>注意.height()总是返回容器的高度,不管CSS box-sizing属性值。截至jQuery 1.8，这可能需要检索的CSS的宽度加加上box-sizing的属性，然后当元素有 box-sizing: border-box时候，减去个元素上任何潜在border和padding值。为了避免这种问题，使用.css( “height” )而非.height()。</em></p>
<p><em>尺寸相关的API返回的数字， 包括的 .height()， 在某些情况下可能带有小数。你的代码不应该假定它是一个整数。  另外，当页面被用户缩放时，返回的尺寸可能是不正确的;浏览器没有一个公开的API来检测这种情况。</em></p>
<p><em>当元素或其父元素被隐藏时，.height()得到的值不能保证准确。要得到准确的值，你应该确保该元素在使用.height()前可见。jQuery将尝试临时显示，然后再隐藏元素来测量元素尺寸，但这是不可靠的，（即使得到准确的值）也会显著影响页面的性能。这总临时显示然后再隐藏的测量功能，可能在jQuery未来的版本中删除。</em></p>
<p>1.2 .height( value )</p>
<p>1.3 .height( function(index, height) )</p>
<p>当调用.height(value)方法的时候，这个“value”参数可以是一个字符串（数字加单位）或者是一个数字。如果这个“value”参数只提供一个数字，jQuery会自动加上单位px。如果只提供一个字符串，任何有效的CSS尺寸都可以为高度赋值（就像100px, 50%, 或者 auto）。注意在现代浏览器中，CSS高度属性不包含padding, border, 或者 margin。</p>
<p>如果没有给定明确的单位（像’em’ 或者 ‘%’），那么默认情况下”px”会被直接添加上去（也理解为”px”是默认单位）。</p>
<p><em>注意.height(‘value’)设置的容器宽度是根据CSS box-sizing属性来定的, 将这个属性值改成border-box，将造成这个函数改变这个容器的outerHeight，而不是原来的内容高度。</em></p>
<p>以上的注意事项，尺寸的其他方法同理。</p>
<p>2 .width()</p>
<p>3 .innerHeight()</p>
<p>用于获得匹配集合中第一个元素的当前计算的内部高度（包括padding，但不包括border），或 设置每一个匹配元素的内部高度。</p>
<p>这个方法返回元素的高度，包括顶部和底部的padding，单位是像素。</p>
<p>这个方法不适用于window 和 document对象，对于这些对象可以使用.height()代替。</p>
<p>4 .innerWidth()</p>
<p>5 .outerHeight()</p>
<p>获取匹配元素集合中第一个元素的当前计算宽度值,包括padding，border和选择性的margin。返回一个整数（不包含“px”）表示的值 ，或如果在一个空集合上调用该方法，则会返回 null。</p>
<p>.outerHeight( [includeMargin ] )</p>
<p>includeMargin (默认: false),类型： Boolean,一个布尔值，表明是否在计算时包含元素的margin值。</p>
<p>6 .outerWidth()</p>
<h3 id="位置"><a href="#位置" class="headerlink" title="位置"></a>位置</h3><p>位置主要有.offset(),.offsetParent(),.position(),.scrollLeft(),.scrollTop()</p>
<p>1 .offset()</p>
<p>1.1 .offset()</p>
<p>在匹配的元素集合中，获取的第一个元素的当前坐标，坐标相对于文档。</p>
<p>.offset()返回一个包含top 和 left属性的对象 。</p>
<p><em>注意：jQuery不支持获取隐藏元素的偏移坐标。同样的，也无法取得隐藏元素的 border, margin, 或 padding 信息。</em></p>
<p><em>若元素的属性设置的是 visibility:hidden，那么我们依然可以取得它的坐标。但是若设置的属性是 display:none，由于在绘制 DOM 树时根本就不绘制该元素，所以它的位置属性值是 undefined。</em></p>
<p>1.2 .offset( coordinates )</p>
<p>coordinates类型: PlainObject,一个包含top 和 left属性的对象，用整数指明元素的新顶部和左边坐标。</p>
<p>1.3 .offset( function(index, coords) )</p>
<p>返回用于设置坐标的一个函数。接收元素在匹配的元素集合中的索引位置作为第一个参数，和当前坐标作为第二个参数。这个函数应该返回一个包含top 和 left属性的对象。</p>
<p>.offset()方法允许我们重新设置元素的位置，这个元素的位置是相对于document对象的。如果对象原先的.position()样式属性是static的话，会被改成relative来实现重定位。</p>
<p>2 .offsetParent()</p>
<p>取得离指定元素最近的含有定位信息的祖先元素。含有定位信息的元素指的是，CSS 的 position 属性是 relative, absolute, 或 fixed 的元素</p>
<p>3 .position()<br>获取匹配元素中第一个元素的当前坐标，相对于offset parent的坐标。( 译者注：offset parent指离该元素最近的而且被定位过的祖先元素 )</p>
<p>.position()方法可以取得元素相对于父元素的偏移位置。与.offset()不同, .offset()是获得该元素相对于documet的当前坐标,当把一个新元素放在同一个容器里面另一个元素附近时，用.position()更好用。</p>
<p>.position()返回一个包含 top 和 left属性的对象.</p>
<p>4 .scrollLeft()</p>
<p>4.1 .scrollLeft()</p>
<p>获取匹配的元素集合中第一个元素的当前水平滚动条的位置。</p>
<p><em>注意:.scrollLeft(), 当直接调用或使用.animate()做动画，当元素被应用了隐藏，将不做任何改变。</em></p>
<p>4.2 .scrollLeft( value )</p>
<p>5 .scrollTop()</p>
<h2 id="数据data"><a href="#数据data" class="headerlink" title="数据data"></a>数据data</h2><p>有三个底层的方法jQuery.data()，jQuery.hasData()，jQuery.removeData()和两个元素上的方法.data()，.removeData()，一般不要使用底层的方法，而是使用元素上的方法。</p>
<p>1 jQuery.hasData()</p>
<p>jQuery.hasData( element )</p>
<p>确定任何一个元素是否有与之相关的jQuery数据。</p>
<p>jQuery.hasData()方法提供了一种方法来确定一个元素是否有任何数据，这些数据是使用jQuery.data()设置的。如果一个元素没有关联的data对象，该方法返回false ;否则返回true 。</p>
<p>jQuery.hasData(element) 的主要优点是它并不创建 data 对象。如果元素上没有 data 对象，那么该方法也不会与元素上的 data 对象关联。相反，jQuery.data(element)总是向调用者返回一个 data 对象，即使该元素上不含有 data 对象，它也会创建一个。</p>
<p><em>请注意，jQuery的事件系统是使用jQuery数据 存储事件处理程序的。 因此，使用.on(), .bind(), .live(), .delegate()，或一个速记事件方法 绑定事件到一个元素上的时候，也会在那个元素上关联一个 data 对象。</em></p>
<p>2 .data()</p>
<p>在匹配元素上存储任意相关数据 或 返回匹配的元素集合中的第一个元素的给定名称的数据存储的值。</p>
<p>2.1 .data( key, value )</p>
<p>key类型: String，一个字符串，用户存储数据的名称。（译者注：存储的数据名）</p>
<p>value类型: Anything，新的数据值；它可以是任意的Javascript数据类型，除了undefined。</p>
<p>2.2 .data( obj )</p>
<p>obj类型: Object，一个用于更新数据的 键/值对</p>
<p>.data() 方法允许我们在DOM元素上绑定任意类型的数据,避免了循环引用的内存泄漏风险。我们可以在一个元素上设置不同的值，并获取这些值：</p>
<p>由于浏览器用插件和外部代码相互作用,.data()方法不能在<object>（除非是Flash插件），<applet> 或 <embed>元素上使用。</p>
<p><em>注意这个方法目前并不提供在XML文档上跨平台设置数据，作为Internet Explorer不允许通过自定义属性附加数据。</em></p>
<p><em>undefined不是认可的数据值。比如这样调用.data( “name”, undefined ) ，将返回 “name”对应的数据， 也就是等同于调用.data( “name” )。</em></p>
<p>2.3 .data( key )</p>
<p>返回匹配的元素集合中的第一个元素的给定名称的数据存储的值。 通过.data(name, value)或HTML5 data-* 属性设置</p>
<p>2.4 .data()</p>
<p>从jQuery 1.4.3起， HTML 5 data- 属性 将自动被引用到jQuery的数据对象中。嵌入式破折号处理属性（ attributes）的方式在 jQuery 1.6 中已经改变，以使之符合W3C HTML5 规范.</p>
<p>如果没有传递key参数的数据存储， jQuery将在元素的属性中搜索， 将驼峰式字符串转化为中横线字符串，然后在结果前面加上data-。 所以，该字符串lastValue将被转换为data-last-value。</p>
<p>每次尝试将字符串转换为一个JavaScript值（包括布尔值（booleans），数字（numbers），对象（objects），数组（arrays）和空（null））。如果这样做不会改变值的表示，那么该值将转换为一个数字（number）。例如，“1E02”和“100.000”是等同于数字（数字值100），但将转换它们会改变他们的表示，所以他们被保留为字符串。字符串值“100”被转换为数字100。</p>
<p>如果数据(data)属性是一个对象（以“{”开始）或数组（以’[‘开始），可以用jQuery.parseJSON 将其解析成字符串；它必须遵循<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/JSON#Data_types.2C_syntax_and_example">有效的JSON的语法</a>，包括带双引号的属性名称。如果该值不能解析为一个JavaScript值，它将被保留为字符串。</p>
<p>如果不想将取出的属性值直接当作字符串的话，请使用attr()方法。</p>
<p>data-属性是在第一次使用这个数据属性后不再存取或改变（所有的数据值都在jQuery内部存储）。</p>
<p>调用 .data() 时如果不带参数，将会以 JavaScript 对象的形式获取所有数据。这个对象可以安全的存放在变量中，因为一旦这个新对象被提取出来，之后对元素进行的 .data(obj)操作，将不会再影响这个对象。另外，直接操作这个对象会比每次调用 .data() 来设置或获取值要快一些：</p>
<p>3 .removeData( [name ] )</p>
<p>在元素上移除绑定的数据</p>
<p>3.1 .removeData( [name ] )</p>
<p>name类型: String,要移除的存储数据名.</p>
<p>3.2 .removeData( [list ] )</p>
<p>list类型: Array or String,一个数组或空间分隔的字符串命名要删除的数据块。</p>
<p>.removeData()方法允许我们移除用.data()绑定的值。当带name参数调用的时候，.removeData()将删除那个特有的值，当不带任何参数的时候，.removeData()将移除所有的值。</p>
<p>需要注意的是.removeData()仅会删除来自jQuery内部.data()缓存中的数据， 并且元素上任何相应的data-属性不会被删除。后调用data()，会重新检索data-的属性的值。 为了防止这种情况，可以在.removeData()旁边使用.removeAttr()来移除data-属性。jQuery 1.4.3以前,data()没有使用data-属性，所以不存在这类问题。</p>
<p>从jQuery 1.7开始, 当键数组或一个空间分隔键的字符串作为参数，调用.removeData()时，将删除在该数组每一项元素或字符串的键值。</p>
<p>4 jQuery.data()</p>
<p>jQuery.data( element, key, value )</p>
<p>jQuery.data( element, key )</p>
<p>jQuery.data( element )</p>
<p>注意：这是一个底层的方法，你应该用.data()代替。</p>
<p>jQuery.data() 方法允许我们在DOM元素上附加任意类型的数据,避免了循环引用的内存泄漏风险。如果 DOM 元素是通过 jQuery 方法删除的或者当用户离开页面时，jQuery 同时也会移除添加在上面的数据。我们可以在一个元素上设置不同的值，并获取这些值：</p>
<p><em>.unload()方法只是作为.on( “unload”, handler )的一个速记写法，移除该事件可以使用.off( “unload” )。</em></p>
<p>关于 HTML5 data-* 属性: 这个低层次的方法不检索的data-*属性， 除非.data()方法已经返回了它们。</p>
<p>调用jQuery.data(element)时将获取一个JavaScript对象，它包含了元素上所有存储的数据。jQuery内部自身使用这个方法来绑定数据，如事件处理器，所以不要以为这对象只包含你的代码中储存的数据。</p>
<p>其他和元素上的data方法一样</p>
<p>5 .removeData()</p>
<p>和元素上的removeDate()同理</p>
<h2 id="DOM操作"><a href="#DOM操作" class="headerlink" title="DOM操作"></a>DOM操作</h2><h3 id="拷贝"><a href="#拷贝" class="headerlink" title="拷贝"></a>拷贝</h3><p>.clone( [withDataAndEvents ] )</p>
<p>withDataAndEvents (默认: false)<br>类型: Boolean，<br>一个Boolean值，表示是否会复制元素上的事件处理函数。从jQuery 1.4开始，元素数据也会被复制。</p>
<p>.clone( [withDataAndEvents ] [, deepWithDataAndEvents ] )</p>
<p>withDataAndEvents (默认: false)<br>类型: Boolean，<br>一个Boolean值，表示是否会复制元素上的事件处理函数。 默认值是 false。*对于1.5.0的默认值被不适当地设置成了true，将在1.5.1以上改回false 。</p>
<p>deepWithDataAndEvents (默认: value of withDataAndEvents)<br>类型: Boolean，<br>一个布尔值，指示是否对事件处理程序和克隆的元素的所有子元素的数据应该被复制。默认情况下它的值相匹配的第一个参数的值（ 默认值是 false）</p>
<p><em>注意:出于性能方面的考虑，表单元素动态的状态（例如，用户将数据输入到 textarea中的值，或者用户在select中已经选中某一项）不会被复制到克隆元素。当克隆input元素时候，该元素的动态状态（例如，用户数据输入到文本输入框(愚人码头注： <input type="text">) 和用户选中一个复选框）将被保留在克隆元素中。</em></p>
<p>像我们讨论.append()一样，通常我们将页面上一个元素插入到DOM里另立个地方，它会被从老地方移走（愚人码头注：不是复制）</p>
<p>但是我们如果需要的是复制而不是移除，我们可以像下面这样写代码：</p>
<pre><code>$(&#39;.hello&#39;).clone().appendTo(&#39;.goodbye&#39;);
</code></pre>
<p>然而，元素数据（data）内对象和数组不会被复制，将继续被克隆元素和原始元素共享。深复制的所有数据，需要手动复制每一个：</p>
<pre><code>// Original element with attached data
var $elem = $( &quot;#elem&quot; ).data( &quot;arr&quot;, [ 1 ] ),
    $clone = $elem.clone( true )
      // Deep copy to prevent data sharing
      .data( &quot;arr&quot;, $.extend( [], $elem.data( &quot;arr&quot; ) ) );
</code></pre>
<p>在jQuery 1.5，withDataAndEvents可以选择性增强deepWithDataAndEvents复制元素的事件和数据的克隆的所有子元素。</p>
<p><em>注意: 使用.clone()可能产生id属性重复的元素的副作用，id应该是唯一的。在可能的情况下，建议，应避免克隆有此属性或标识符的元素，使用类（class）属性代替。</em></p>
<p>当使用 .clone()克隆一组元素，并且这些克隆生成的元素尚未被添加到 DOM 中，那么当这些元素被插入到 DOM 中时，不能保证是按它们的原顺序被插入的。但是，可以像下面例子中提到的那样，保证顺序的正确性：</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;style&gt;
  #orig, #copy, #copy-correct &#123;
    float: left;
    width: 20%;
  &#125;
&lt;/style&gt;
  &lt;script src=&quot;http://code.jquery.com/jquery-latest.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
 
&lt;div id=&quot;orig&quot;&gt;
    &lt;div class=&quot;elem&quot;&gt;&lt;a&gt;1&lt;/a&gt;&lt;/div&gt;
    &lt;div class=&quot;elem&quot;&gt;&lt;a&gt;2&lt;/a&gt;&lt;/div&gt;
    &lt;div class=&quot;elem&quot;&gt;&lt;a&gt;3&lt;/a&gt;&lt;/div&gt;
    &lt;div class=&quot;elem&quot;&gt;&lt;a&gt;4&lt;/a&gt;&lt;/div&gt;
    &lt;div class=&quot;elem&quot;&gt;&lt;a&gt;5&lt;/a&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&quot;copy&quot;&gt;&lt;/div&gt;
&lt;div id=&quot;copy-correct&quot;&gt;&lt;/div&gt;
 
&lt;script&gt;
// sort order is not guaranteed here and may vary with browser
$(&#39;#copy&#39;).append($(&#39;#orig .elem&#39;)
          .clone()
          .children(&#39;a&#39;)
          .prepend(&#39;foo - &#39;)
          .parent()
          .clone());
 
// correct way to approach where order is maintained
$(&#39;#copy-correct&#39;)
          .append($(&#39;#orig .elem&#39;)
          .clone()
          .children(&#39;a&#39;)
          .prepend(&#39;bar - &#39;)
          .end());
&lt;/script&gt;
 
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="DOM-插入-包裹"><a href="#DOM-插入-包裹" class="headerlink" title="DOM 插入, 包裹"></a>DOM 插入, 包裹</h3><p>有三个方法：.wrap()，.wrapAll()，.wrapInner()</p>
<p>1 .wrap()</p>
<p> 在集合中匹配的每个元素周围包裹一个HTML结构。</p>
<p>.wrap( wrappingElement )</p>
<p>wrappingElement<br>类型: Selector 或 htmlString 或 Element 或 jQuery，<br>一个选择器，元素，HTML字符串，或jQuery对象指定的html结构环绕包裹的匹配元素。 当你传递一个包含多个元素一个jQuery集合， 或选择器的匹配多个元素时， 第一元素将被使用。</p>
<p>.wrap( function )<br>function<br>类型: Function( Integer index ) =&gt; String 或 jQuery，<br>一个回调函数，返回用于包裹匹配元素的 HTML 内容或 jQuery 对象。接受的 index 参数表示匹配元素在集合中的索引位置。该函数内的 this 指向集合中的当前元素。</p>
<pre><code>$(&#39;.inner&#39;).wrap(function() &#123;
  return &#39;&lt;div class=&quot;&#39; + $(this).text() + &#39;&quot; /&gt;&#39;;
&#125;);

&lt;div class=&quot;container&quot;&gt;
  &lt;div class=&quot;Hello&quot;&gt;
    &lt;div class=&quot;inner&quot;&gt;Hello&lt;/div&gt;
  &lt;/div&gt;
  &lt;div class=&quot;Goodbye&quot;&gt;
    &lt;div class=&quot;inner&quot;&gt;Goodbye&lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<p>使用一个嵌套深度为两层 div 的 jQuery 对象来包裹所有的段落。注意，这并不会移动用于包裹的对象，只是将克隆后的对象用于包裹。</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;style&gt;
 
  div &#123; border: 2px solid blue; margin:2px; padding:2px; &#125;
  .doublediv &#123; border-color:red; &#125;
  p &#123; background:yellow; margin:4px; font-size:14px; &#125;
  &lt;/style&gt;
  &lt;script src=&quot;http://code.jquery.com/jquery-latest.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;p&gt;Hello&lt;/p&gt;
  &lt;p&gt;cruel&lt;/p&gt;
  &lt;p&gt;World&lt;/p&gt;
  &lt;div class=&quot;doublediv&quot;&gt;&lt;div&gt;&lt;/div&gt;&lt;/div&gt;
&lt;script&gt;$(&quot;p&quot;).wrap($(&quot;.doublediv&quot;));&lt;/script&gt;
 
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>2 .wrapAll()</p>
<p>.wrapAll( wrappingElement )</p>
<p>wrappingElement</p>
<p>类型: Selector 或 htmlString 或 Element 或 jQuery</p>
<p>一个选择器，元素，HTML字符串，或jQuery对象指定的html结构环绕包裹的匹配元素。</p>
<p>.wrapAll( function )</p>
<p>function</p>
<p>类型: Function() =&gt; String 或 jQuery，</p>
<p>一个回调函数，返回的HTML内容或jQuery对象将包裹所有匹配的元素。函数内的this指向集合中的第一个元素。在jQuery 3.0 之前，回调函数错误地调用集合中的每一个元素并且接收所述集合中这个元素的索引位置作为参数。</p>
<p>.wrapAll()函数可以接受任何字符串或对象，可以传递给$()工厂函数来指定一个DOM结构。这种结构可以嵌套多层，但是最内层只能有一个元素。所有匹配元素将会被当作是一个整体，在这个整体的外部用指定的 HTML 结构进行包裹。</p>
<p>为 span 标签包裹一个对象树。注意，任何 span 之间的元素都不会被包裹，例如例子中使用的 <strong> (红色文本)。即使是 span 之间的空格也不会被包裹。可以查看原始 HTML 的源代码。</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;style&gt;
 
  div &#123; border:2px blue solid; margin:2px; padding:2px; &#125;
  p &#123; background:yellow; margin:2px; padding:2px; &#125;
  strong &#123; color:red; &#125;
  &lt;/style&gt;
  &lt;script src=&quot;http://code.jquery.com/jquery-latest.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;span&gt;Span Text&lt;/span&gt;
  &lt;strong&gt;What about me?&lt;/strong&gt;
  &lt;span&gt;Another One&lt;/span&gt;
&lt;script&gt;$(&quot;span&quot;).wrapAll(&quot;&lt;div&gt;&lt;div&gt;&lt;p&gt;&lt;em&gt;&lt;b&gt;&lt;/b&gt;&lt;/em&gt;&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&quot;);&lt;/script&gt;
 
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>3 .wrapInner()</p>
<p>注意: 当通过一个选择器字符串传递给.wrapInner() 函数，其参数应该是格式正确的 HTML，并且 HTML 标签应该是被正确关闭的。下面是一些正确的例子：</p>
<pre><code>$(elem).wrapInner(&quot;&lt;div class=&#39;test&#39; /&gt;&quot;);
$(elem).wrapInner(&quot;&lt;div class=&#39;test&#39;&gt;&lt;/div&gt;&quot;);
$(elem).wrapInner(&quot;&lt;div class=\&quot;test\&quot;&gt;&lt;/div&gt;&quot;);
</code></pre>
<h3 id="DOM-插入-内部插入"><a href="#DOM-插入-内部插入" class="headerlink" title="DOM 插入, 内部插入"></a>DOM 插入, 内部插入</h3><p>有.append()，.appendTo()，.prepend()，.prependTo()，.html()，.text()</p>
<p>1 .append()</p>
<p>.append( content [, content ] )</p>
<p>content<br>类型: String, Element, jQuery，<br>DOM 元素，文本节点，元素和文本节点的数组，HTML字符串，或者jQuery对象，用来插在每个匹配元素里面的末尾。</p>
<p>content<br>类型: String, Element, Array, jQuery，<br>一个或多个DOM元素，文本节点，元素和文本节点的数组，HTML字符串，或jQuery对象插入到每个匹配元素的末尾。</p>
<p>.append( function(index, html) )</p>
<p>function(index, html)<br>类型: Function()，<br>一个返回HTML字符串，DOM元素（或多个），文本节点（或多个），jQuery对象的函数，该字符串用来插入到匹配元素的末尾。接收index 参数表示元素在匹配集合中的索引位置和html 参数表示元素上原来的 HTML 内容。在函数中this指向元素集合中的当前元素。</p>
<p>如果一个被选中的元素被插入到另外一个地方，这是移动而不是复制。</p>
<p>和其他添加内容的方法类似， 例如.prepend() 和 .before(), .append() 还支持传递输入多个参数。支持的输入包括DOM元素，jQuery对象，HTML字符串，DOM元素的数组。</p>
<p>.append() 可以接受任何数量的额外的参数</p>
<p><em>设计上，任何jQuery的构造或方法，都接受一个HTML字符串（作为参数） - jQuery(),.append(), .after()等 -可以潜在地执行代码。这可能会出现注入script标签或使用HTML属性执行的代码（例如，<img onload="">）。不要使用这些方法来插入来自不受信任来源的内容，如网址查询参数，Cookie或表单输入获得的字符串。这样做可能会引起跨站点脚本（XSS）漏洞。将内容添加到文档之前删除或避免用户任何输入内容。</em></p>
<p><em>jQuery没有正式的支持SVG。在SVG文档上使用jQuery方法，除非该方法有明确的说明，否则可能会导致意外的行为。例如jQuery 3.0中支持SVG的方法有addClass 和 removeClass。</em></p>
<p>2 .appendTo()</p>
<p>然而，如果有多个目标元素，插入元素的克隆副本被创建到每个目标元素，而不是只插入到最后一个目标元素，并且新的集合（原始元素加克隆元素）被返回。</p>
<p>在jQuery 1.9以前，追加到单个元素的情况下没有创建一个新的集合，而是返回原来的集合，当被用与数目不详的元素时，使得它难以可靠地使用.end()方法。</p>
<p>3 .prepend()</p>
<p>4 .prependTo()</p>
<p>5 .html()</p>
<p>5.1 .html()</p>
<p>这种方法使用浏览器的innerHTML 属性。有些浏览器返回的结果可能不是原始文档的 HTML 源代码。例如，如果属性值只包含字母数字字符，Internet Explorer有时丢弃包裹属性值的引号。</p>
<p>5.2 .html( htmlString )</p>
<p>5.3 .html( function(index, oldhtml) )</p>
<p>这个 .html() 方法对 XML 文档无效.</p>
<p>我们可以使用 .html() 来设置元素的内容，这些元素中的任何内容会完全被新的内容取代。此外，用新的内容替换这些元素前，jQuery从子元素删除其他结构，如数据和事件处理程序。（愚人码头注：这样可以防止内存溢出。）</p>
<p>这种方法使用浏览器的innerHTML 属性。有些浏览器可能不完全复制所提供的HTML源代码生成DOM。例如，Internet Explorer的版本8之前转换所有链接的href属性为绝对URL路径，和Internet Explorer第9版之前，不增加一个单独的兼容层的情况下，将无法正确处理HTML5元素。</p>
<p><em>要设置一个&lt;script&gt;元素的内容， 其不包含HTML， 使用的 .text()方法，而不是.html()。所以在定义在script标签中的模板应该用.html()方法获取</em></p>
<p><em>注意:在Internet Explorer中，包括第9版，  设置HTML元素的文本内容可能会破坏其子节点的文本节点，结果导致子节点的文本节点从文档中被删除。如果你想保留这些 DOM 元素的引用，需要他们将保持不变，请使用.empty().html(string)来代替.html(string)，以便从文档中删除元素之前的元素被分配到新的字符串</em></p>
<p>6 .text()</p>
<p>6.1 .text()</p>
<p>和 .html() 方法不同， .text() 在XML 和 HTML 文档中都能使用。.text() 方法返回一个字符串，包含所有匹配元素的合并文本。  （由于在不同的浏览器中的HTML解析器的变化，返回的文本中换行和其他空白可能会有所不同。）</p>
<p>.text() 方法不能使用在 input 元素或scripts元素上。 input 或 textarea 需要使用 .val() 方法获取或设置文本值。得到scripts元素的值，使用.html()方法</p>
<p>从 jQuery 1.4开始， .text()方法返回文本内容和作为元素节点的CDATA 节点。</p>
<p>6.2 .text( text )</p>
<p>text<br>类型: String or Number or Boolean,<br>用于设置匹配元素内容的文本。当提供的是一个数值或布尔值得时候，那么将被转换成一个字符串表现形式，提供给这个方法。</p>
<p>6.3 .text( function(index, text) )</p>
<p>function(index, text)<br>类型: Function(),<br>用来返回设置文本内容的一个函数。接收元素的索引位置和文本值作为参数。</p>
<h3 id="DOM-插入-外部插入"><a href="#DOM-插入-外部插入" class="headerlink" title="DOM 插入, 外部插入"></a>DOM 插入, 外部插入</h3><p>有.after()，.before()，.insertAfter()，.insertBefore()</p>
<p>1 .after()</p>
<p>1.1 .after( content [, content ] )</p>
<p>1.2 .after( function )</p>
<p>function类型: Function( Integer index ) =&gt; htmlString or Element or jQuery</p>
<p>一个返回HTML字符串，DOM元素（或多个），文本节点（或多个），或jQuery对象的函数，返回的内容用来插入到集合中每个匹配元素的后面（愚人码头注：外部插入）。 接收元素集合中该元素的索引位置作为一个参数（index 参数）。在函数中this指向元素集合中的当前元素。</p>
<p>1.3 .after( function-html ),1.10版本添加</p>
<p>function类型: Function( Integer index, String html ) =&gt; htmlString or Element or jQuery<br>一个返回HTML字符串，DOM元素，jQuery对象的函数，返回的内容用来插入到集合中每个匹配元素的后面（愚人码头注：外部插入）。接收元素集合中该元素的索引位置（愚人码头注：index 参数）和元素的原来HTML值（愚人码头注：html 参数）作为参数。在函数中this指向元素集合中的当前元素。</p>
<p><em>在此之前的jQuery1.9， 如果该集合中的第一个节点没有在文档中， .after()将尝试添加 或 在当前的jQuery集合改变节点，在这种情况下返回一个新的jQuery集合，而不是原来的集合。该方法可能会或可能不会返回一个新的结果，这取决于它的参数个数或参数的连贯性！ 从jQuery1.9开始，.after(), .before(), 和 .replaceWith()总是返回原始未修改的集合。 试图在一个没有父级元素的节点上使用这些方法是没有效果的，也就是说，集合和它包含的节点都不会改变。</em></p>
<p>2 .before()</p>
<p>3 .insertAfter()</p>
<p>4 .insertBefore()</p>
<h3 id="DOM-移除"><a href="#DOM-移除" class="headerlink" title="DOM 移除"></a>DOM 移除</h3><p>有.detach()，.empty()，.remove()，.unwrap()</p>
<p>1 .detach()</p>
<p>.detach( [selector ] )，从DOM中去掉所有匹配的元素。</p>
<p>.detach() 方法和.remove()一样, 除了 .detach()保存所有jQuery数据和被移走的元素相关联。当需要移走一个元素，不久又将该元素插入DOM时，这种方法很有用。</p>
<p>2 .empty()</p>
<p>从DOM中移除集合中匹配元素的所有子节点。</p>
<p>为了避免内存泄漏，jQuery先移除子元素的数据和事件处理函数，然后移除子元素。</p>
<p>如果你想删除元素，不破坏他们的数据或事件处理程序（这些绑定的信息还可以在之后被重新添加回来），请使用.detach()代替 </p>
<p>3 .remove()</p>
<p>.remove( [selector ] )，将匹配元素集合从DOM中删除。</p>
<p>和 .empty()相似。.remove() 将元素移出DOM。 当我们想将元素自身移除时我们用 .remove()，同时也会移除元素内部的一切，包括绑定的事件及与该元素相关的jQuery数据。要删除的元素不删除数据和事件的情况下，使用.detach()来代替。</p>
<p>4 .unwrap()</p>
<p>将匹配元素集合的父级元素删除，保留自身（和兄弟元素，如果存在）在原来的位置。</p>
<p>4.1 .unwrap()</p>
<p>4.2 .unwrap( [selector ] )，添加版本3.0</p>
<p>selector类型: String，<br>一个选择器，用来检查匹配的父元素。如果一个元素的父不匹配该选择器，该元素将不会被解开。 (愚人码头注：该签名官网还未提供示例，可以查看我写的简单示例：<a target="_blank" rel="noopener" href="http://jsbin.com/rufaqu/edit?html,css,js,output">http://jsbin.com/rufaqu/edit?html,css,js,output</a>)</p>
<p>.unwrap()删除元素的父级元素。和 .wrap()的功能相反。匹配的元素（以及他们的兄弟元素，如果有的话）取代他们的父母在DOM结构。</p>
<h3 id="DOM-替换"><a href="#DOM-替换" class="headerlink" title="DOM 替换"></a>DOM 替换</h3><p>有.replaceAll()，.replaceWith()</p>
<p>1 .replaceAll()</p>
<p>.replaceAll( target )，用集合的匹配元素替换每个目标元素。</p>
<p>.replaceAll() 方法会删除与节点相关联的所有数据和事件处理程序 。</p>
<p>2 .replaceWith()</p>
<p>.replaceWith()方法，和大部分其他jQuery方法一样，返回jQuery对象，所以可以和其他方法链接使用， 但是需要注意的是： （original）原始jQuery对象被返回。该对象指向已经从 DOM 中被移除的对象，而不是指向已经取代了它的新元素。</p>
<h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><h3 id="筛选"><a href="#筛选" class="headerlink" title="筛选"></a>筛选</h3><p>有.eq(),.filter(),.first(),.has(),.is(),.last(),.map(),.not(),.slice()</p>
<p>1 .eq()</p>
<p>.eq( index ),支持负值，负值从最后一个元素倒数</p>
<p>2 .first()</p>
<p>3 .last()</p>
<p>4 .has()</p>
<p>.has( selector )</p>
<p>.has( contained )</p>
<p>contained<br>类型: Element，<br>用于匹配元素的DOM元素。</p>
<p>5 .is()</p>
<p>5.1 .is( selector )</p>
<p>5.2 .is( function(index) )</p>
<p>5.3 .is( jQuery object )</p>
<p>5.4 .is( element )</p>
<p>6 .filter()</p>
<p>参数种类同上</p>
<p>7 .not()</p>
<p>从匹配的元素集合中移除指定的元素。参数同理</p>
<p>8 .map()</p>
<p>.map( callback(index, domElement) )</p>
<p>如果你想处理一个简单的数组或对象中，使用jQuery.map()代替。</p>
<p>由于返回值是一个jQuery包裹的数组，所以通常会使用get()方法将其转换成普通的数组。</p>
<p>.map()方法特别适用于获取或设置元素集合中的值,如下获取一组checkbox的值</p>
<pre><code>$(&#39;:checkbox&#39;).map(function() &#123;
  return this.id;
&#125;).get().join();
</code></pre>
<p>在回调函数中，this指向每次迭代中的当前DOM元素。该函数可以返回一个单独的数据或数据数组，并在结果集合中插入。如果数组返回，数组中的元素插入到集合。如果函数返回null或undefined ，没有元素将被插入。</p>
<p>将一组div等高：</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;style&gt;
div &#123; width: 40px; float:left; &#125;
input &#123; clear:left&#125;
  &lt;/style&gt;
  &lt;script src=&quot;http://code.jquery.com/jquery-latest.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
 
 
&lt;input type=&quot;button&quot; value=&quot;equalize div heights&quot;&gt;
 
&lt;div style=&quot;background:red; height: 40px; &quot;&gt;&lt;/div&gt;
&lt;div style=&quot;background:green; height: 70px;&quot;&gt;&lt;/div&gt;
&lt;div style=&quot;background:blue; height: 50px; &quot;&gt;&lt;/div&gt;
 
 
&lt;script&gt;
$.fn.equalizeHeights = function() &#123;
  var maxHeight = this.map(function(i,e) &#123; //this为实例，即jquery对象
    return $(e).height();
  &#125;).get();
 
  return this.height( Math.max.apply(this, maxHeight) );
&#125;;
 
$(&#39;input&#39;).click(function()&#123;
  $(&#39;div&#39;).equalizeHeights();
&#125;);
 
&lt;/script&gt;
 
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>9 .slice()</p>
<p>.slice( start [, end ] )</p>
<p>根据指定的下标范围，过滤匹配的元素集合，并生成一个新的 jQuery 对象。</p>
<p>jQuery的.slice()方法是仿照的JavaScript 数组的.slice()方法。其中的一个功能就是允许传入负的 start 和 end 参数。如果传递的是负数，那么下标位置是从结尾开始的，而不是从起始位置开始。</p>
<h3 id="各种遍历"><a href="#各种遍历" class="headerlink" title="各种遍历"></a>各种遍历</h3><p>.add()，.contents()，.each()，.end()</p>
<p>1 .add()</p>
<p>创建一个新的jQuery对象 ，元素添加到匹配的元素集合中。</p>
<p>1.1 .add( selector )</p>
<p>1.2 .add( elements )</p>
<p>1.3 .add( html )</p>
<p>1.4 .add( jQuery object )</p>
<p>1.5 .add( selector, context )</p>
<p>2 .contents()</p>
<p>获得匹配元素集合中每个元素的子元素，包括文字和注释节点。</p>
<p>给定一个jQuery对象，表示一个DOM元素的集合，.contents()方法允许我们通过DOM树中查找集合中的直接子元素，并根据匹配的元素创建一个新的 jQuery 对象。.contents()和.children()方法类似，只不过前者包括文本节点和注释节点，以及jQuery对象中产生的HTML元素。请注意，虽然这种方式可以传递文本节点和注释节点给一个jQuery集合，但是大多数操作不会支持他们。少数几个支持的操作将在他们的API文档页面中有一个明确的说明。</p>
<p>如果iframe与主页同域，.contents()方法也可用于获取iframe中的文件内容。</p>
<p>3 .each()</p>
<p>遍历一个jQuery对象，为每个匹配元素执行一个函数。</p>
<p>我们可以通过返回 false以便在回调函数内中止循环。</p>
<p>注意: jQuery的方法，返回一个jQuery对象遍历jQuery集合中的元素 - 被称为隐式迭代的过程。当这种情况发生时，它通常不需要显式地循环的.each()方法：</p>
<p>4 .end()</p>
<p>终止在当前链的最新过滤操作，并返回匹配的元素的以前状态。</p>
<p>大多数 jQueryDOM遍历 方法来操作 jQuery 对象实例，并创建一个新的对象，匹配一个不同的 DOM 元素集合。当发生这种情况时，实际上是新的元素集合被压入到对象内部维护的栈中。每次过滤方法都会被压入栈中。当我们需要返回到前一个状态时，我们可以使用end() 进行出栈操作，来返回栈中的前一个状态。</p>
<h3 id="树遍历"><a href="#树遍历" class="headerlink" title="树遍历"></a>树遍历</h3><p>有.addBack()，.children()，.find()，.closest()，.parent()，.parents()，.parentsUntil()，.next()，.nextAll()，.nextUntil()，.prev()，.prevAll()，.prevUntil()，.siblings()</p>
<p>1 .addBack()</p>
<p>.addBack( [selector ] )</p>
<p>添加堆栈中元素集合到当前集合，一个选择性的过滤选择器。</p>
<p>如上所述在讨论中的.end()， jQuery对象维护一个堆栈内部来跟踪匹配的元素集合的变化。当一个DOM遍历方法被调用时，新的元素集合推入到堆栈中。 如果还需要包含先前的元素集合，.addBack() 可以提供帮助。</p>
<pre><code>$(&#39;li.third-item&#39;).nextAll().addBack()
      .css(&#39;background-color&#39;, &#39;red&#39;);
</code></pre>
<p>2 .children()</p>
<p>.children()方法允许我们通过在DOM树中对这些元素的直接子元素进行搜索，并且构造一个新的匹配元素的jQuery对象。.find()和.children()方法是相似的，但后者只是针对向下一个级别的DOM树。还要注意的是和大多数的jQuery方法一样，.children()不返回文本节点;让所有子元素包括使用文字和注释节点，建议使用.contents()。</p>
<p>3 .find()</p>
<p>.find( selector )</p>
<p>.find( element ) 元素或jQuery对象</p>
<p>4 .closest()</p>
<p>从元素本身开始，在DOM 树上逐级向上级元素匹配，并返回最先匹配的祖先元素。</p>
<p>.parents()和.closest()方法类似，它们都在DOM树遍历了。两者之间的差异，尽管细微，是重要的：</p>
<ul>
<li>.closest()开始于当前元素，.parents()开始于父元素</li>
<li>.closest()在 DOM 树中向上遍历，直到找到与提供的选择器相匹配的元素，.parents()向上遍历DOM树到文档的根元素，每个祖先元素加入到临时集合，如果提供一个选择器，则会使用该选择器在集合中进行过滤</li>
<li>.closest()返回包含零个或一个元素的jQuery对象，.parents()返回包含零个，一个或多个元素的jQuery对象</li>
</ul>
<p>5 .parent()</p>
<p>6 .parents()</p>
<p>.parents()和.parent()方法是相似的，但后者只是进行了一个单级的DOM树查找（愚人码头注：也就是只查找一层，直接的父元素，而不是更加上级的祖先元素）。此外，$( “html” ).parent()方法返回一个包含document的集合，而$( “html” ).parents()返回一个空集合。</p>
<p>7 ..parentsUntil()</p>
<p>8 .next()</p>
<p>9 .nextAll()</p>
<p>10 .nextUntil()</p>
<p>11 .prev()</p>
<p>12 .prevAll()</p>
<p>13 .prevUntil()</p>
<p>14 .siblings()</p>
<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><h3 id="浏览器事件"><a href="#浏览器事件" class="headerlink" title="浏览器事件"></a>浏览器事件</h3><p>1 .resize()</p>
<p>1.1 .resize( handler(eventObject) )</p>
<p>1.2 .resize( [eventData ], handler(eventObject) )</p>
<p>1.3 .resize()</p>
<p>这个函数的前两个用法是 .bind(‘resize’, handler) 的快捷方式，第3个不带参数的用法是 .trigger(‘resize’) 的快捷方式。</p>
<p>当浏览器window的尺寸改变时，window元素上绑定的resize事件将被触发</p>
<p>2 .scroll()</p>
<p>当用户在元素内执行了滚动操作，就会在这个元素上触发scroll事件。它适用于window对象，但也可以是可滚动frames与CSS overflow属性设置为scroll的元素（或auto时，元素的显示高度小于其内容高度）</p>
<p>每当元素的滚动位置的变化时，该元素就会触发scroll事件，不管什么原因。鼠标点击或拖动滚动条，拖动里面的元素，按箭头键，或使用鼠标的滚轮都可能导致触发此事件。</p>
<h3 id="文档加载"><a href="#文档加载" class="headerlink" title="文档加载"></a>文档加载</h3><p>1 jQuery.holdReady()</p>
<p> 暂停或恢复.ready() 事件的执行。</p>
<p> jQuery.holdReady( hold )</p>
<p>hold类型: Boolean</p>
<p>指示是否暂停或恢复被请求的ready事件</p>
<p>在$.holdReady()方法允许调用者延迟jQuery的ready事件。这种先进的功能，通常会被用来允许在 ready 事件发生之前，动态加载其它的 JavaScript，例如 jQuery 插件，即使 DOM 可能已经准备就绪。该方法必须在文档早期被调用，例如，在 <head> 中加载完 jQuery 脚本之后，立刻调用该方法。如果在 ready 事件已经被调用后再调用该方法，将不会起作用。</p>
<p>为了延迟 ready 事件，首先要调用 $.holdReady(true)，当 ready 事件准备执行时，再调用 $.holdReady(false) 。注意，在 ready 事件中可以设置多个 hold。每一个都对应一次 $.holdReady(true) 调用。直到所有的 hold 都被释放，也就是调用了对应数量的 $.holdReady(false)之后，并且满足正常的文档 ready 条件时，ready 事件才会被真正执行。（见ready的更多信息。）)</p>
<pre><code>$.holdReady(true);
$.getScript(&quot;myplugin.js&quot;, function() &#123;
  $.holdReady(false);
&#125;);
</code></pre>
<p>2 .ready()</p>
<p>当DOM准备就绪时，指定一个函数来执行。</p>
<p>大多数浏览器提供了 DOMContentLoaded 事件形式的类似功能。 然而，jQuery的 .ready() 方法的不同之处在于它是一个重要并且有效的方法：在代码调用.ready( handler )之前，如果 DOM 已经准备就绪并且浏览器已经触发DOMContentLoaded，handler处理函数仍然会被执行。 相反，如果 DOMContentLoaded 事件侦听器在这个事件触发后才被添加进来，那么这个DOMContentLoaded 事件的处理程序将永远不会被执行。</p>
<p>浏览器还提供了 window 对象上的load事件。当这个事件触发时候，表明该网页上的所有资源已加载，包括图像。此事件可以使用jQuery的$( window ).on( “load”, handler )监听。当代码依赖加载的资源情况下，（例如，必需知道图像的尺寸时），那么代码应放置在一个 load事件的处理程序中。</p>
<p>值得注意的是，虽然 DOM 准备就绪（ready）总是在页面被完全加载之前，但是在已经生效执行的 .ready() 处理程序代码中绑定load事件侦听器，通常是不安全的。例如，在页面加载后，可以使用一些方法动态加载脚本，如$.getScript() 。虽然动态加载的脚本中的 .ready() 处理程序始终会被执行， 但是在动态加载脚本中的 window 的 load 事件已经触发过了，所以那些load 事件监听器将永远不会运行。</p>
<p>jQuery提供了几种方法来绑定函数，当DOM已准备就绪时，绑定的函数将会运行。在jQuery 3.0 中，只建议使用第一种语法（愚人码头注：即 $( handler )）; 其他语法仍然能正常工作，但已被标记为弃用（愚人码头注：将来的某个版本会被删除）。$(document).on( “ready”, handler ),从jQuery 1.8开始已被标记为弃用，在jQuery 3.0中已经被删除。请注意。</p>
<p>当$快捷方式不再可用时，$.noConflict()可以用于避免命名空间冲突。然而，传递给.ready() 的处理函数可以传递一个引用jQuery对象的参数。这使得处理程序中能够使用jQuery对象，例如，用作$,这样就可以不用关心它的别名：</p>
<pre><code>jq2 = jQuery.noConflict();
jq2(function( $ ) &#123;
  // 在这个代码块中可以像往常一样使用 $ ;实际的jQuery 对象是 jq2 
&#125;);
</code></pre>
<h3 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h3><p>1 .bind()</p>
<p>在jQuery 3.0中，.bind()已被标记为弃用。从jQuery 1.7开始，.on() 方法是将事件处理程序绑定到文档（document）的首选方法。所以我们不建议使用该方法。</p>
<p>2 .delegate()</p>
<p>在jQuery 3.0中，.delegate()已被标记为弃用。从jQuery 1.7开始，它已经被.on()方法取代。所以我们不建议使用该方法。</p>
<p>3 .on()</p>
<p>3.1 .on( events [, selector ] [, data ], handler(eventObject) )</p>
<p>events<br>类型: String，<br>一个或多个空格分隔的事件类型和可选的命名空间，或仅仅是命名空间，比如”click”, “keydown.myPlugin”, 或者 “.myPlugin”。</p>
<p>selector<br>类型: String，<br>一个选择器字符串，用于过滤出被选中的元素中能触发事件的后代元素。如果选择器是 null 或者忽略了该选择器，那么被选中的元素总是能触发事件。，</p>
<p>data<br>类型: Anything，<br>当一个事件被触发时，要传递给事件处理函数的event.data。</p>
<p>handler(eventObject)<br>类型: Function()，<br>事件被触发时，执行的函数。若该函数只是要执行return false的话，那么该参数位置可以直接简写成 false。</p>
<p>3.2 .on( events [, selector ] [, data ] )</p>
<p>events<br>类型: PlainObject，<br>一个对象，键是由一个或多个由空格分隔的事件类型及可选的名字空间，值是这些事件类型所对应的事件处理函数。</p>
<p>selector<br>类型: String，<br>一个选择器字符串，用于过滤出被选中的元素中能触发事件的后代元素。如果选择器是 null 或者忽略了该选择器，那么被选中的元素总是能触发事件。</p>
<p>data<br>类型: Anything，<br>当一个事件被触发时，要传递给事件处理函数的event.data。</p>
<p>（1）Event names and namespaces（事件名称和命名空间）</p>
<p>事件名称可以添加指定的event namespaces（命名空间） 来简化删除或触发事件。例如，”click.myPlugin.simple”为 click 事件同时定义了两个命名空间 myPlugin 和 simple。通过上述方法绑定的 click 事件处理，可以用.off(“click.myPlugin”) 或 .off(“click.simple”)删除绑定到相应元素的Click事件处理程序，而不会干扰其他绑定在该元素上的“click（点击）” 事件。命名空间类似CSS类，因为它们是不分层次的;只需要有一个名字相匹配即可。以下划线开头的名字空间是供 jQuery 使用的。</p>
<p>在.on()方法的第二种用法中，events参数是一个JavaScript对象或者键值对。键等同于events参数，用空格分隔的事件名称字符串和可选命名空间。每个键的值是一个函数（或false 的值），相当于 handler 参数，但是该值并不是方法中的最后一个参数。在其它方面，这两种形式在下面描述的内容中其行为都是相同的。</p>
<p>（2）Direct and delegated events（直接和委托的事件）</p>
<p>除了可以给未创建的后代元素绑定事件外，代理事件的另一个好处就是，当需要监视很多元素的时候，代理事件的开销更小。</p>
<p>注意: 委托事件不能用于SVG.</p>
<p>（3）The event handler and its environment（事件处理程序和它的环境）</p>
<p>默认情况下，大多数事件的冒泡从最初的 event target（目标元素） 开始的，直到document 元素。每个元素都沿着DOM层级这条路，jQuery会调用任何匹配的已被绑定的事件处理程序。一个处理程序可以调用的event.stopPropagation()防止事件向上冒泡文档树（从而防止这些元素的处理程序运行）。任何绑定到当前元素上的其他处理程序都将运行，为了防止这种情况，可以调用event.stopImmediatePropagation()。（绑定在元素上的事件被调用的顺序和它们被绑定的顺序时一样的。 ）</p>
<p>类似地，一个处理程序可以调用的event.preventDefault()取消浏览器默认操作行为。</p>
<p>调用event.stopPropagation() 和 event.preventDefault()会从一个事件处理程序会自动返回false。也可以直接将 false 当作 handler 的参数，作为 function(){ return false; } 的简写形式。</p>
<p>当jQuery的调用处理程序时，this关键字指向的是当前正在执行事件的元素。对于直接事件而言，this 代表绑定事件的元素。对于代理事件而言，this 则代表了与 selector 相匹配的元素。(注意，如果事件是从后代元素冒泡上来的话，那么 this 就有可能不等于 event.target。)若要使用 jQuery 的相关方法，可以根据当前元素创建一个 jQuery 对象，即使用 $(this)。</p>
<p>（4） Passing data to the handler（将数据传递到处理程序）</p>
<p>如果data参数给.on()并且不是null 或者 undefined，那么每次触发事件时，event.data都传递给处理程序。data参数可以是任何类型，但如果是字符串类型时，那么selector参数必须提供，或明确地传递null，这样的 data 参数不会误认为是选择器。最好是使用一个对象（键值对） ，所以可以作为属性传递多个值。</p>
<p>jQuery的1.4以后 ，相同的事件处理程序可以多次绑定到一个元素。这对于使用 event.data 功能，或者在闭包中使用唯一的数据时是特别有用的。例如：</p>
<pre><code>function greet( event ) &#123;
  alert( &quot;Hello &quot; + event.data.name );
&#125;
$( &quot;button&quot; ).on( &quot;click&quot;, &#123;
  name: &quot;Karl&quot;
&#125;, greet );
$( &quot;button&quot; ).on( &quot;click&quot;, &#123;
  name: &quot;Addy&quot;
&#125;, greet );
</code></pre>
<p>按一下按钮时，上面的代码会产生两个不同的警告（alert）。</p>
<p>除了可以向 .on() 方法传入 data 参数外，还可以向 .trigger() 或 .triggerHandler() 中传入该参数。 这种方式提供数据（Data）被传递给事件处理程序的Event 对象内，作为进一步的参数。 如果传递给.trigger() 和 .triggerHandler()的第二个参数是一个数组， 数组中的每个元素将作为事件处理程序的单独参数。</p>
<p>（5）Event performance（事件性能）</p>
<p>对于高频率事件，可以按如下的办法提高事件的性能：</p>
<ul>
<li>减少事件处理函数中的工作量；</li>
<li>对于在事件处理函数中要用到的信息做好缓存而不是再重新计算一次；</li>
<li>或使用setTimeout限制的页面更新的实际次数。</li>
</ul>
<p>为了获得更好的性能，在绑定代理事件时，绑定的元素最好尽可能的靠近目标元素。避免在大型文档中，过多的在 document 或 document.body 上添加代理事件。</p>
<p>若代理事件的选择器使用了过于复杂的形式，特别是使用了分层选择器的情况，虽然说这样做会大大的降低性能，但是对于大多数应用而言，它的速度依然是足够快的。通过为寻找更合适的元素绑定事件的方法，就可以很简单的避免使用分层选择器的情况。</p>
<p>（6）Additional notes（其他注意事项）</p>
<p>虽然不建议，伪类事件名称”hover”可以作为”mouseenter mouseleave”的缩写使用。不要与 接受两个函数的.hover()方法混淆，这里只用一个处理函数绑定到伪类事件名称”hover”;处理程序应该检查的event.type 以确定是否是mouseenter或 mouseleave事件。</p>
<p>jQuery的事件系统需要一个DOM元素可以通过元素的属性附加数据，使事件就可以被跟踪和传递。object, embed, 和applet元素不能绑定数据，因此不能有jQuery的事件绑定。</p>
<p>W3C指定明确指定focus 和 blur事件没有冒泡，但是jQuery定义的跨浏览器的focusin 和 focusout事件，并且可以冒泡。当focus 和 blur绑定委派的事件处理程序时，jQuery分析名称，并提供将他们分别交付给focusin 和 focusout。为了保持一致性和清晰度，使用冒泡事件类型的名称。</p>
<p>在所有的浏览器，load ，scroll, 和 error 事件(例如, 在一个 <img> 元素上)不会冒泡。在Internet Explorer 8和更低，paste 和 reset事件不会冒泡，这样的事件是不支持委派使用，但若事件处理函数是直接绑定在产生事件的元素上的话，是可以使用这些事件的。</p>
<p>window对象上的error 事件使用非标准的参数和返回值约定，所以jQuery 不支持该事件。作为替代，直接用window.onerror属性分配一个处理函数。</p>
<p>当事件被首次触发时，处理函数列表才会被设置到元素上。当前元素上添加或删除事件处理函数不会立即生效，直到下一次的事件被处理。 为了避免任何后续事件处理函数在一个元素的事件处理函数中执行，调用event.stopImmediatePropagation() 这种行为违反了<a target="_blank" rel="noopener" href="https://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-EventTarget-removeEventListener">W3C的事件规范</a>。 为了更好地了解这种情况下，考虑下面的代码：</p>
<pre><code>var $test = $( &quot;#test&quot; );

function handler1() &#123;
  console.log( &quot;handler1&quot; );
  $test.off( &quot;click&quot;, handler2 );
&#125;
 
function handler2() &#123;
  console.log( &quot;handler2&quot; );
&#125;
 
$test.on( &quot;click&quot;, handler1 );
$test.on( &quot;click&quot;, handler2 );
</code></pre>
<p>在上面的代码，handler2第一次无论如何都会被执行，即使使用.off()删除。 然而，该处理函数在下一次click事件被触发时将不执行。（愚人码头注：查看代码运行效果：<a target="_blank" rel="noopener" href="http://jsfiddle.net/feiwen8772/dgxru81d/%EF%BC%89">http://jsfiddle.net/feiwen8772/dgxru81d/）</a></p>
<p>（7）一些事例</p>
<p>传递一个数组给.trigger()的事件处理程序，作为第二个参数。</p>
<pre><code>$( &quot;div&quot; ).on( &quot;click&quot;, function( event, salutation, name ) &#123;
  alert( salutation + &quot;, &quot; + name );
&#125;);
$( &quot;div&quot; ).trigger( &quot;click&quot;, [ &quot;Goodbye&quot;, &quot;Jim&quot; ] );
</code></pre>
<p>添加并触发自定义事件（非浏览器事件）。</p>
<pre><code>&lt;!doctype html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;utf-8&quot;&gt;
  &lt;title&gt;on demo&lt;/title&gt;
  &lt;style&gt;
  p &#123;
    color: red;
  &#125;
  span &#123;
    color: blue;
  &#125;
  &lt;/style&gt;
  &lt;script src=&quot;//code.jquery.com/jquery-1.10.2.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
 
&lt;p&gt;Has an attached custom event.&lt;/p&gt;
&lt;button&gt;Trigger custom event&lt;/button&gt;
&lt;span style=&quot;display:none;&quot;&gt;&lt;/span&gt;
 
&lt;script&gt;
$( &quot;p&quot; ).on( &quot;myCustomEvent&quot;, function( event, myName ) &#123;
  $( this ).text( myName + &quot;, hi there!&quot; );
  $( &quot;span&quot; )
    .stop()
    .css( &quot;opacity&quot;, 1 )
    .text( &quot;myName = &quot; + myName )
    .fadeIn( 30 )
    .fadeOut( 1000 );
&#125;);
$( &quot;button&quot; ).click(function () &#123;
  $( &quot;p&quot; ).trigger( &quot;myCustomEvent&quot;, [ &quot;John&quot; ] );
&#125;);
&lt;/script&gt;
 
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>使用 对象 同时添加多个事件处理函数。</p>
<pre><code>$( &quot;div.test&quot; ).on(&#123;
  click: function() &#123;
    $( this ).toggleClass( &quot;active&quot; );
  &#125;, mouseenter: function() &#123;
    $( this ).addClass( &quot;inside&quot; );
  &#125;, mouseleave: function() &#123;
    $( this ).removeClass( &quot;inside&quot; );
  &#125;
&#125;);
</code></pre>
<p>在同一个元素上绑定多个事件，一个mouseenter和mouseleave：</p>
<pre><code>$( &quot;#cart&quot; ).on( &quot;mouseenter mouseleave&quot;, function( event ) &#123;
  $( this ).toggleClass( &quot;active&quot; );
&#125;);
</code></pre>
<p>4 .off()</p>
<p>5 .one()</p>
<p>6 .trigger()</p>
<pre><code>$(&#39;#foo&#39;).on(&#39;custom&#39;, function(event, param1, param2) &#123;
  alert(param1 + &quot;\n&quot; + param2);
&#125;);
$(&#39;#foo&#39;).trigger(&#39;custom&#39;, [&#39;Custom&#39;, &#39;Event&#39;]);
</code></pre>
<p>注意: 对于非window的普通的对象和DOM对象， 如果一个触发事件名称和对象的一个属性名称相匹配， 如果事件处理程序没有调用event.preventDefault()，jQuery将尝试调用属性的方法。 如果不希望这种行为发生，请使用.triggerHandler() 来代替。（愚人码头注 .triggerHandler() 方法并不会触发事件的默认行为。）</p>
<p>注意: 和.triggerHandler()一样， 当调用.trigger()时，当一个事件名称匹配对象上属性名称时，属性名称会加上on前缀（如，在 具有非空onclick方法的window上触发click），  jQuery将尝试调用该属性作为方法。</p>
<p>注意: 当通过一个普通的对象不是类数组触发时 但仍然包含了length属性， 你应该传递对象到数组中（例如：[ { length: 1 } ]）。</p>
<p>7 .triggerHandler()</p>
<p>这个方法的行为与 .trigger() 相似，不同之处有如下几点：</p>
<ul>
<li><p>.triggerHandler( “event” )方法被触发时不会调用元素上的 .event()。 这意味着在表单上触发 .triggerHandler( “submit” )将不会调用表单上的.submit()。（愚人码头注：可以理解为.triggerHandler() 方法并不会触发事件的默认行为。(例如，表单提交)。）</p>
</li>
<li><p>.trigger() 会影响所有与 jQuery 对象相匹配的元素，而 .triggerHandler() 仅影响第一个匹配到的元素。</p>
</li>
<li><p>使用 .triggerHandler() 触发的事件，并不会在 DOM 树中向上冒泡。 如果它们不是由目标元素直接触发的，那么它就不会进行任何处理。<br>与普通的方法返回 jQuery 对象(这样就能够使用链式用法)相反，.triggerHandler()返回最后一个处理的事件的返回值。如果没有触发任何事件，会返回 undefined。</p>
</li>
</ul>
<p>8 .unbind()</p>
<p>在jQuery 3.0中，.unbind()已被标记为弃用。从jQuery 1.7开始，它已经被.off()方法取代。所以我们不建议使用该方法。</p>
<p>9 .undelegate()</p>
<p>在jQuery 3.0中，.undelegate()已被标记为弃用。从jQuery 1.7开始，它已经被.off()方法取代。所以我们不建议使用该方法。</p>
<h3 id="表单事件"><a href="#表单事件" class="headerlink" title="表单事件"></a>表单事件</h3><p>1 .blur()</p>
<p>一个元素失去焦点将触发blur事件。起初，这个事件仅适用于表单元素，如元素<input> 。在最新的浏览器中，这个事件适用范围已经扩大到包括所有元素类型。一个元素可以通过键盘命令失去焦点，比如tab键，或用鼠标点击网页上的其他地方。</p>
<p>应用不带参数的.blur()，我们可以手动触发这个事件:</p>
<p>2 .change()</p>
<p>一个元素的值改变的时候将触发change事件。此事件仅限用于<input>元素，<textarea>和<select>元素。对于下拉选择框，复选框和单选按钮，当用户用鼠标作出选择，该事件立即触发，但对于其他类型的input元素，该事件触发将推迟，直到元素失去焦点才会触发。</p>
<p>注意: 使用JavaScript改变输入元素的值，例如使用.val()，将不会触发该事件。</p>
<p>3 .focus()</p>
<p>当一个元素获得焦点时，focus事件被触发。此事件起初适用于有限的元素，比如表单元素（<input>, <select>等）和链接元素（<a href>）。在最近版本的浏览器中，该事件可以扩展到所有包括通过显式设置tabindex属性的元素类型。一个元素可以通过键盘命令获得焦点，如Tab键，或按鼠标点击的元素。</p>
<p>试图将焦点设置到一个隐藏的元素在Internet Explorer中导致错误。请注意，.focus()只能在可见元素上使用。要在一个元素执行focus事件却又不想让这个元素获取焦点的话， 请使用.triggerHandler(“focus”) 来代替 .focus()。</p>
<p>focus事件不会在Internet Explorer中冒泡。因此，用focus事件委派，跨浏览器无法正常工作。但是，在1.4.2版本， jQuery的解决此限制，将focus模拟为focusin 事件</p>
<p>4 .select()</p>
<p>当用户在一个元素中进行文本选择时，这个元素上的select事件就会被触发。此事件只能用在<input type="text"> 和<textarea>。</p>
<p>用于检索当前选定文本的方法在各个浏览器中是不同的。jQuery的一个插件都提供跨平台的解决方案。</p>
<p>5 .submit()</p>
<p>当用户试图提交表单时，就会在这个表单元素上触发submit事件。它只能绑定在<form>元素上。以下几种情况会导致表单被提交：用户点击了<input type="submit">, <input type="image">, 或者 <button type="submit">，或者当某些表单元素获取焦点时，敲击Enter（回车键），都可以提交。</p>
<p>根据不同的浏览器，Enter 键可能会导致表单被提交，如果这个表单只有一个文本框或只有一个 submit 按钮的话。界面不应该依赖于这个键的特殊行为，除非已经使用了 keypress 事件来监听 Enter 键的按下。</p>
<p>我们可以通过调用事件对象的.preventDefault()或在处理函数中返回 false 来取消提交：</p>
<p>在Internet Explorer中，JavaScript的submit事件不会冒泡。但是，依赖 submit 事件代理的脚本，从 jQuery 1.4 开始，可以跨浏览器正常使用。</p>
<h3 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件"></a>键盘事件</h3><p>1 .keydown()</p>
<p>当用户在一个元素上按下键盘上的键的时候，keydown事件就会发送给这个元素。 如果按下该键不放（保持按下状态），事件被重复发送到该键，时间间隔取决于操作系统。它可以绑定到任何元素，但该事件只是发送到具有焦点的元素上。不同的浏览器中，可获得焦点的元素略有不同，但是表单元素总是能获取焦点，所以对于此事件类型表单元素是最合适的。</p>
<p>如果需要任何按键被捕获（例如，要实现网页全局上的快捷键），那么把这个事件附加到document对象上是非常有用的。所有的按键事件都会沿着各自的 DOM 树冒泡到 document 对象上，除非明确停止。</p>
<p>要确定哪个键被按下，我们可以检测传递给处理函数的event 对象。而浏览器使用不同的属性来存储这些信息，jQuery的规范了.which属性，以便我们能够可靠地使用它来检索关键代码。此代码对应一个键盘上的按键，包括像方向键这种特殊键的代码，如果要捕获实际输入文本， .keypress()可能是一个更好的选择。</p>
<p>2 .keypress()</p>
<p>注意:：由于keypress事件没有统一的官方规范说明，所以在不同的浏览器，不同的浏览器版本，和不同的平台实际使用这个事件时可能遇到的问题。</p>
<p>当浏览器捕获一个元素上键盘输入时，keypress就会发送个元素。这是类似keydown事件，除了当按键被一直按下（即连续插入字符的场合）时的处理。如果用户按下并按住这个键（不松开释放）的时候，keydown事件只触发一次，但是keypress会在每个字符插入的时候都会触发事件。此外，组合键（如Shift）会触发keydown事件，但不会触发keypress事件。</p>
<p>值得注意的是keydown 和 keyup提供一个代码，表示哪一个键被按下，而keypress表示被输入哪个字符。例如，按下了小写的 “a”，在 keydown和keyup 中，对应该键的代码是 65，但是对于 keypress 而言，接收到的代码是 97。如果是大写 “A” 的话，则所有的相关事件接收到的代码都是 65。由于这个区别，若想捕获敲击了哪个特殊键的话，例如，方向键，使用 .keydown()或.keyup() 更好。</p>
<p>在文本框中按下某个键时，显示 event 对象。注意：输出 event 对象时，要依赖一个简单的 $.print() 插件 (<a target="_blank" rel="noopener" href="http://api.jquery.com/scripts/events.js)%E3%80%82">http://api.jquery.com/scripts/events.js)。</a></p>
<p>3 .keyup()</p>
<h3 id="鼠标事件"><a href="#鼠标事件" class="headerlink" title="鼠标事件"></a>鼠标事件</h3><p>1 .click()</p>
<p>2 .contextmenu()</p>
<p>当在一个元素上点击鼠标的右键时,contextmenu事件被发送到这个元素上,但在显示的上下文菜单(右键菜单)之前。 这时上下文菜单键被按下，该事件在html元素上被触发。 任何HTML元素都可以接受此事件。</p>
<p>3 .dblclick()</p>
<p>在同一元素上同时绑定 click 和 dblclick 事件是不可取的。各个浏览器事件触发的顺序是不同的，一些浏览器在dblclick之前接受两个 click 事件 ，而和其它浏览器只接受一个 click 事件。用户往往可通过不同的操作系统和浏览器配置双击灵敏度（两次点击之间的最大时间被检测为双击）</p>
<p>4 .focusin()</p>
<p>focusin 事件会在元素（或者其内部的任何元素）获得焦点时触发。这跟 focus 事件的显著区别在于，它可以在父元素上检测子元素获得焦点的情况(换而言之，它支持事件冒泡)。</p>
<p>5 .focusout()</p>
<p>focusout 事件会在元素（或者其内部的任何元素）失去焦点时触发。这跟 blur 事件的显著区别在于，它可以在父元素上检测子元素失去焦点的情况(换而言之，它支持事件冒泡)。</p>
<p>6 .hover()</p>
<p>.hover()方法是同时绑定 mouseenter和 mouseleave事件</p>
<p>7 .mousedown()</p>
<p>任何鼠标按钮被按下时mousedown事件就会被发送。若要区分是哪个键被按下了，我们可以使用 event 对象的which属性。并非所有浏览器都支持这个属性（在 IE 中，要使用 button 属性来代替），但是jQuery对该属性进行了标准化，因此你可以放心的在任何浏览器中使用该属性。敲击鼠标左键which的值是1，敲击鼠标中键which的值是2，敲击鼠标右键which的值是3。</p>
<p>此事件主要用于确保主要按钮是用来开始拖动操作;如果不进行这样的判断，当用户尝试使用上下文菜单，可能会出现奇怪的结果。虽然可以通过这些属性，来检测鼠标中键和右键的点击，但不一定是可靠的。例如，在 Opera 和 Safari 中，默认情况下是无法检测鼠标右键的点击的。</p>
<p>如果在一个元素按住了鼠标不放，并且拖动鼠标离开这个元素，并释放鼠标键，这仍然是算作mousedown事件。在大多数的用户界面，这个动作的顺序被视为一个“取消”的按键，所以通常最好使用click事件，除非我们知道mousedown事件针对一个特定情况较好。</p>
<p>8 .mouseup()</p>
<p>9 .mouseenter()</p>
<p>mouseenter事件和mouseover的不同之处是事件的冒泡的方式。如果mouseover在这个例子中使用了，然后当鼠标指针在Inner元素上移动，该处理程序将被触发。这通常是不受欢迎的行为。另一方面, mouseenter 事件只会在绑定它的元素上被调用，而不会在后代节点上被触发。</p>
<p>10 .mouseleave()</p>
<p>mouseleave事件和mouseover的不同之处是事件的冒泡的方式。如果mouseover在这个例子中使用了，然后当鼠标指针在Inner元素上移出，该处理程序将被触发。这通常是不受欢迎的行为。另一方面, mouseleave 事件只会在绑定它的元素上被调用，而不会在后代节点上被触发</p>
<p>11 .mousemove()</p>
<p>当跟踪鼠标移动时，我们通常需要知道实际的鼠标指针的位置。event 对象传递给处理程序包含了一些有关鼠标的坐标信息。比如.clientX, .offsetX, 和 .pageX属性是有效的，但对他们的支持不同浏览器。幸运的是，jQuery的规范了.pageX和.pageY属性，以便他们能够在所有浏览器上使用。这些属性提供了鼠标指针位置相对于页面的左上角的X和Y坐标。</p>
<p>我们必须记住， mousemove事件是当鼠标指针移动时触发的，即使是一个像素。这意味着多个事件在短时间内被触发。如果处理器做任何重大的处理，或者如果该事件存在多个处理函数，这可能造成浏览器的严重的性能问题。因此，优化mousemove处理程序尽可能，这一点很重要，当不再需要他们时应尽快解除绑定。</p>
<p>一个常见的模式是在mousedown处理器内部绑定mousemove处理器，并在一个相应mouseup处理函数解除绑定。要实现这一系列事件，请记住，与 mouseup 事件相比，mouseup 事件可能会被发送到不同的 HTML 元素上。由于这个原因，mouseup 事件通常应该绑定在更高的 DOM 树中，例如 <body>。</p>
<p>12 .mouseout()</p>
<p>由于此事件类型冒泡，可能导致引起的很多头痛的问题。例如，在这个例子中当鼠标指针移出Inner元素，mouseout事件将被发送到Inner元素，然后冒泡到Outer元素 。这可能会不合时宜的触发绑定的mouseout处理函数。这可以用一个替代方法，见讨论. mouseleave ()。</p>
<p>13 .mouseover()</p>
<p>由于此事件类型冒泡，可能导致引起的很多头痛的问题。例如，在这个例子中当鼠标指针移出Inner元素，mouseover事件将被发送到Inner元素，然后冒泡到Outer元素 。这可能会不合时宜的触发绑定的mouseover处理函数。这可以用一个替代方法，见讨论. mouseenter ()。</p>
<h3 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h3><p>1 event.currentTarget</p>
<p>在事件冒泡过程中的当前DOM元素。</p>
<p>这个属性总是等于函数的this。</p>
<p>如果您使用jQuery.proxy或另一种形式操作作用域，this 将等于您所提供的context（上下文），而不是event.currentTarget</p>
<p>2 event.target</p>
<p>target 属性可以是注册事件时的元素，或者它的子元素。通常用于比较 event.target 和 this 来确定事件是不是由于冒泡而触发的。经常用于事件冒泡时处理事件委托。</p>
<p>3 event.relatedTarget</p>
<p>在事件中涉及的其它任何DOM元素。</p>
<p>对于 mouseout 事件，它指向被进入的元素；对于 mouseover 事件，它指向被离开的元素。</p>
<p>4 event.data</p>
<p>当当前正在执行的处理程序绑定时，一个可选的数据对象传递给一个事件方法。</p>
<p>5 event.type</p>
<p>6 event.timeStamp</p>
<p>通过在代码中获得两个点之间的 event.timeStamp 值，并给出差值来分析事件的性能，此属性是很有用的。如果只是要确定当前的时间内的事件处理程序，使用(new Date).getTime()来代替。</p>
<p>7 event.which</p>
<p>event.which 将 event.keyCode 和 event.charCode 标准化了。推荐用 event.which 来监视键盘输入。更多细节请参阅： event.charCode on the MDN.</p>
<p>event.which也将正常化的按钮按下(mousedown 和 mouseupevents)，左键报告1，中间键报告2，右键报告3。使用event.which代替event.button。</p>
<p>8 event.namespace</p>
<p>当事件被触发时此属性包含指定的命名空间。</p>
<p>这属性主要提供给插件作者用来处理的不同任务，具体取决于事件使用的命名空间。</p>
<p>9 event.result</p>
<p>事件被触发的一个事件处理程序的最后返回值，除非值是 undefined。</p>
<p>此属性当获取自定义事件前一个返回值时非常有用的。</p>
<p>10 event.pageX</p>
<p>11 event.pageY</p>
<p>12 event.isDefaultPrevented()</p>
<p>13 event.isImmediatePropagationStopped()</p>
<p>14 event.isPropagationStopped()</p>
<p>15 event.stopImmediatePropagation()</p>
<p>阻止剩余的事件处理函数执行并且防止事件冒泡到DOM树上。</p>
<p>16 event.stopPropagation()</p>
<h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p>1 .hide()</p>
<p>1.1 .hide()</p>
<p>1.2 .hide( [duration ] [, complete ] )</p>
<p>duration (默认: 400)<br>类型: Number or String，<br>一个字符串或者数字决定动画将运行多久。</p>
<p>complete<br>类型: Function()，<br>在动画完成时执行的函数。</p>
<p>1.3 .hide( [duration ] [, easing ] [, complete ] )</p>
<p>1.4 .hide( options )</p>
<p>options<br>类型: PlainObject，<br>一组包含动画选项的值的集合。 支持的选项：</p>
<p>duration (default: 400)</p>
<p>easing (default: swing)，jQuery自身提供”linear” 和 “swing”，其他效果可以使用<a target="_blank" rel="noopener" href="http://gsgd.co.uk/sandbox/jquery/easing/">jQuery Easing Plugin</a>插件）</p>
<p>queue (default: true)<br>Type: Boolean or String,<br>一个布尔值，指示是否将动画放置在效果队列中。如果为false时，将立即开始动画。 从jQuery1.7开始，队列选项也可以接受一个字符串，在这种情况下，在动画被添加到由该字符串表示的队列中。当一个自定义的队列名称被使用，动画不会自动启动;你必须调用.dequeue(“queuename”)来启动它。</p>
<p>specialEasing,<br>Type: PlainObject,<br>一组一个或多个通过相应的参数和相对简单函数定义的CSS属性 ( 1.4 新增)</p>
<p>step,<br>Type: Function( Number now, Tween tween ),<br>每个动画元素的每个动画属性将调用的函数。这个函数为修改Tween 对象提供了一个机会来改变设置中得属性值。</p>
<p>progress,<br>Type: Function( Promise animation, Number progress, Number remainingMs ),<br>每一步动画完成后调用的一个函数，无论动画属性有多少，每个动画元素都执行单独的函数。 (version added: 1.8)</p>
<p>complete,<br>Type: Function(),<br>在动画完成时执行的函数。</p>
<p>done<br>Type: Function( Promise animation, Boolean jumpedToEnd )<br>在动画完成时执行的函数。 (他的Promise对象状态已完成). (version added: 1.8)</p>
<p>fail<br>Type: Function( Promise animation, Boolean jumpedToEnd )<br>动画失败完成时执行的函数。(他的Promise对象状态未完成)。 (version added: 1.8)</p>
<p>always<br>Type: Function( Promise animation, Boolean jumpedToEnd )<br>在动画完成或未完成情况下停止时执行的函数。(他的Promise对象状态已完成或未完成)。 (version added: 1.8)</p>
<p><em>所有jQuery效果，包括.hide(),都能通过设置jQuery.fx.off = true全局的关闭，效果等同于持续时间设置为0。更多信息查看 jQuery.fx.off</em></p>
<p>2 .show()</p>
<p>注意: 如果使用!important在你的样式中，比如display: none !important，如果你希望.show()方法才能正常工作，必须使用.css(‘display’, ‘block !important’)重写样式。</p>
<p>3 .toggle()</p>
<p>3.1 .toggle( [duration ] [, complete ] )</p>
<p>3.2 .toggle( options )</p>
<p>3.3 .toggle( [duration ] [, easing ] [, complete ] )</p>
<p>3.4 .toggle(display)</p>
<p>display<br>类型: Boolean,<br>一个布尔值，使用 true 来显示元素，或者 false 隐藏它.</p>
<p>注意: 事件处理套件也有一个名为.toggle()方法(.toggle( handler(eventObject), handler(eventObject) [, handler(eventObject) ] ),在1.8被宣布过时，1.9已删除),哪一个被调用取决于传递的参数的设置。</p>
<h3 id="自定义"><a href="#自定义" class="headerlink" title="自定义"></a>自定义</h3><p>1 .animate()</p>
<p>.animate()方法允许我们在任意的数值的CSS属性上创建动画。唯一必要的属性就是一组CSS属性键值对。这组属性和用于设置.css()方法的属性键值对类似，除了属性范围做了更多限制。</p>
<p>所有用于动画的属性必须是数字的，除非另有说明；这些属性如果不是数字的将不能使用基本的jQuery功能。（例如，width, height或者left可以执行动画，但是background-color不能，除非使用jQuery.Color插件。）属性值的单位像素（px）,除非另有说明。单位em 和 %需要指定使用。</p>
<p>除了样式属性， 一些非样式的属性，如scrollTop 和 scrollLeft，以及自定义属性，也可应用于动画。</p>
<p>CSS简写属性（例如font, background, border）没有得到充分的支持。例如， 如果你想边框宽度做动画呈现，至少边框样式和边框宽度必须预先设定不为”auto” 。或者，如果你想字体大小做动画， 你可以使用fontSize的或相当于CSS的 ‘font-size’ ，而不是简单的’font’。</p>
<p>除了定义数值，每个属性能使用’show’, ‘hide’, 和 ‘toggle’。这些快捷方式允许定制隐藏和显示动画用来控制元素的显示或隐藏。为了使用jQuery内置的切换状态跟踪，’toggle’关键字必须在动画开始前给定属性值。（愚人码头注：jquery中有两个.toggle()方法，一个是显示或隐藏匹配元素。另一个是绑定两个或多个处理程序绑定到匹配的元素，用来执行在交替的点击。哪一个被调用取决于传递的参数的设置。所以这里’toggle’关键字必须在动画开始前给定属性值，以确认调用哪个’toggle’方法。）</p>
<p>动画属性也可以是一个相对值。如果提供一个以+= 或 -=开始的值，那么目标值就是以这个属性的当前值加上或者减去给定的数字来计算的。</p>
<p><em>注意: 不同于动画的简便方法，比如.slideDown() 和 .fadeIn(),.animate()方法不会影响隐藏元素的可见性部分的效果。例如，给定$(‘someElement’).hide().animate({height:’20px’}, 500)，动画将执行，但该元素将保持隐藏。</em></p>
<pre><code>$(&#39;#clickme&#39;).click(function() &#123;
  $(&#39;#book&#39;).animate(&#123;
    opacity: 0.25,
    left: &#39;+=50&#39;,
    height: &#39;toggle&#39;
  &#125;, 5000, function() &#123;
    // Animation complete.
  &#125;);
&#125;);
</code></pre>
<p>Step Function</p>
<p>第二个版本的.animate()提供了一个step选项- 每步动画执行后调用的回调函数。启用自定义动画类型或改变正在执行的动画，此功能是非常有用。它接受两个参数（now 和 fx），this是当前正在执行动画的DOM元素集合。</p>
<p>now: 每一步动画属性的数字值</p>
<p>fx: jQuery.fx 原型对象的一个引用，其中包含了多项属性，比如elem 表示前正在执行动画的元素，start和end分别为动画属性的第一个和最后一个的值，prop为进行中的动画属性。</p>
<p>需要注意的是step函数被每个动画元素的每个动画属性调用。例如，给定两个列表项，step函数会被激发四次：</p>
<pre><code>$(&#39;li&#39;).animate(&#123;
  opacity: .5,
  height: &#39;50%&#39;
&#125;,
&#123;
  step: function(now, fx) &#123;
    var data = fx.elem.id + &#39; &#39; + fx.prop + &#39;: &#39; + now;
    $(&#39;body&#39;).append(&#39;&lt;div&gt;&#39; + data + &#39;&lt;/div&gt;&#39;);
  &#125;
&#125;);
</code></pre>
<p>Per-property Easing</p>
<pre><code>$(&#39;#clickme&#39;).click(function() &#123;
  $(&#39;#book&#39;).animate(&#123;
    width: [&#39;toggle&#39;, &#39;swing&#39;],
    height: [&#39;toggle&#39;, &#39;swing&#39;],
    opacity: &#39;toggle&#39;
  &#125;, 5000, &#39;linear&#39;, function() &#123;
      $(this).after(&#39;&lt;div&gt;Animation complete.&lt;/div&gt;&#39;);
  &#125;);
&#125;);
</code></pre>
<p>在.animate()的第二个版本中，选项对象能包含specialEasing属性，该属性本身是一组CSS属性与相应的缓冲函数。例如，我们可以同时的使用linear缓冲函数来做width动画，并且用easeOutBounce缓冲函数来做height动画：</p>
<pre><code>$(&#39;#clickme&#39;).click(function() &#123;
  $(&#39;#book&#39;).animate(&#123;
    width: &#39;toggle&#39;,
    height: &#39;toggle&#39;
  &#125;, &#123;
    duration: 5000,
    specialEasing: &#123;
      width: &#39;linear&#39;,
      height: &#39;easeOutBounce&#39;
    &#125;,
    complete: function() &#123;
      $(this).after(&#39;&lt;div&gt;Animation complete.&lt;/div&gt;&#39;);
    &#125;
  &#125;);
&#125;);    
</code></pre>
<p>2 .delay()</p>
<p>.delay( duration [, queueName ] )</p>
<p>设置一个延时来推迟执行队列中后续的项。</p>
<p>queueName<br>类型: String,<br>一个作为队列名的字符串。默认是动画队列 fx。标准的效果队列。</p>
<p><em>.delay()是用来在jQuery动画效果和类似队列中是最好的。但是，由于其本身的限制，比如无法取消延时,.delay()，它不是JavaScript的原生 setTimeout函数的替代品，这可能是更适合某些使用情况。</em></p>
<p>3 .queue()</p>
<p>显示或操作匹配的元素上已经执行的函数列队。</p>
<p>3.1 .queue( [queueName ] )</p>
<p>3.2 .queue( [queueName ], newQueue )</p>
<p>3.3 .queue( [queueName ], callback( next ) )</p>
<p>显示列队的长度: $div.queue(“fx”).length</p>
<p>值得注意的是，当使用.queue()添加一个函数的时候，我们应该保证在函数最后调用了 jQuery.dequeue()，这样就能让队列中的其它函数按顺序执行。</p>
<p>从jQuery 1.4开始，向队列中追加函数时，可以向该函数中传入另一个函数，作为第一个参数。当调用函数时，会自动从函数队列中弹出下一个项目，保证队列中函数的继续进行。我们可以像下面这样使用：</p>
<pre><code>$(&quot;#test&quot;).queue(function(next) &#123;
    // Do some stuff...
    next();
&#125;);
</code></pre>
<p>4 .dequeue()</p>
<p>执行匹配元素队列的下一个函数。</p>
<p>.dequeue( [queueName ] )</p>
<p>当.dequeue()被调用的时候，列队中的下一个函数将从这个列队中被移除，然后再执行。这个执行的函数中也应当直接或间接的包含 .dequeue()语句，这样才能继续执行队列中的其它函数，所以,这个序列可以继续。</p>
<p>5 jQuery.queue()</p>
<p>6 jQuery.dequeue()</p>
<p>7 jQuery.fx.interval</p>
<p>此属性在 3.0 版本中已经标记为弃用， 并在支持requestAnimationFrame方法的浏览器中没有效果。</p>
<p>对于不支持requestAnimationFrame的浏览器，该属性可以被改变，以调整动画将运行的时间间隔。默认为13毫秒。</p>
<p>由于jQuery中，该属性是全局性的，因此在没有动画正在运行或停止所有动画时，此属性的变化才能生效。</p>
<p>8 jQuery.fx.off</p>
<p>当这个属性设置为true的时候，调用时所有动画方法将立即设置元素为他们的最终状态，而不是显示效果。有时候确实有必要这样做：</p>
<p>jQuery是被用在低资源设备。</p>
<p>动画使用户遇到可访问性问题(查看这篇文章获得更多信息 Turn Off Animation)。</p>
<p>动画可以通过设置这个属性为false重新打开</p>
<p>9 .stop()</p>
<p>9.1 .stop( [clearQueue ] [, jumpToEnd ] )</p>
<p>clearQueue (默认: false)<br>类型: Boolean，<br>一个布尔值，指示是否取消列队动画。默认 false.</p>
<p>jumpToEnd (默认: false)<br>类型: Boolean，<br>一个布尔值指示是否当前动画立即完成。默认false.</p>
<p>9.2 .stop( [queue ] [, clearQueue ] [, jumpToEnd ] )</p>
<p>当一个元素调用.stop()，当前正在运行的动画（如果有的话）立即停止。</p>
<p>如果同一元素调用多个动画方法，尚未被执行的动画被放置在元素的效果队列中。这些动画不会开始，直到第一个完成。当调用.stop()的时候，队列中的下一个动画立即开始。如果clearQueue参数提供true值,那么在队列中的动画其余被删除并永远不会运行。</p>
<p>如果提供jumpToEnd参数，并且值为true时，当前动画将停止，但该元素上的 CSS 属性会被立刻修改成动画的目标值。</p>
<p>当我们需要对元素做mouseenter和mouseleave动画时，.stop()方法明显是有效的：</p>
<p>10 .finish()</p>
<p>停止当前正在运行的动画，删除所有排队的动画，并完成匹配元素所有的动画</p>
<p>.finish( [queue ] )</p>
<p>当.finish()在一个元素上被调用，立即停止当前正在运行的动画和所有排队的动画（如果有的话），并且他们的CSS属性设置为它们的目标值（愚人码头注：就是所有动画的目标值）。所有排队的动画将被删除。</p>
<p>.finish()方法和.stop(true, true)很相似，.stop(true, true)将清除队列，并且目前的动画跳转到其最终值。但是，不同的是，.finish() 会导致所有排队的动画的CSS属性跳转到他们的最终值。</p>
<p>.stop(true, true)等于.clearQueue().finish();</p>
<h3 id="渐变"><a href="#渐变" class="headerlink" title="渐变"></a>渐变</h3><p>.fadeIn()</p>
<p>.fadeOut()</p>
<p>.fadeTo()</p>
<p>.fadeToggle()</p>
<h3 id="滑动"><a href="#滑动" class="headerlink" title="滑动"></a>滑动</h3><p>.slideDown()</p>
<p>.slideToggle()</p>
<p>.slideUp()</p>
<h2 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h2><h3 id="全局Ajax事件处理程序"><a href="#全局Ajax事件处理程序" class="headerlink" title="全局Ajax事件处理程序"></a>全局Ajax事件处理程序</h3><p>这些方法用于注册事件处理器，用来处理页面上的任何 Ajax 请求，当某些事件触发后，这些事件处理器被调用。如何 jQuery.ajaxSetup() 中的 global 属性被设置为 true （这也是默认设置），那么，每个 Ajax 请求都会触发全局事件。注意：全局事件绝对不会被跨域（cross-domain）脚本或 JSONP 请求触发，和 global 属性的设置毫无关系。</p>
<p>1 .ajaxStart()</p>
<p>在AJAX 请求刚开始时执行一个处理函数</p>
<p><em>在jQuery1.9中，jQuery全局AJAX事件的所有处理程序， 包括那些.ajaxStart()添加的方法，必须 附加到 document上。</em></p>
<p><em>如果 $.ajax() 或 $.ajaxSetup()调用时， global 选项设置为 false， .ajaxStart()将不会触发。</em></p>
<p>2 .ajaxSend()</p>
<p>在Ajax请求发送之前绑定一个要执行的函数</p>
<p>无论哪一个Ajax请求被发送，所有ajaxSend处理器都将被执行。如果我们必须区分不同的请求,我们可以使参数传递给这个处理器。 每次ajaxSend 处理器执行，它传递事件对象，jqXHR对象（在 jQuery 1.4中是XMLHttpRequest对象），和用来创建请求的设置（settings object）对象。如果请求失败，因为JavaScript抛出一个异常，并且作为第四个参数的异常对象被传递给处理程序。举个例子,我们能限制我们的回调到只处理事件处理某一特定的URL:</p>
<pre><code>$(document).ajaxSend(function(event, jqxhr, settings) &#123;
  if ( settings.url == &quot;ajax/test.html&quot; ) &#123;
    $( &quot;.log&quot; ).text( &quot;Triggered ajaxSend handler.&quot; );
  &#125;
&#125;);
</code></pre>
<p>3 .ajaxStop()</p>
<p>在AJAX 请求完成时执行一个处理函数。</p>
<p>每当一个Ajax请求完成，jQuery检查是否有任何其他响应过程中的Ajax请求（愚人码头注：未完成的请求）。如果都执行完成，jQuery就会触发ajaxStop事件，在这个时间点所有处理函数都会使用.ajaxStop()方法注册并执行。如果一个未处理完成的Ajax请求用beforeSend回调函数返回false取消，ajaxStop事件也被触发</p>
<p>4 .ajaxSuccess()</p>
<p>绑定一个函数当 Ajax 请求成功完成时执行</p>
<p>.ajaxSuccess( handler(event, XMLHttpRequest, ajaxOptions) )</p>
<p>5 .ajaxError()</p>
<p>Ajax请求出错时注册一个回调处理函数</p>
<p>.ajaxError( handler(event, jqXHR, ajaxSettings, thrownError) )</p>
<p>6 .ajaxComplete()</p>
<p>当Ajax请求完成后注册一个回调函数</p>
<p>每当一个Ajax请求完成，jQuery就会触发ajaxComplete事件，在这个时间点所有处理函数会使用.ajaxComplete()方法注册并执行。</p>
<h3 id="辅助函数"><a href="#辅助函数" class="headerlink" title="辅助函数"></a>辅助函数</h3><p>1 jQuery.param()</p>
<p>创建一个数组，一个普通的对象，或一个jQuery对象的序列化表示形式，用于URL查询字符串或Ajax请求。 如果传递一个jQuery对象传递，它应该包含输入元素（愚人码头注：input，textarea等）的名称/值属性。</p>
<p>1.1 jQuery.param( obj )</p>
<p>obj<br>类型: Array 或 PlainObject 或 jQuery，<br>一个用来序列化的一个数组，一个普通的对象，或一个jQuery对象。</p>
<p>1.2 jQuery.param( obj, traditional )</p>
<p>traditional<br>类型: Boolean，<br>一个布尔值，指示是否执行了传统的“shallow”的序列化。</p>
<p>在 jQuery 1.4中, $.param() 方法将会通过深度递归的方式序列化对象，以便符合现代化脚本语言和框架的需求，比如 PHP 和 Ruby on Rails。 你可以通过设置 jQuery.ajaxSettings.traditional = true;废除这个全局功能。</p>
<p>在jQuery 3.0中，$.param()方法，不再使用jQuery.ajaxSettings.traditional 作为其默认设置，将默认为 false。对于最好的跨版本兼容性，调用 $.param()时传递明确的值给第二个参数，不使用默认值。</p>
<p>如果传递的对象是一个数组，它必须是一个对象数组，其格式要跟.serializeArray()返回的格式一样：</p>
<pre><code>[
  &#123; name: &quot;first&quot;, value: &quot;Rick&quot; &#125;,
  &#123; name: &quot;last&quot;, value: &quot;Astley&quot; &#125;,
  &#123; name: &quot;job&quot;, value: &quot;Rock Star&quot; &#125;
]
</code></pre>
<p><em>因为一些框架解析序列化的数字的能力有限， 在传递 obj 参数时我们应该谨慎，尽量不要传递含有对象的数组，或者数组中嵌套其它数组。</em></p>
<p><em>由于目前对序列化字符串没有统一的规约，此方法无法对复杂数据结构进行编码，使之可以支持所有语言。在此之前，$.param 方法将继续保持其目前的形式。</em></p>
<p>2 .serialize()</p>
<p>将用作提交的表单元素的值编译成字符串。</p>
<p>注意: 只有 “successful controls”可以被序列化成字符串。其中，提交按钮的值不会被序列化。另外，如果想要一个表单元素的值被序列化成字符串，这个元素必须含有 name 属性。此外，复选框（checkbox）和单选按钮（radio）(input 类型为 “radio” 或 “checkbox”)的值只有在被选中时才会被序列化。另外，文件选择元素的数据也不会被序列化。</p>
<pre><code>$(&quot;form&quot;).serialize();
</code></pre>
<p>3 .serializeArray()</p>
<p>将用作提交的表单元素的值编译成拥有name和value对象组成的数组。例如[ { name: a value: 1 }, { name: b value: 2 },…]</p>
<p>.serializeArray()方法使用标准的W3C”successful controls”的标准来检测哪些元素应当包括在内。被禁用的元素不会被包括在内。并且,元素必须含有 name 属性。此外，提交按钮的值也不会被序列化。文件选择元素的数据也不会被序列化。</p>
<h3 id="底层接口"><a href="#底层接口" class="headerlink" title="底层接口"></a>底层接口</h3><p>1 jQuery.ajax()</p>
<p>jQuery最复杂的一个API，因为参数实在是太多了。</p>
<p>1.1 jQuery.ajax( url [, settings ] )</p>
<p>1.2 jQuery.ajax( [settings ] )</p>
<p>settings</p>
<p>类型: PlainObject</p>
<p>一个以”{键:值}”组成的AJAX 请求设置。所有选项都是可选的。可以使用$.ajaxSetup()设置任何默认参数。</p>
<p>1）accepts (默认: 取决于数据类型)</p>
<p>类型: PlainObject</p>
<p>一个键/值对集合映射给定的dataType 到其的MIME类型，它可以从发送Accept请求头信息中获得。 </p>
<p>请求头信息通知服务器该请求需要接收何种类型的返回结果。 例如，下面定义一个自定义类型的mycustomtype与请求一起发送：</p>
<pre><code>$.ajax(&#123;
  accepts: &#123;
    mycustomtype: &#39;application/x-some-custom-type&#39;
  &#125;,
 
  // Instructions for how to deserialize a `mycustomtype`
  converters: &#123;
    &#39;text mycustomtype&#39;: function(result) &#123;
      // Do Stuff
      return newresult;
    &#125;
  &#125;,
 
  // Expect a `mycustomtype` back from server
  dataType: &#39;mycustomtype&#39;
&#125;);
</code></pre>
<p>注意: 对于这种类型，为了使其正常工作，您将需要在converters中指定补充项。</p>
<p>2）async (默认: true)</p>
<p>跨域请求和 dataType: “jsonp” 请求不支持同步操作。</p>
<p>3）beforeSend</p>
<p>类型: Function( jqXHR jqXHR, PlainObject settings )<br>请求发送前的回调函数，用来修改请求发送前jqXHR（在jQuery 1.4.x的中，XMLHttpRequest）对象，此功能用来设置自定义 HTTP 头信息，等等。在beforeSend函数中返回false将取消这个请求</p>
<p>4）cache (默认: true, dataType为”script”和”jsonp”时默认为false)</p>
<p>如果设置为 false ，浏览器将不缓存此页面。注意: 设置cache为 false将在 HEAD和GET请求中正常工作。它的工作原理是在GET请求参数中附加”_={timestamp}”（译者注：时间戳）。该参数不是其他请求所必须的，除了在IE8中，当一个POST请求一个已经用GET请求过的URL。</p>
<p>5）complete</p>
<p>6）contents</p>
<p>类型: PlainObject，<br>一个以”{字符串/正则表达式}”配对的对象，根据给定的内容类型，解析请求的返回结果。 (1.5新增)</p>
<p>7）contentType (default: ‘application/x-www-form-urlencoded; charset=UTF-8’)</p>
<p>从 jQuery 1.6 开始，你可以传递false来告诉jQuery，没有设置任何内容类型头信息。 注意：W3C的XMLHttpRequest的规范规定，数据将总是使用UTF-8字符集传递给服务器；指定其他字符集无法强制浏览器更改编码。 注意:对于跨域请求，内容类型设置为application/x-www-form-urlencoded, multipart/form-data, 或 text/plain以外， 将触发浏览器发送一个预检OPTIONS请求到服务器。</p>
<p>8）context</p>
<p>类型: Object</p>
<p>这个对象用于设置Ajax相关回调函数的上下文。 默认情况下，这个上下文是一个ajax请求使用的参数设置对象。比如指定一个DOM元素作为context参数，这样就设置了complete回调函数的上下文为这个DOM元素。</p>
<pre><code>$.ajax(&#123;
  url: &quot;test.html&quot;,
  context: document.body
&#125;).done(function() &#123;
  $(this).addClass(&quot;done&quot;);
&#125;);
</code></pre>
<p>9)converters (默认: {“* text”: window.String, “text html”: true, “text json”: jQuery.parseJSON, “text xml”: jQuery.parseXML})</p>
<p>类型: PlainObject</p>
<p>一个数据类型到数据类型转换器的对象。每个转换器的值是一个函数，返回经转换后的请求结果</p>
<p>10)crossDomain (默认: 同域请求为false， 跨域请求为true</p>
<p>如果你想在同一域中强制跨域请求（如JSONP形式），例如，想服务器端重定向到另一个域，那么需要将crossDomain设置为 true 。</p>
<p>11)data</p>
<p>类型: PlainObject 或 String 或 Array</p>
<p>发送到服务器的数据。它被转换成一个查询字符串,如果已经是一个字符串的话就不会转换。查询字符串将被追加到GET请求的URL后面。参见 processData 选项说明，以防止这种自动转换。对象必须为”{键:值}”格式。如果这个参数是一个数组，jQuery会按照traditional 参数的值， 将自动转化为一个同名的多值查询字符串(查看下面的说明)。愚人码头注：如 {foo:[“bar1”, “bar2”]} 转换为 ‘&amp;foo=bar1&amp;foo=bar2’。</p>
<p>12)dataFilter</p>
<p>类型: Function( String data, String type ) =&gt; Anything</p>
<p>一个函数被用来处理XMLHttpRequest的原始响应数据。这是一个预过滤功能，净化响应。您应该返回安全数据。提供data和type两个参数：data是Ajax返回的原始数据，type是调用jQuery.ajax时提供的dataType参数。</p>
<p>13)dataType (default: Intelligent Guess (xml, json, script, or html))</p>
<p>从服务器返回你期望的数据类型。 如果没有指定，jQuery将尝试通过MIME类型的响应信息来智能判断（一个XML MIME类型就被识别为XML，在1.4中 JSON将生成一个JavaScript对象，在1.4中 script 将执行该脚本，其他任何类型会返回一个字符串）。</p>
<p>可用的类型（以及结果作为第一个参数传递给成功回调函数）有：</p>
<ul>
<li><p>xml 返回 XML 文档</p>
</li>
<li><p>html 返回纯文本 HTML 文本；包含的script标签会在插入DOM时执行。</p>
</li>
<li><p>script 把响应的结果当作 JavaScript 执行，并将其当作纯文本返回。默认情况下会通过在URL中附加查询字符串变量 _=[TIMESTAMP]， 禁用缓存结果，除非设置了cache参数为true。注意: 在远程请求时(不在同一个域下)，所有POST请求都将转为GET请求。(愚人码头注：因为将使用DOM的script标签来加载)</p>
</li>
<li><p>json 把响应的结果当作 JSON 执行，并返回一个JavaScript对象。跨域”json” 请求转换为”jsonp”，除非该请求在其请求选项中设置了jsonp:false。JSON 数据以严格的方式解析; 任何畸形的JSON将被拒绝，并且抛出解析错误信息。在jQuery1.9中，一个空响应也将被拒绝;服务器应该返回null或 {}响应代替。（见<a target="_blank" rel="noopener" href="http://json.org/">json.org</a>的更多信息，正确的JSON格式。）</p>
</li>
<li><p>jsonp 以 JSONP 的方式载入 JSON 数据块。会自动在所请求的URL最后添加”?callback=?”。默认情况下会通过在URL中附加查询字符串变量 _=[TIMESTAMP]， 禁用缓存结果，除非设置了cache参数为true。</p>
</li>
<li><p>text 返回纯文本字符串</p>
</li>
</ul>
<p>多个用空格分割的值:从 jQuery 1.5 开始， jQuery可以内容类型（Content-Type）头收到并转换一个您需要的数据类型。例如，如果你想要一个文本响应为XML处理，使用”text xml”数据类型。您也可以将一个JSONP的请求，以文本形式接受，并用jQuery以XML解析: “jsonp text xml”。同样地可以使用”jsonp xml”简写,首先会尝试从 jsonp 到 xml 的转换，如果转换失败，就先将 jsonp 转换成 text, 然后再由 text 转换成 xml。</p>
<p>14)error</p>
<p>类型: Function( jqXHR jqXHR, String textStatus, String errorThrown )</p>
<p>如果发生了错误，错误信息（第二个参数）除了得到null之外，还可能是”timeout”, “error”, “abort” ，和 “parsererror”。 当一个HTTP错误发生时，errorThrown 接收HTTP状态的文本部分，比如： “Not Found”（没有找到） 或者 “Internal Server Error.”（服务器内部错误）。 从jQuery 1.5开始, 在error设置可以接受函数组成的数组。每个函数将被依次调用。 注意：此处理程序在跨域脚本和JSONP形式的请求时不被调用。</p>
<p>15)global (默认: true)</p>
<p>16)headers (默认: {})</p>
<p>一个额外的”{键:值}”对映射到请求一起发送。此设置会在beforeSend 函数调用之前被设置 ;因此，请求头中的设置值，会被beforeSend 函数内的设置覆盖 。 </p>
<p>17)ifModified (默认: false)</p>
<p>只有上次请求响应改变时，才允许请求成功。使用 HTTP 包 Last-Modified 头信息判断。默认值是false，忽略HTTP头信息。</p>
<p>18)isLocal (默认: 取决于当前的位置协议)</p>
<p>允许当前环境被认定为“本地”，（如文件系统），即使jQuery默认情况下不会这么做。以下协议目前公认为本地：file, *-extension, and widget。如果isLocal设置需要修改，建议在$.ajaxSetup()方法中这样做一次。 </p>
<p>19)jsonp</p>
<p>在一个JSONP请求中重写回调函数的名字。这个值用来替代在”callback=?”这种GET或POST请求中URL参数里的”callback”部分，比如{jsonp:’onJsonPLoad’}会导致将”onJsonPLoad=?”传给服务器。在jQuery 1.5，，设置jsonp选项为false，阻止了jQuery从加入”?callback”字符串的URL或试图使用”=?”转换。在这种情况下，你也应该明确设置jsonpCallback设置。例如, { jsonp: false, jsonpCallback: “callbackName” }。如果你不信任你的Ajax请求的目标，出于安全原因， 考虑 设置jsonp 属性为false。</p>
<p>20)jsonpCallback</p>
<p>类型: String, Function</p>
<p>为jsonp请求指定一个回调函数名。这个值将用来取代jQuery自动生成的随机函数名。这主要用来让jQuery生成一个独特的函数名，这样管理请求更容易，也能方便地提供回调函数和错误处理。你也可以在想让浏览器缓存GET请求的时候，指定这个回调函数名。从jQuery 1.5开始，你也可以使用一个函数作为该参数设置，在这种情况下，该函数的返回值就是jsonpCallback的结果。</p>
<p>21)method (default: ‘GET’)</p>
<p>HTTP 请求方法 (比如：”POST”, “GET “, “PUT”)。 (添加版本: 1.9.0)。（愚人码头注：如果你使用jQuery 1.9.0 之前的版本，你需要使用type选项。）</p>
<p>22)mimeType</p>
<p>一个mime类型用来覆盖XHR的 MIME类型。</p>
<p>23)password</p>
<p>用于响应HTTP访问认证请求的密码</p>
<p>24)processData (默认: true)</p>
<p>默认情况下，通过data选项传递进来的数据，如果是一个对象(技术上讲只要不是字符串)，都会处理转化成一个查询字符串，以配合默认内容类型 “application/x-www-form-urlencoded”。如果要发送 DOM 树信息或其它不希望转换的信息，请设置为 false。</p>
<p>25)scriptCharset</p>
<p>仅适用于当”script”传输使用时（例如，跨域的”jsonp”或 dataType选项为”script” 和 “GET”类型）。请求中使用在script标签上设置charset 属性。通常只在本地和远程的内容编码不同时使用。</p>
<p>26)statusCode (默认: {})</p>
<p>一个 HTTP响应状态码 和 当请求响应相应的状态码时执行的函数 组成的对象。例如： 下面的代码将在http响应状态码为404时弹出“page not found”。</p>
<pre><code>$.ajax(&#123;
  statusCode: &#123;
    404: function() &#123;
      alert(&quot;page not found&quot;);
    &#125;
  &#125;
&#125;);
</code></pre>
<p>如果请求成功，响应状态代码对应的函数会带着success回调函数相同的参数；如果请求结果是错误的（包含3xx之类的重定向），他们会采用error回调函数相同的参数。</p>
<p>27)success</p>
<p>28)timeout</p>
<p>设置请求超时时间（毫秒）。此设置将覆盖$.ajaxSetup() 里的全局设置。</p>
<p>29)traditional</p>
<p>如果你想要用传统的方式来序列化数据，那么就设置为true。请参考工具分类下面的jQuery.param 方法.</p>
<p>30)type (默认: ‘GET’)</p>
<p>method选项的别名。如果你使用jQuery 1.9.0 之前的版本，你需要使用type选项</p>
<p>31)url (默认: 当前页面地址)</p>
<p>32)username</p>
<p>响应HTTP访问认证请求的用户名</p>
<p>33)xhr (默认: 当可用的ActiveXObject（IE）中，否则为XMLHttpRequest)</p>
<p>类型: Function()</p>
<p>回调创建XMLHttpRequest对象。当可用时默认为ActiveXObject（IE）中，否则为XMLHttpRequest。提供覆盖你自己的执行的XMLHttpRequest或增强工厂。</p>
<p>34)xhrFields</p>
<p>类型: PlainObject</p>
<p>一对“文件名-文件值”组成的映射，用于设定原生的 XHR对象。例如，如果需要的话，在进行跨域请求时，你可以用它来设置withCredentials为true。</p>
<pre><code>$.ajax(&#123;
   url: a_cross_domain_url,
   xhrFields: &#123;
      withCredentials: true
   &#125;
&#125;); 
</code></pre>
<h4 id="ajax"><a href="#ajax" class="headerlink" title=".ajax()"></a>.ajax()</h4><p>jQuery 发送的所有 Ajax 请求，内部都会通过调用 $.ajax() 函数来实现。通常没有必要直接调用这个函数，可以使用几个已经封装的简便方法，如$.get()和.load()。如果你需要用到那些不常见的选项，那么， $.ajax()使用起来更灵活。</p>
<p>注意: 所有的选项都可以通过$.ajaxSetup() 函数来全局设置</p>
<h4 id="jqXHR-对象"><a href="#jqXHR-对象" class="headerlink" title="jqXHR 对象"></a>jqXHR 对象</h4><p>从jQuery 1.5开始，$.ajax() 返回XMLHttpRequest（jqXHR）对象，该对象是浏览器的原生的XMLHttpRequest对象的一个超集。例如，它包含responseText和responseXML属性，以及一个getResponseHeader()方法。当传输机制不是是XMLHttpRequest时（例如，一个JSONP请求脚本，返回一个脚本 tag 时），jqXHR对象尽可能的模拟原生的XHR功能。</p>
<p>从jQuery 1.5.1开始， jqXHR对象还包含了overrideMimeType方法 (它在jQuery 1.4.x中是有效的，但是在jQuery 1.5中暂时的被移除)。.overrideMimeType() 方法可能用在beforeSend()的回调函数中，例如，修改响应的Content-Type信息头：</p>
<p>从 jQuery 1.5 开始，$.ajax()返回的jqXHR对象 实现了 Promise 接口, 使它拥有了 Promise 的所有属性，方法和行为</p>
<p>jqXHR.done(function(data, textStatus, jqXHR) {});</p>
<p>jqXHR.fail(function(jqXHR, textStatus, errorThrown) {});</p>
<p>jqXHR.always(function(data|jqXHR, textStatus, jqXHR|errorThrown) { });</p>
<p>jqXHR.then(function(data, textStatus, jqXHR) {}, function(jqXHR, textStatus, errorThrown) {});</p>
<p>推荐使用的注意事项: jqXHR.success(), jqXHR.error(), 和 jqXHR.complete()回调从 jQuery 1.8开始 被弃用过时。他们将最终被取消，您的代码应做好准备， 从jQuery 3.0开始被删除，你可以使用jqXHR.done(), jqXHR.fail(), 和 jqXHR.always() 代替。</p>
<p>this在所有的回调中的引用，是这个对象在传递给$.ajax的设置中上下文；如果没有指定context（上下文），this 引用的是Ajax设置的本身。</p>
<p>为了向后兼容XMLHttpRequest ，jqXHR对象将公开下列属性和方法：</p>
<p>readyState</p>
<p>status</p>
<p>statusText</p>
<p>responseXML and/or responseText 当底层的请求分别作出XML和/或文本响应</p>
<p>setRequestHeader(name, value) 从标准出发，通过替换旧的值为新的值，而不是替换的新值到旧值</p>
<p>getAllResponseHeaders()</p>
<p>getResponseHeader()</p>
<p>abort()</p>
<p>这里有$.ajax()提供的回调钩子 （hooks），如下：</p>
<ul>
<li><p>beforeSend 在发送请求之前调用，它接收jqXHR对象和settings作为参数对象。</p>
</li>
<li><p>error 在请求出错时调用。如果请求失败，在它们的顺序依次登记。他们接受jqXHR ，字符串表示的错误类型，以及异常对象（如果有的话）。一些内置的错误会将 “abort”, “timeout”, “No Transport” 等字符串作为异常对象。</p>
</li>
<li><p>dataFilter 在请求成功之后调用。传入返回的数据以及dataType参数的值。并且必须返回新的数据（可能是处理过的）传递给success回调函数。</p>
</li>
<li><p>success 当请求成功并接收到返回数据之后调用。传入返回后的数据，以及包含成功代码的字符串和jqXHR对象。</p>
</li>
<li><p>Promise callbacks — .done(), .fail(), .always(), and .then() — 根据他们注册的顺序被调用。</p>
</li>
<li><p>complete 请求完成时，无论是在失败或成功，它们按顺序依次执行回调。他们收到jqXHR对象，以及一个包含成功或错误代码。</p>
</li>
</ul>
<h4 id="Data-Types（数据类型）"><a href="#Data-Types（数据类型）" class="headerlink" title="Data Types（数据类型）"></a>Data Types（数据类型）</h4><p>$.ajax()调用不同类型的响应，被传递到成功处理函数之前，会经过不同种类的预处理。 预处理的类型取决于由更加接近默认的Content-Type响应，但可以明确使用dataType选项进行设置。如果提供了dataType选项， 响应的Content-Type头信息将被忽略。</p>
<p>有效的数据类型是text， html， xml， json，jsonp，和 script.</p>
<p>如果指定的是text 或 html， 则不会预处理。 这些数据被简单地传递给成功处理函数， 并通过该jqXHR对象的responseText属性获得的。</p>
<p>如果指定的是xml， 响应结果作为XMLDocument，在传递给成功处理函数之前使用jQuery.parseXML进行解析。 XML文档是可以通过该jqXHR对象的responseXML属性获得的。</p>
<p>如果指定的是json，响应结果作为一个对象，在传递给成功处理函数之前使用jQuery.parseJSON进行解析。 解析后的JSON对象可以通过该jqXHR对象的responseJSON属性获得的。</p>
<p>如果指定的是script ，$.ajax() 执行这段 JavaScript，这段 JavaScript 从服务器接收到，在传递给成功处理函数之前是一个字符串。</p>
<p>如果指定的是jsonp ，$.ajax()会自动在请求的URL后面增加一个查询字符串参数 callback=?（默认） 。传递给$.ajax() 设置中的jsonp 和 jsonpCallback属性可以被用来指定， 分别为 查询字符串参数的名称和JSONP回调函数的名称。服务器应返回有效的JavaScript，传递JSON响应到回调函数（愚人码头注：例如，flightHandler({“code”: “CA1998”,”price”: 1780,”tickets”: 5});等）。 在包含JSON对象的相应结果传递给成功处理函数之前，$.ajax() 将执行返回的JavaScript， 调用JSONP回调函数。</p>
<h4 id="Sending-Data-to-the-Server（发送数据到服务器）"><a href="#Sending-Data-to-the-Server（发送数据到服务器）" class="headerlink" title="Sending Data to the Server（发送数据到服务器）"></a>Sending Data to the Server（发送数据到服务器）</h4><p>data选项既可以包含一个查询字符串，比如 key1=value1&amp;key2=value2，也可以是一个映射，比如 {key1: ‘value1’, key2: ‘value2’} 。如果使用了后者的形式，则数据再发送前会用jQuery.param() 将其转换成查询字符串。这个处理过程也可以通过设置processData选项为false来回避。如果我们希望发送一个XML对象给服务器时，这种处理可能并不合适。并且在这种情况下，我们也应当改变contentType 选项的值，用其他合适的MIME类型来取代默认的 application/x-www-form-urlencoded 。</p>
<h4 id="Advanced-Options（高级选项）"><a href="#Advanced-Options（高级选项）" class="headerlink" title="Advanced Options（高级选项）"></a>Advanced Options（高级选项）</h4><p>global选项用于阻止响应注册的回调函数，比如.ajaxSend(), .ajaxError()，以及类似的方法。这在有些时候很有用，比如发送的请求非常频繁且简短的时候，就可以在.ajaxSend()里禁用这个。跨域脚本和JSONP请求，全局选项自动设置为false。更多关于这些方法的详细信息，请参阅下面的内容。</p>
<p>如果服务器需要HTTP认证，可以使用用户名和密码可以通过 username 和 password 选项来设置。</p>
<p>默认情况下，请求总会被发出去，但浏览器有可能从他的缓存中调取数据。要禁止使用缓存的结果，可以设置cache参数为false。如果希望判断数据自从上次请求后没有更改过就报告出错的话，可以设置ifModified为true。</p>
<p>$.ajax()函数返回他创建的XMLHttpRequest对象。通常jQuery只在内部处理并创建这个对象，但用户也可以通过xhr 选项来传递一个自己创建的xhr对象。返回的对象通常已经被丢弃了，但依然提供一个底层接口来观察和操控请求。比如说，调用对象上的.abort() 可以在请求完成前挂起请求。</p>
<p>目前, 在Firefox中有一个bug，虽然.getResponseHeader(‘Content-Type’)返回一个非空的字符串，但是 .getAllResponseHeaders()还是返回空字符串， 在Firefox中使用jQuery不支持自动解码JSON CORS 响应。</p>
<h4 id="Using-Converters（使用转换器）"><a href="#Using-Converters（使用转换器）" class="headerlink" title="Using Converters（使用转换器）"></a>Using Converters（使用转换器）</h4><p>$.ajax()的转换器支持的数据类型映射到其它数据类型。但是，如果你想把自定义数据类型映射到一个已知的类型（json等）,您必须contents 选项在响应的Content-Type和实际的数据类型之间的添加一个相关的转换函数：</p>
<pre><code>$.ajaxSetup(&#123;
  contents: &#123;
    mycustomtype: /mycustomtype/
  &#125;,
  converters: &#123;
    &quot;mycustomtype json&quot;: function ( result ) &#123;
      // do stuff
      return newresult;
    &#125;
  &#125;
&#125;);
</code></pre>
<p>这额外的对象是必要的，因为响应内容类型(Content-Types)和数据类型从来没有一个严格的一对一对应关系（正则表达式表示结果）。</p>
<p>转换一个支持的类型（例如text, json）成自定义数据类型，然后再返回，使用另一个直通转换器：</p>
<pre><code>$.ajaxSetup(&#123;
  contents: &#123;
    mycustomtype: /mycustomtype/
  &#125;,
  converters: &#123;
    &quot;text mycustomtype&quot;: true,
    &quot;mycustomtype json&quot;: function ( result ) &#123;
      // do stuff
      return newresult;
    &#125;
  &#125;
&#125;);
</code></pre>
<p>现在上面的代码允许通过从text 为mycustomtype ，进而，mycustomtype 转换为 json。</p>
<p><em>由于浏览器的安全限制，大多数“Ajax”的要求，均采用同一起源的政策 ;该请求不能成功地检索来自不同的域，子域或协议的数据。<br>Script和JSONP形式请求不受同源策略的限制</em></p>
<p>2 jQuery.ajaxSetup()</p>
<p>为以后要用到的Ajax请求设置默认的值</p>
<p>用于设置$.ajaxSetup()的详细参数, 参见 $.ajax().</p>
<p>所有后面的 Ajax 调用任何函数都将使用新的设置参数,除非它们调用时设置了各自的参数重载了这个默认值。 直到下一次调用$.ajaxSetup().</p>
<p>注意： 此处指定的设置会影响所有 $.ajax或基于AJAX的衍生方法，如$.get()的调用。这可能会导致不良的行为因为其他调用（例如，插件）可能希望正常的默认设置。出于这个原因，我们强烈建议您不要使用此API。相反我们建议，在调用时明确设置选项或定义一个简单的插件。</p>
<p>注意: 全局回调函数应使用他们各自的全局Ajax事件处理方法-.ajaxStart(), .ajaxStop(), .ajaxComplete(), .ajaxError(), .ajaxSuccess(), .ajaxSend()-设置，而不是为 $.ajaxSetup() 设置 options 对象。</p>
<h3 id="快捷方法"><a href="#快捷方法" class="headerlink" title="快捷方法"></a>快捷方法</h3><p>1 jQuery.get()</p>
<p>jQuery.get( url [, data ] [, success ] [, dataType ] )</p>
<p>2 jQuery.getJSON()</p>
<p>jQuery.getJSON( url [, data ] [, success(data, textStatus, jqXHR) ] )</p>
<pre><code>$.getJSON(&#39;ajax/test.json&#39;, function(data) &#123;
  var items = [];
 
  $.each(data, function(key, val) &#123;
    items.push(&#39;&lt;li id=&quot;&#39; + key + &#39;&quot;&gt;&#39; + val + &#39;&lt;/li&gt;&#39;);
  &#125;);
 
  $(&#39;&lt;ul/&gt;&#39;, &#123;
    &#39;class&#39;: &#39;my-new-list&#39;,
    html: items.join(&#39;&#39;)
  &#125;).appendTo(&#39;body&#39;);
&#125;);
</code></pre>
<p>3 jQuery.getScript()</p>
<p>使用一个HTTP GET请求从服务器加载并执行一个 JavaScript 文件</p>
<p>定义了一个$.cachedScript（）方法可以获取缓存的脚本：</p>
<pre><code>jQuery.cachedScript = function(url, options) &#123;
 
  // allow user to set any option except for dataType, cache, and url
  options = $.extend(options || &#123;&#125;, &#123;
    dataType: &quot;script&quot;,
    cache: true,
    url: url
  &#125;);
 
  // Use $.ajax() since it is more flexible than $.getScript
  // Return the jqXHR object so we can chain callbacks
  return jQuery.ajax(options);
&#125;;
 
// Usage
$.cachedScript(&quot;ajax/test.js&quot;).done(function(script, textStatus) &#123;
  console.log( textStatus );
&#125;);
</code></pre>
<p>4 .load()</p>
<p>.load( url [, data ] [, complete(responseText, textStatus, XMLHttpRequest) ] )</p>
<p>默认使用 GET 方式 ， 如果data参数提供一个对象，那么使用 POST 方式。</p>
<h4 id="Loading-Page-Fragments（加载页面片段）"><a href="#Loading-Page-Fragments（加载页面片段）" class="headerlink" title="Loading Page Fragments（加载页面片段）"></a>Loading Page Fragments（加载页面片段）</h4><p>如果 url 参数的字符串中包含一个或多个空格，那么第一个空格后面的内容，会被当成是 jQuery 的选择器，从而决定应该加载返回结果中的哪部分内容。</p>
<pre><code>$(&#39;#result&#39;).load(&#39;ajax/test.html #container&#39;);
</code></pre>
<p>5 jQuery.post()</p>
<p>用 POST 获取的页面是从来不会被缓存, 所以这些请求中的 cache 和 ifModified 选项在 jQuery.ajaxSetup() 是无效的。</p>
<h2 id="jQuery核心"><a href="#jQuery核心" class="headerlink" title="jQuery核心"></a>jQuery核心</h2><p>1 jQuery()</p>
<p>1.1 jQuery( selector [, context ] )</p>
<p>jQuery( selector [, context ] )</p>
<p>jQuery( element )</p>
<p>jQuery( elementArray )</p>
<p>jQuery( object )</p>
<p>jQuery( jQuery object )</p>
<p>jQuery()</p>
<p>1）Cloning jQuery Objects(克隆jQuery对象)</p>
<p>当一个jQuery对象作为一个参数传递给$()方法时，这个对象的一个克隆对象将被创建。这个新的jQuery对象引用同一DOM元素。</p>
<p>2）Returning an Empty Set(返回一个空集合)</p>
<p>在jQuery 1.4中，如果你传递给jQuery()方法一个空参数，一个空的jQuery设置将被返回（.length属性为0）。 在以前的jQuery版本中，一个包含整个文档节点的集合将被返回。</p>
<p>3）Working With Plain Objects（使用普通的对象）</p>
<p>目前，只支持包裹在jQuery中的普通的JavaScript对象是：.data(),.prop(),.bind(), .unbind(), .trigger() 和 .triggerHandler()。使用.data()（或者任何返回.data()的方法），在一个普通的对象会产生一个新的属性的名为jQuery{randomNumber}（如jQuery123456789）。</p>
<pre><code>// define a plain object
var foo = &#123;foo: &quot;bar&quot;, hello: &quot;world&quot;&#125;;
 
// Pass it to the jQuery function
var $foo = $( foo );
 
// test accessing property values
var test1 = $foo.prop( &quot;foo&quot; ); // bar
 
// test setting property values
$foo.prop( &quot;foo&quot;, &quot;foobar&quot; );
var test2 = $foo.prop( &quot;foo&quot; ); // foobar
 
// test using .data() as summarized above
$foo.data( &quot;keyName&quot;, &quot;someValue&quot;);
console.log( $foo ); // will now contain a jQuery&#123;randomNumber&#125; property
 
// test binding an event name and triggering
$foo.bind( &quot;eventName&quot;, function () &#123;
  console.log(&quot;eventName was called&quot;);
&#125;);
 
$foo.trigger( &quot;eventName&quot; ); // logs &quot;eventName was called&quot;
</code></pre>
<p>1.2 jQuery( html [, ownerDocument ] )</p>
<p>jQuery( html [, ownerDocument ] )</p>
<p>jQuery( html, attributes )</p>
<p>从jQuery 1.4开始，给jQuery() 的第二个参数可以接受一个简单的对象组成的一个属性集合，可以传递.attr()方法。</p>
<p>重要提示： 如果第二个参数被传递，第一个参数中的HTML字符串 必须代表一个没有任何属性简单的元素。 从 jQuery 1.4开始，一些event type（事件类型）可以传递进来， 而且能够调用以下jQuery方法： val, css, html, text, data, width, height, or offset。</p>
<p>从 jQuery 1.8开始, 任何jQuery实例方法（一个jQuery.fn的方法），可以被用来作为一个该对象的属性传递给第二个参数：</p>
<pre><code>$( &quot;&lt;div&gt;&lt;/div&gt;&quot;, &#123;
  &quot;class&quot;: &quot;my-div&quot;,
  on: &#123;
    touchstart: function( event ) &#123;
      // do something
    &#125;
  &#125;
&#125;).appendTo( &quot;body&quot; );
</code></pre>
<p>在这个对象中，”class”（类）的名称必须使用引号括起来，因为它是一个JavaScript保留字，还有不能使用”className”，因为它是指的DOM属性（property），不是属性（attribute）。</p>
<p>虽然第二个参数是方便，它的灵活性可能会导致意想不到的后果（例如$(“<input>“, {size: “4”})调用.size()方法，代替设置size属性）。上面的代码块可以被写入，代替为：</p>
<pre><code>$( &quot;&lt;div&gt;&lt;/div&gt;&quot; )
.addClass( &quot;my-div&quot; )
.on(&#123;
  touchstart: function( event ) &#123;
    // do something
  &#125;
&#125;).appendTo( &quot;body&quot; );
</code></pre>
<p>1.3 jQuery( callback )</p>
<p>2 jQuery.noConflict()</p>
<p>jQuery.noConflict( [removeAll ] )</p>
<p>removeAll<br>类型: Boolean，<br>一个布尔值，判断是否从全局作用域中内去除所有jQuery变量(包括jQuery本身)。</p>
<h2 id="jQuery杂项"><a href="#jQuery杂项" class="headerlink" title="jQuery杂项"></a>jQuery杂项</h2><h3 id="DOM-元素方法"><a href="#DOM-元素方法" class="headerlink" title="DOM 元素方法"></a>DOM 元素方法</h3><p>1 .get()</p>
<p>1.1 .get( index )</p>
<p>1.2 .get()</p>
<p>调用这个方法将会返回所有匹配的DOM节点，这些节点包含在一个标准的数组中</p>
<p>选择文档中的所有div，并且作为一个数组返回。然后使用浏览器原生的 reverse 方法将数组翻转。</p>
<pre><code>function disp(divs) &#123;
    var a = [];
    for ( var i = 0; i &lt; divs.length; i++) &#123;
      a.push( divs[i].innerHTML );
    &#125;
    $( &quot;span&quot; ).text( a.join(&quot; &quot;) );
&#125;

disp( $( &quot;div&quot; ).get().reverse() );
</code></pre>
<p>2 .toArray()</p>
<p>和.get()方法效果相同</p>
<p>3 .index()</p>
<p>3.1 .index()</p>
<p>3.2 .index( selector )</p>
<p>3.3 .index( element )</p>
<p>如果不传递任何参数给 .index() 方法，则返回值就是jQuery对象中第一个元素相对于它同辈元素的位置。</p>
<p>如果在一组元素上调用 .index() ，并且参数是一个DOM元素或jQuery对象， .index() 返回值就是传入的元素相对于原先集合的位置。</p>
<p>如果参数是一个选择器， .index() 返回值就是原先元素相对于选择器匹配元素的位置。如果找不到匹配的元素，则 .index() 返回 -1.</p>
<h3 id="内部构件"><a href="#内部构件" class="headerlink" title="内部构件"></a>内部构件</h3><p>1 .jquery</p>
<p>.jquery原型指向jQuery的原型， 通常被称为它的别名$.fn。它是一个字符串，其中包含的jQuery的版本号，如“1.5.0”或“1.4.4”。</p>
<p>2 jQuery.error()</p>
<p>jQuery.error( message )</p>
<p>接受一个字符串，并抛出包含这个字符串的异常。</p>
<p>这个方法主要是为了让插件开发人员可以重载此方法，并以更好的方式显示错误消息，或者提供更多相关信息。</p>
<p>3 .length</p>
<p>4 .pushStack()</p>
<p>将一个DOM元素集合加入到jQuery栈。</p>
<p><a target="_blank" rel="noopener" href="http://www.cnblogs.com/AndyWithPassion/archive/2012/02/06/jquery_pushStack_javascript.html">更多参考</a></p>
<h2 id="实用工具"><a href="#实用工具" class="headerlink" title="实用工具"></a>实用工具</h2><p>1 jQuery.contains()</p>
<p>jQuery.contains( container, contained )</p>
<p>检查一个DOM元素是另一个DOM元素的后代。</p>
<p>如果第二个参数所提供的DOM元素是第一个参数DOM元素的后裔，那么$.contains() 方法返回true，无论是直接的子元素或者是后代元素。否则，返回false。只支持 element 节点;如果第二个参数是一个文本或注释节点，$.contains()将返回 false。</p>
<p><em>注意: 第一个参数必须是一个DOM元素，不是一个jQuery对象或普通的JavaScript对象。</em></p>
<p>2 jQuery.each()</p>
<p>注意: $.each()函数会在内部检索并且使用传递集合的 length属性。 所以，如果集合有一个名为length的属性 - 比如 {bar: ‘foo’, length: 10} - 这个函数可能无法正常工作。</p>
<p>我们可以在$.each()返回false来终止迭代。返回非false相当于一个循环中的continue语句，这意味着，它会立即跳出当前的迭代，转到下一个迭代。</p>
<p><em>jQuery中的each方法和ES5、underscore、Angular都不同，它的回调函数第一个参数为index/key，第二个为value，其他刚好相反</em></p>
<p>3 jQuery.extend()</p>
<p>jQuery.extend( [deep ], target, object1 [, objectN ] )</p>
<p>如果只有一个参数提供给$.extend()，这意味着目标参数被省略。在这种情况下，jQuery对象本身被默认为目标对象。这样，我们可以在jQuery的命名空间下添加新的功能。这对于插件开发者希望向 jQuery 中添加新函数时是很有用的。</p>
<p>请记住，目标对象（第一个参数）将被修改，并且将通过$.extend()返回。然而，如果我们想保留原对象，我们可以通过传递一个空对象作为目标对象：</p>
<pre><code>var object = $.extend(&#123;&#125;, object1, object2);
</code></pre>
<p>在默认情况下，通过$.extend()合并操作不是递归的;如果第一个对象的属性本身是一个对象或数组，那么它将完全用第二个对象相同的key重写一个属性。这些值不会被合并。可以通过检查下面例子中 banana 的值，就可以了解这一点。然而，如果将 true 作为该函数的第一个参数，那么会在对象上进行递归的合并。</p>
<p>警告:不支持第一个参数传递 false 。</p>
<p>未定义的属性不会被复制。然而，从对象原型的继承属性将被复制。如果属性（Properties）是一个通过构造函数new MyCustomObject(args)定义的，或JavaScript中内置类型，如Date 或 RegExp，是不会重新创建的，并且将被当作普通的对象出在返回的对象或数组中。</p>
<p>若设置了 deep 参数，对象和数组也会被合并进来，但是对象包裹的原始类型，比如String, Boolean, 和 Number是不会被合并进来的。</p>
<p>4 jQuery.fn.extend()</p>
<p>一个对象的内容合并到jQuery的原型，以提供新的jQuery实例方法。</p>
<p>jQuery.fn.extend()方法继承了jQuery原型($.fn)对象，以提供jQuery原型新的方法，可以链式调用jQuery()函数。</p>
<pre><code>jQuery.fn.extend(&#123;
  check: function() &#123;
    return this.each(function() &#123; this.checked = true; &#125;);
  &#125;,
  uncheck: function() &#123;
    return this.each(function() &#123; this.checked = false; &#125;);
  &#125;
&#125;);
 
// Use the newly created .check() method
$( &quot;input[type=&#39;checkbox&#39;]&quot; ).check();
</code></pre>
<p>5 jQuery.globalEval()</p>
<p>在全局上下文下执行一些JavaScript代码</p>
<p>此方法的表现不同于正常使用的JavaScript eval()，因为它是在全局上下文下执行（这对加载外部动态脚本很重要）。</p>
<pre><code>function test()&#123;
    jQuery.globalEval(&quot;var newVar = true;&quot;)
&#125;
test();
// newVar === true
</code></pre>
<p>6 jQuery.grep()</p>
<p>jQuery.grep( array, function(elementOfArray, indexInArray) [, invert ] )</p>
<p>查找满足过滤函数的数组元素。原始数组不受影响。类似underscore的filter</p>
<p>7 jQuery.inArray()</p>
<p>jQuery.inArray( value, array [, fromIndex ] )</p>
<p>8 jQuery.isArray()</p>
<p>9 jQuery.isEmptyObject()</p>
<p>从 jQuery 1.4 开始，这个方法既检测对象本身的属性，也检测从原型继承的属性（因此没有使用hasOwnProperty）。参数应当是一个普通的JavaScript对象， 对于其他类型的对象（DOM元素，原始strings/numbers，host对象）在跨浏览器中可能无法提供一致的结果。 要确定一个对象是否是一个普通的JavaScript对象，使用$.isPlainObject()</p>
<p>10 jQuery.isFunction()</p>
<p>11 jQuery.isNumeric()</p>
<p>$.isNumeric()方法检查它的参数是否能代表一个数值。如果是这样，则返回true。否则返回false。该参数可以是任何类型。（愚人码头注：jQuery 3.0之前，这个方法会强制转换参数为Number，转换后的值类型如果是如果是Number，也会返回true）</p>
<p>在jQuery 3.0中，$.isNumeric()方法只有接收number类型的参数时候，或者是可以被强制为有限数值的 string类型的参数，才会返回true，在其他情况下，返回false。</p>
<p>12 jQuery.isPlainObject()</p>
<p>注意: Host对象（或浏览器宿主环境中所使用的对象，用来完成的ECMAScript执行环境）在检测跨平台时存在很多的不一致，难以提供跨平台的强劲的检测函数。在某些情况下，$.isPlainObject()的结果可能在不同的浏览器评估不一致</p>
<p>13 jQuery.isWindow()</p>
<p>这个方法在jQuery很多地方用到，用来确定我们的操作是否为一个浏览器窗口操作。（如当前窗口或一个iframe）。</p>
<p>14 jQuery.isXMLDoc()</p>
<p>检查一个DOM节点是否在XML文档中（或者是一个XML文档）。</p>
<p>15 jQuery.makeArray()</p>
<p>转换一个类似数组的对象成为真正的JavaScript数组。</p>
<p>16 jQuery.map()</p>
<p>17 jQuery.merge()</p>
<p>合并两个数组内容到第一个数组。</p>
<p>18 jQuery.noop()</p>
<p>当你仅仅想要传递一个空函数的时候，就用他吧。</p>
<p>这对一些插件作者很有用，当插件提供了一个可选的回调函数接口，那么如果调用的时候没有传递这个回调函数，就用jQuery.noop来代替执行。</p>
<p>19 jQuery.now()</p>
<p>20 jQuery.parseHTML()</p>
<p>jQuery.parseHTML( data [, context ] [, keepScripts ] )</p>
<p>大多数的jQuery的API接受的HTML字符串将运行所包含在HTML中的脚本。jQuery.parseHTML不运行HTML中解析出来的脚本，除非 keepScripts参数为true。然而，它仍然是可能在大多数环境中间接地执行脚本，例如通过<img onerror>属性。调用者应该意识到这一点，并通过清理或避免任何不可信来源的输入，如URL或cookies，来防止它。为了未来的兼容性，当keepScripts为不确定的或false时，调用者不应该依赖于这个能力来运行任何脚本内容。</p>
<p>21 jQuery.parseJSON()</p>
<p>在jQuery 1.9之前,如果传递给$.parseJSON一个空字符串，null, 或者 undefined,，将返回null，而不是抛出一个错误，即使这些都不是有效的JSON。</p>
<p>jQuery 3.0开始，$.parseJSON已经过时（愚人码头注：不建议使用）。要将字符串解析成JSON对象，请使用原生的JSON.parse方法来代替</p>
<p>22 jQuery.parseXML()</p>
<p>23 jQuery.proxy()</p>
<p>24 jQuery.readyException()</p>
<p>jQuery.readyException( error )</p>
<p>处理包裹在jQuery()中函数同步抛出的错误。</p>
<p>25 jQuery.trim()</p>
<p>26 jQuery.type()</p>
<p>确定JavaScript 对象的类型[[Class]] 。</p>
<p>27 jQuery.unique()</p>
<p>在jQuery 3.0中，这种方法已被弃用，只是jQuery.uniqueSort()的别名。请使用该方法代替。</p>
<p>$.unique()函数通过搜索的数组对象，排序数组，并移除任何重复的节点。 如果一个节点和已经在数组中的节点完全相同，那么它被认为是重复的;  两个不同的节点具有相同的属性是被认为不重复的。 此功能只适用于普通的JavaScript DOM元素的数组，主要是jQuery内部使用。你可能永远都不需要使用它。</p>
<h2 id="延迟对象（deferred对象）"><a href="#延迟对象（deferred对象）" class="headerlink" title="延迟对象（deferred对象）"></a>延迟对象（deferred对象）</h2><p>deferred对象就是jQuery的回调函数解决方案。</p>
<p>1 $.deferred()方法</p>
<p>作用是生成一个deferred对象。</p>
<p>2 deferred.done()</p>
<p>当Deferred（延迟）对象解决时，调用添加处理程序。</p>
<p>deferred.done( doneCallbacks [, doneCallbacks ] )</p>
<p>当Deferred（延迟）解决时，doneCallbacks被调用。回调是依照他们添加的顺序执行。</p>
<p>3 deferred.fail()</p>
<p>当Deferred（延迟）对象拒绝时，调用添加的处理程序。</p>
<p>4 deferred.progress()</p>
<p>当Deferred（延迟）对象生成正在执行中的进度通知时，调用添加处理程序。</p>
<p>5 deferred.always()</p>
<p>当Deferred（延迟）对象解决或拒绝时，调用添加处理程序。</p>
<p>6 deferred.then()</p>
<p>deferred.then( doneFilter [, failFilter ] [, progressFilter ] )</p>
<p>有时为了省事，可以把done()和fail()合在一起写，这就是then()方法。</p>
<p>7 deferred.promise()</p>
<p>返回Deferred(延迟)的Promise（承诺）对象。</p>
<p>deferred.promise( [target ] )</p>
<p>大多数情况下，我们不想让用户从外部更改deferred对象的状态。这时，你可以在deferred对象的基础上，返回一个针对它的promise对象。我们可以把后者理解成，promise是deferred的只读版，或者更通俗地理解成promise是一个对将要完成的任务的承诺。promise对象只开放与改变执行状态无关的方法（比如done()方法和fail()方法），屏蔽与改变执行状态有关的方法（比如resolve()方法和reject()方法），从而使得执行状态不能被改变</p>
<p>你可以通过promise对象，为原始的deferred对象添加回调函数，查询它的状态，但是无法改变它的状态，也就是说promise对象不允许你调用resolve和reject方法。</p>
<p>jQuery的ajax() 方法返回的就是一个promise对象。此外，Animation类操作也可以使用promise对象。</p>
<p>8 deferred.state()</p>
<p>deferred.state() 方法返回一个字符串，代表Deferred（延迟）对象的当前状态。Deferred对象可以在三种状态之一：</p>
<ul>
<li><p>“pending”: Deferred对象是尚未完成状态 (不是 “rejected” 或 “resolved”).</p>
</li>
<li><p>“resolved”: Deferred对象是在解决状态，这意味着，deferred.resolve() 或者 deferred.resolveWith()被对象访问和doneCallbacks被访问（或在被调用的过程中） 。</p>
</li>
<li><p>“rejected”: Deferred对象是在被拒绝的状态，这意味着，deferred.reject() 或者 deferred.rejectWith() 被对象访问和failCallbacks被访问（或在被调用的过程中） 。</p>
</li>
</ul>
<p>这种方法主要是有用的调试，例如，在准备拒绝（reject）一个延迟对象前，判断它是否已经处于 resolved 状态。</p>
<p>9 deferred.notify()</p>
<p>deferred.notify( args )</p>
<p>根据给定的 args参数 调用Deferred（延迟）对象上进行中的回调 （progressCallbacks）。</p>
<p>通常情况下，只有递延对象（Deferred）的创建者才能调用此方法; 您可以通过deferred.promise()返回的受限制的 Promise 对象，来防止其他代码改变递延的状态 。</p>
<p>当 deferred.notify 被访问时， 任何progressCallbacks 可以通过访问deferred.then 好或者 deferred.progress来添加。回调是依照他们添加的顺序执行的。</p>
<p>10 deferred.notifyWith( context [, args ] )</p>
<p>Context（上下文） 作为this对象传递给进行中的回调（progressCallbacks ）</p>
<p>11 deferred.reject()</p>
<p>拒绝Deferred（延迟）对象，并根据给定的args参数调用任何失败回调函数（failCallbacks）。</p>
<p>12 deferred.rejectWith()</p>
<p>13 deferred.resolve()</p>
<p>解决Deferred（延迟）对象，并根据给定的args参数调用任何完成回调函数（doneCallbacks）。</p>
<p>14 deferred.resolveWith()</p>
<p>15 .promise()</p>
<p>.promise( [type ] [, target ] )</p>
<p>type (默认: fx),<br>类型: String,<br>需要待观察队列类型。 </p>
<p>target<br>类型: PlainObject,<br>将要绑定 promise 方法的对象。</p>
<p>注意: 返回的 Promise 被链接到延迟对象上，保存在元素的 .data() 中。由于 .remove() 方法会移除元素上的 data，同时也会移除元素本身。所以，使用它会防止任何元素上未被受理的（unresolved） Promise 被受理（resolving）。如果有必要在元素的 Promise 被受理（resolved）之前，从 DOM 中移除该元素的话，请使用 .detach() 来代替。之后再调用 .removeData()</p>
<p>当所有的动画结果时(包括那些在动画回调函数和之后添加的回调函数中初始化的动画），受理（Resolve）返回的 Promise：</p>
<pre><code>&lt;script&gt;
$(&quot;button&quot;).bind( &quot;click&quot;, function() &#123;
  $(&quot;p&quot;).append( &quot;Started...&quot;);
 
  $(&quot;div&quot;).each(function( i ) &#123;
    $( this ).fadeIn().fadeOut( 1000 * (i+1) );
  &#125;);
 
  $( &quot;div&quot; ).promise().done(function() &#123;
    $( &quot;p&quot; ).append( &quot; Finished! &quot; );
  &#125;);
&#125;);
&lt;/script&gt;
</code></pre>
<p>16 deferred.catch()</p>
<p>当Deferred对象被拒绝(reject)时，调用添加的处理程序。</p>
<p>deferred.catch( failFilter )</p>
<p>failFilter<br>Type: Function(),<br>一个函数，当 Deferred 对象被拒绝(reject)时被调用</p>
<p>jQuery3.0添加</p>
<p>deferred.catch( fn ) 是 deferred.then( null, fn )的一个别名</p>
<h2 id="回调对象"><a href="#回调对象" class="headerlink" title="回调对象"></a>回调对象</h2><p>jQuery.Callbacks()</p>
<p>jQuery.Callbacks( flags )</p>
<p>flags<br>类型: String，<br>一个用空格标记分隔的标志可选列表,用来改变回调列表中的行为。</p>
<p>$.Callbacks用来管理函数队列。采用了观察者模式，通过add添加操作到队列当中，通过fire去执行这些操作。实际上$.Callbacks是1.7版本从$.Deferred对象当中分离出来的，主要是实现$.Deferred功能。</p>
<p>$.Callbacks()的内部提供了jQuery的$.ajax() 和 $.Deferred() 基本功能组件。它可以用来作为类似基础定义的新组件的功能。</p>
<p>$.Callbacks() 支持的方法，包括 callbacks.add(),callbacks.remove(), callbacks.fire() 和 callbacks.disable().</p>
<h3 id="支持的-Flags"><a href="#支持的-Flags" class="headerlink" title="支持的 Flags"></a>支持的 Flags</h3><p>这个 flags 参数是$.Callbacks()的一个可选参数, 结构为一个用空格标记分隔的标志可选列表,用来改变回调列表中的行为 (比如. $.Callbacks( ‘unique stopOnFalse’ )).</p>
<p>可用的 flags:</p>
<ul>
<li><p>once: 函数队列只执行一次</p>
</li>
<li><p>memory: 当函数队列fire或fireWith一次过后，内部会记录当前fire或fireWith的参数。当下次调用add的时候，会把记录的参数传递给新添加的函数并立即执行这个新添加的函数</p>
</li>
<li><p>unique: 往内部队列添加的函数保持唯一，不能重复添加。</p>
</li>
<li><p>stopOnFalse: 内部队列里的函数是依次执行的，当某个函数的返回值是false时，停止继续执行剩下的函数。</p>
</li>
</ul>
<p>默认情况下，回调列表将像事件的回调列表中可以多次触发。</p>
<p>这四种基本类型可以相互组合起来使用，例如$.Deferred就使用了once和memory的组合。</p>
<h3 id="Callbacks-支持的方法"><a href="#Callbacks-支持的方法" class="headerlink" title="$.Callbacks() 支持的方法"></a>$.Callbacks() 支持的方法</h3><p>1 add()</p>
<p>向内部队列添加函数，总有三种参数形式:</p>
<ul>
<li><p>单个函数参数</p>
</li>
<li><p>多个函数参数</p>
</li>
<li><p>数组参数</p>
</li>
</ul>
<p>2 fire()</p>
<p>依次执行队列里的函数</p>
<p>3 fire的参数会传递给我们添加的函数</p>
<p>4 fireWith</p>
<p>fire调用的时候，我们添加函数当中的this指向我们的Callbacks实例</p>
<p>fireWith就是改变我们添加函数的context，即this指向</p>
<p>fireWith第一个参数是我们的context，第二个参数是我们需要传递的内容数组，注意了是数组！</p>
<p>5 empty</p>
<p>清空函数队列</p>
<p>6 has</p>
<p>判断函数队列中是否存在某个函数</p>
<p>7 remove</p>
<p>从内部队列中移除某些函数</p>
<p>8 disable</p>
<p>禁用回调列表中的回调</p>
<p>9 disabled</p>
<p>回调管理是否被禁用</p>
<p>10 lock</p>
<p>锁定回调列表的当前状态。</p>
<p>disable和lock的区别</p>
<p>两者唯一的区别就是添加了memory参数，看一下对比</p>
<pre><code>var cb = $.Callbacks(&#39;memory&#39;);

cb.add(function () &#123;
    console.log(&#39;one&#39;);
&#125;);
cb.fire();
cb.disable();
//cb.lock();
cb.add(function () &#123;
    console.log(&#39;two&#39;);
&#125;);
</code></pre>
<p>毫无疑问，disable就是禁用所有功能，无论添加什么参数。而在memory的情况下，fire过后再lock，继续add新的函数依旧会立即执行。</p>
<p>11 locked</p>
<p>回调管理是否被锁</p>
<p>12 fired</p>
<p>回调队列是否执行过</p>
<h3 id="Callbacks-Deferred-and-Pub-Sub"><a href="#Callbacks-Deferred-and-Pub-Sub" class="headerlink" title="$.Callbacks, $.Deferred and Pub/Sub"></a>$.Callbacks, $.Deferred and Pub/Sub</h3><p>pub / sub（观察者模式）背后的一般思路 是促进应用程序的松散耦合。而比对其他对象的方法调用的单个对象，一个对象，而不是另一个对象的一个特定的任务或活动，并通知当它发生。观察家也被称为订阅者，它指向观察对象。观察者（Publisher）事件发生时通知用户</p>
<p>作为 $.Callbacks() 的创建组件的一个演示，只使用回调函数列表，就可以实现 Pub/Sub 系统。</p>
<pre><code>var topics = &#123;&#125;;
 
jQuery.Topic = function( id ) &#123;
    var callbacks,
        method,
        topic = id &amp;&amp; topics[ id ];
 
    if ( !topic ) &#123;
        callbacks = jQuery.Callbacks();
        topic = &#123;
            publish: callbacks.fire,
            subscribe: callbacks.add,
            unsubscribe: callbacks.remove
        &#125;;
        if ( id ) &#123;
            topics[ id ] = topic;
        &#125;
    &#125;
    return topic;
&#125;;
</code></pre>
<p>然后，可以很容易的使用这部分应用程序的发布和订阅感兴趣的事件：</p>
<pre><code>// Subscribers
$.Topic( &quot;mailArrived&quot; ).subscribe( fn1 );
$.Topic( &quot;mailArrived&quot; ).subscribe( fn2 );
$.Topic( &quot;mailSent&quot; ).subscribe( fn1 );
 
// Publisher
$.Topic( &quot;mailArrived&quot; ).publish( &quot;hello world!&quot; );
$.Topic( &quot;mailSent&quot; ).publish( &quot;woo! mail!&quot; );
 
// Here, &quot;hello world!&quot; gets pushed to fn1 and fn2
// when the &quot;mailArrived&quot; notification is published
// with &quot;woo! mail!&quot; also being pushed to fn1 when
// the &quot;mailSent&quot; notification is published.
 
/*
output:
hello world!
fn2 says: hello world!
woo! mail!
*/
</code></pre>
<p>尽管上面的代码很有用，但是可以进一步改进其实现。使用 $.Deferreds，可以保证当特定的任务被完成（或被解决）时，发布者只能向订阅者发布通知。参见下面的示例代码，进一步讨论如何在实践中使用这种情况：</p>
<pre><code>// subscribe to the mailArrived notification
$.Topic( &quot;mailArrived&quot; ).subscribe( fn1 );
 
// create a new instance of Deferreds
var dfd = $.Deferred();
 
// define a new topic (without directly publishing)
var topic = $.Topic( &quot;mailArrived&quot; );
 
// when the deferred has been resolved, publish a
// notification to subscribers
dfd.done( topic.publish );
 
// Here the Deferred is being resolved with a message
// that will be passed back to subscribers. It&#39;s possible to
// easily integrate this into a more complex routine
// (eg. waiting on an ajax call to complete) so that
// messages are only published once the task has actually
// finished.
dfd.resolve( &quot;it&#39;s been published!&quot; );
</code></pre>
<h3 id="use-JQuery-Callbacks"><a href="#use-JQuery-Callbacks" class="headerlink" title="use JQuery.Callbacks"></a>use JQuery.Callbacks</h3><p><a target="_blank" rel="noopener" href="http://stackoverflow.com/questions/8070894/when-would-i-use-jquery-callbacks">When would I use JQuery.Callbacks?</a></p>
  
	</div>
		<footer class="article-footer clearfix">

  <div class="article-tags">
  
  <span></span> <a href="/tags/计算机/">计算机</a><a href="/tags/前端/">前端</a><a href="/tags/javascript/">javascript</a><a href="/tags/jQuery/">jQuery</a><a href="/tags/积累/">积累</a>
  </div>


<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</a>
</div>



<div class="article-share" id="share">

  <div data-url="http://example.com/2021/10/06/jquery/" data-title="jQuery API学习总结 | 欢迎来到曾安的博客" data-tsina="" class="share clearfix">
  </div>

</div>
</footer>   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/2021/10/06/jquery插件开发/" title="jQuery插件开发入门">
  <strong>PREVIOUS:</strong><br/>
  <span>
  jQuery插件开发入门</span>
</a>
</div>


<div class="next">
<a href="/2021/10/06/javaScript篇03--promise/"  title="javaScript篇03--promise">
 <strong>NEXT:</strong><br/> 
 <span>javaScript篇03--promise
</span>
</a>
</div>

</nav>

	
</div>  
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">文章目录</strong>
  <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E5%99%A8"><span class="toc-number">1.</span> <span class="toc-text">选择器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%AD%9B%E9%80%89"><span class="toc-number">1.1.</span> <span class="toc-text">基本筛选</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AE%B9%E7%AD%9B%E9%80%89"><span class="toc-number">1.2.</span> <span class="toc-text">内容筛选</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E8%A7%81%E6%80%A7%E7%AD%9B%E9%80%89"><span class="toc-number">1.3.</span> <span class="toc-text">可见性筛选</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A8%E5%8D%95"><span class="toc-number">1.4.</span> <span class="toc-text">表单</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7-CSS%E7%9B%B8%E5%85%B3"><span class="toc-number">2.</span> <span class="toc-text">属性&#x2F;CSS相关</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7"><span class="toc-number">2.1.</span> <span class="toc-text">属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CSS"><span class="toc-number">2.2.</span> <span class="toc-text">CSS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%BA%E5%AF%B8"><span class="toc-number">2.3.</span> <span class="toc-text">尺寸</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%8D%E7%BD%AE"><span class="toc-number">2.4.</span> <span class="toc-text">位置</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AEdata"><span class="toc-number">3.</span> <span class="toc-text">数据data</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DOM%E6%93%8D%E4%BD%9C"><span class="toc-number">4.</span> <span class="toc-text">DOM操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%B7%E8%B4%9D"><span class="toc-number">4.1.</span> <span class="toc-text">拷贝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DOM-%E6%8F%92%E5%85%A5-%E5%8C%85%E8%A3%B9"><span class="toc-number">4.2.</span> <span class="toc-text">DOM 插入, 包裹</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DOM-%E6%8F%92%E5%85%A5-%E5%86%85%E9%83%A8%E6%8F%92%E5%85%A5"><span class="toc-number">4.3.</span> <span class="toc-text">DOM 插入, 内部插入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DOM-%E6%8F%92%E5%85%A5-%E5%A4%96%E9%83%A8%E6%8F%92%E5%85%A5"><span class="toc-number">4.4.</span> <span class="toc-text">DOM 插入, 外部插入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DOM-%E7%A7%BB%E9%99%A4"><span class="toc-number">4.5.</span> <span class="toc-text">DOM 移除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DOM-%E6%9B%BF%E6%8D%A2"><span class="toc-number">4.6.</span> <span class="toc-text">DOM 替换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%81%8D%E5%8E%86"><span class="toc-number">5.</span> <span class="toc-text">遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AD%9B%E9%80%89"><span class="toc-number">5.1.</span> <span class="toc-text">筛选</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%84%E7%A7%8D%E9%81%8D%E5%8E%86"><span class="toc-number">5.2.</span> <span class="toc-text">各种遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E9%81%8D%E5%8E%86"><span class="toc-number">5.3.</span> <span class="toc-text">树遍历</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6"><span class="toc-number">6.</span> <span class="toc-text">事件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BA%8B%E4%BB%B6"><span class="toc-number">6.1.</span> <span class="toc-text">浏览器事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E6%A1%A3%E5%8A%A0%E8%BD%BD"><span class="toc-number">6.2.</span> <span class="toc-text">文档加载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A"><span class="toc-number">6.3.</span> <span class="toc-text">事件绑定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A8%E5%8D%95%E4%BA%8B%E4%BB%B6"><span class="toc-number">6.4.</span> <span class="toc-text">表单事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%AE%E7%9B%98%E4%BA%8B%E4%BB%B6"><span class="toc-number">6.5.</span> <span class="toc-text">键盘事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%BC%A0%E6%A0%87%E4%BA%8B%E4%BB%B6"><span class="toc-number">6.6.</span> <span class="toc-text">鼠标事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1"><span class="toc-number">6.7.</span> <span class="toc-text">事件对象</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%88%E6%9E%9C"><span class="toc-number">7.</span> <span class="toc-text">效果</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80"><span class="toc-number">7.1.</span> <span class="toc-text">基础</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89"><span class="toc-number">7.2.</span> <span class="toc-text">自定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B8%90%E5%8F%98"><span class="toc-number">7.3.</span> <span class="toc-text">渐变</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BB%91%E5%8A%A8"><span class="toc-number">7.4.</span> <span class="toc-text">滑动</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Ajax"><span class="toc-number">8.</span> <span class="toc-text">Ajax</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E5%B1%80Ajax%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F"><span class="toc-number">8.1.</span> <span class="toc-text">全局Ajax事件处理程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%85%E5%8A%A9%E5%87%BD%E6%95%B0"><span class="toc-number">8.2.</span> <span class="toc-text">辅助函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%95%E5%B1%82%E6%8E%A5%E5%8F%A3"><span class="toc-number">8.3.</span> <span class="toc-text">底层接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ajax"><span class="toc-number">8.3.1.</span> <span class="toc-text">.ajax()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#jqXHR-%E5%AF%B9%E8%B1%A1"><span class="toc-number">8.3.2.</span> <span class="toc-text">jqXHR 对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Data-Types%EF%BC%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%89"><span class="toc-number">8.3.3.</span> <span class="toc-text">Data Types（数据类型）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Sending-Data-to-the-Server%EF%BC%88%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%89"><span class="toc-number">8.3.4.</span> <span class="toc-text">Sending Data to the Server（发送数据到服务器）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Advanced-Options%EF%BC%88%E9%AB%98%E7%BA%A7%E9%80%89%E9%A1%B9%EF%BC%89"><span class="toc-number">8.3.5.</span> <span class="toc-text">Advanced Options（高级选项）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Using-Converters%EF%BC%88%E4%BD%BF%E7%94%A8%E8%BD%AC%E6%8D%A2%E5%99%A8%EF%BC%89"><span class="toc-number">8.3.6.</span> <span class="toc-text">Using Converters（使用转换器）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E6%8D%B7%E6%96%B9%E6%B3%95"><span class="toc-number">8.4.</span> <span class="toc-text">快捷方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Loading-Page-Fragments%EF%BC%88%E5%8A%A0%E8%BD%BD%E9%A1%B5%E9%9D%A2%E7%89%87%E6%AE%B5%EF%BC%89"><span class="toc-number">8.4.1.</span> <span class="toc-text">Loading Page Fragments（加载页面片段）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#jQuery%E6%A0%B8%E5%BF%83"><span class="toc-number">9.</span> <span class="toc-text">jQuery核心</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#jQuery%E6%9D%82%E9%A1%B9"><span class="toc-number">10.</span> <span class="toc-text">jQuery杂项</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#DOM-%E5%85%83%E7%B4%A0%E6%96%B9%E6%B3%95"><span class="toc-number">10.1.</span> <span class="toc-text">DOM 元素方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E6%9E%84%E4%BB%B6"><span class="toc-number">10.2.</span> <span class="toc-text">内部构件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7"><span class="toc-number">11.</span> <span class="toc-text">实用工具</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BB%B6%E8%BF%9F%E5%AF%B9%E8%B1%A1%EF%BC%88deferred%E5%AF%B9%E8%B1%A1%EF%BC%89"><span class="toc-number">12.</span> <span class="toc-text">延迟对象（deferred对象）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E8%B0%83%E5%AF%B9%E8%B1%A1"><span class="toc-number">13.</span> <span class="toc-text">回调对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%AF%E6%8C%81%E7%9A%84-Flags"><span class="toc-number">13.1.</span> <span class="toc-text">支持的 Flags</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Callbacks-%E6%94%AF%E6%8C%81%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">13.2.</span> <span class="toc-text">$.Callbacks() 支持的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Callbacks-Deferred-and-Pub-Sub"><span class="toc-number">13.3.</span> <span class="toc-text">$.Callbacks, $.Deferred and Pub&#x2F;Sub</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#use-JQuery-Callbacks"><span class="toc-number">13.4.</span> <span class="toc-text">use JQuery.Callbacks</span></a></li></ol></li></ol>
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  
<div class="categorieslist">
	<p class="asidetitle">分类</p>
		<ul>
		
			<li><a href="/categories/前端/" title="前端">前端<sup>3</sup></a></li>
		
			<li><a href="/categories/生活琐事/" title="生活琐事">生活琐事<sup>1</sup></a></li>
		
			<li><a href="/categories/计算机/" title="计算机">计算机<sup>20</sup></a></li>
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
		
			<li><a href="/tags/CSS/" title="CSS">CSS<sup>1</sup></a></li>
		
			<li><a href="/tags/ES6/" title="ES6">ES6<sup>3</sup></a></li>
		
			<li><a href="/tags/HTML5/" title="HTML5">HTML5<sup>1</sup></a></li>
		
			<li><a href="/tags/SASS/" title="SASS">SASS<sup>1</sup></a></li>
		
			<li><a href="/tags/css/" title="css">css<sup>6</sup></a></li>
		
			<li><a href="/tags/css3/" title="css3">css3<sup>1</sup></a></li>
		
			<li><a href="/tags/fiddler/" title="fiddler">fiddler<sup>1</sup></a></li>
		
			<li><a href="/tags/git/" title="git">git<sup>1</sup></a></li>
		
			<li><a href="/tags/jQuery/" title="jQuery">jQuery<sup>2</sup></a></li>
		
			<li><a href="/tags/javascript/" title="javascript">javascript<sup>11</sup></a></li>
		
			<li><a href="/tags/webpack/" title="webpack">webpack<sup>1</sup></a></li>
		
			<li><a href="/tags/webstorm/" title="webstorm">webstorm<sup>1</sup></a></li>
		
			<li><a href="/tags/前端/" title="前端">前端<sup>22</sup></a></li>
		
			<li><a href="/tags/生活/" title="生活">生活<sup>1</sup></a></li>
		
			<li><a href="/tags/积累/" title="积累">积累<sup>5</sup></a></li>
		
			<li><a href="/tags/翻译/" title="翻译">翻译<sup>1</sup></a></li>
		
			<li><a href="/tags/计算机/" title="计算机">计算机<sup>20</sup></a></li>
		
			<li><a href="/tags/计算机基础/" title="计算机基础">计算机基础<sup>1</sup></a></li>
		
			<li><a href="/tags/调试/" title="调试">调试<sup>1</sup></a></li>
		
		</ul>
</div>


  <div class="rsspart">
	<a href="" target="_blank" title="rss">RSS 订阅</a>
</div>

</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<div class="social-font clearfix">
		
		
		
		
		
	</div>
		<p class="copyright">Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/A-limon/pacman" target="_blank" title="Pacman">Pacman</a> © 2021 
		
		<a href="http://example.com" target="_blank" title="angus-Zeng">angus-Zeng</a>
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.1.0.min.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else
    {
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      h  = $('article h2')
      ah = $('article h2'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  if(ah.length==0){
    t.css('display','none');
  }else{
    c.click(function(){
      ta.css('display', 'block').addClass('fadeIn');
    });
    o.click(function(){
      ta.css('display', 'none');
    });
    $(window).scroll(function(){
      ta.css("top",Math.max(140,320-$(this).scrollTop()));
    });
  };
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina');
  var html = [
  '<a href="#" class="overlay" id="qrcode"></a>',
  '<div class="qrcode clearfix"><span>扫描二维码分享到微信朋友圈</span><a class="qrclose" href="#share"></a><strong>Loading...Please wait</strong><img id="qrcode-pic" data-src="http://s.jiathis.com/qrcode.php?url=' + encodedUrl + '"/></div>',
  '<a href="#textlogo" class="article-back-to-top" title="Top"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="QRcode"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="Weibo"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);
  $('.article-share-qrcode').click(function(){
    var imgSrc = $('#qrcode-pic').attr('data-src');
    $('#qrcode-pic').attr('src', imgSrc);
    $('#qrcode-pic').load(function(){
        $('.qrcode strong').text(' ');
    });
  });
});     
</script>






  </body>
</html>
