<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="jQuery API学习总结, 秋山的技术博客">
    <meta name="description" content="行之于途而应于心">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>jQuery API学习总结 | 秋山的博客</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="秋山的博客" type="application/atom+xml">
</head>




<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">秋山的博客</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">秋山的博客</div>
        <div class="logo-desc">
            
            行之于途而应于心
            
        </div>
    </div>

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/SilenceZeng" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/SilenceZeng" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/18.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">jQuery API学习总结</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        padding-bottom: 30px;
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/%E5%89%8D%E7%AB%AF/">
                                <span class="chip bg-color">前端</span>
                            </a>
                        
                            <a href="/tags/%E7%A7%AF%E7%B4%AF/">
                                <span class="chip bg-color">积累</span>
                            </a>
                        
                            <a href="/tags/javascript/">
                                <span class="chip bg-color">javascript</span>
                            </a>
                        
                            <a href="/tags/jQuery/">
                                <span class="chip bg-color">jQuery</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/%E5%89%8D%E7%AB%AF/" class="post-category">
                                前端
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2016-12-11
                </div>
                

                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    36k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    140 分
                </div>
                

                
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="/libs/prism/prism.css">
        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <p>jQuery，在工作中很常用，但是很多 API 或者使用这些 API 的注意事项也经常会忘记，因此写个博客总结一下，这样也能复习一下 jQuery API。主要参考了<a target="_blank" rel="noopener" href="http://www.css88.com/jqapi-1.9/">jQuery 中文文档</a>,适用于 jQuery1.9~3.1 版本。</p>
<p>jQuery API 主要分为选择器、属性/CSS 相关（属性、CSS、尺寸、位置）、数据 data、DOM 操作、遍历和筛选、事件、效果、Ajax、jQuery 核心、实用工具、延迟对象、回调对象和其他一些杂项。</p>
<h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><p>基本选择、层级选择、属性选择、子元素筛选这些和 CSS 基本一致。jQuery 还支持这些选择器：</p>
<h3 id="基本筛选"><a href="#基本筛选" class="headerlink" title="基本筛选"></a>基本筛选</h3><p>:animated</p>
<p><em>注意事项 1: 如果您使用一个自定义的 jQuery 绑定一个没有效果模块，:animated 选择器会抛出一个错误；</em></p>
<p><em>注意事项 2: 因为:animated 是一个 jQuery 延伸出来的选择器，并不是的 CSS 规范的一部分，使用:animated 查询不能充分利用原生 DOM 提供的 querySelectorAll() 方法来提高性能。为了当使用:animated 的时候在现代浏览器上获得更佳的性能，首先使用纯 CSS 选择器选择元素，然后使用.filter(“:animated”)，其他非 CSS 规范选择器同理。</em></p>
<p>:eq(index)</p>
<p>要匹配元素的索引值，从 0 开始计数（由于 JavaScript 数组使用基于 0 的索引，而:nth-child(n)是基于 1 的索引的，以符合 CSS 规范），支持负值</p>
<p>:even</p>
<p>这是基于 0 的索引，所以:even 选择器是选择第一个元素，第三个元素，依此类推在匹配</p>
<p>:first</p>
<p>:first 伪类选择器相当于:eq(0)。它也可以写为:lt(1)。虽然:first 只匹配一个单独的元素，但是:first-child 选择器可以匹配多个：即为每个父级元素匹配第一个子元素。</p>
<p>:gt()</p>
<p>:header</p>
<p>选择所有标题元素</p>
<p>:lang()</p>
<p>选择指定语言的所有元素。</p>
<p>:last</p>
<p>:lt()</p>
<p>:not()</p>
<p>.not()方法可以让代码更易读。而使用 :not() 通常会构建出一个非常复杂的选择器。所以大多数情况下，推荐使用 .not()方法。</p>
<p>:odd</p>
<p>:root</p>
<p>在 HTML 中，文档的根元素，和$(“:root”)选择的元素一样，永远是&lt;html&gt;元素</p>
<p>:target</p>
<p>如果文档的 URI 包含一个格式化的标识符，或 hash（哈希），然后:target 选择器将匹配 ID 和标识符相匹配的元素。例如，给定的 URI <a target="_blank" rel="noopener" href="http://example.com/#foo%EF%BC%8C">http://example.com/#foo，</a> $( “p:target” )，将选择&lt;p id=”foo”&gt;元素。</p>
<h3 id="内容筛选"><a href="#内容筛选" class="headerlink" title="内容筛选"></a>内容筛选</h3><p>:contains()</p>
<p>选择所有包含指定文本的元素。</p>
<p>:empty</p>
<p>选择所有没有子元素的元素（包括文本节点）。</p>
<p><em>注意：W3C 的建议 p 元素都至少有一个子节点，即使这个子节点是文字（见 <a target="_blank" rel="noopener" href="http://www.w3.org/TR/html401/struct/text.html%EF%BC%83edef-P%EF%BC%89%E3%80%82%E5%8F%A6%E4%B8%80%E6%96%B9%E9%9D%A2%EF%BC%8C%E5%85%B6%E4%BB%96%E4%B8%80%E4%BA%9B%E5%85%83%E7%B4%A0%E5%A7%8B%E7%BB%88%E6%98%AF%E7%A9%BA%E7%9A%84%EF%BC%88%E5%8D%B3%E6%B2%A1%E6%9C%89%E5%AD%90%E8%8A%82%E7%82%B9%EF%BC%89%EF%BC%9A%E4%BE%8B%E5%A6%82input,img,br%E5%92%8Chr%E3%80%82">http://www.w3.org/TR/html401/struct/text.html＃edef-P）。另一方面，其他一些元素始终是空的（即没有子节点）：例如input,img,br和hr。</a></em></p>
<p>:has()</p>
<p>选择元素其中至少包含指定选择器匹配的一个/种元素。</p>
<p>:parent</p>
<p>选择所有含有子元素或者文本的父级元素。这个正好和 :empty 相反。</p>
<h3 id="可见性筛选"><a href="#可见性筛选" class="headerlink" title="可见性筛选"></a>可见性筛选</h3><p>:hidden</p>
<p>:visible</p>
<p>元素可以被认为是隐藏的几个情况：</p>
<ul>
<li>他们的 CSS display 值是 none。</li>
<li>他们是 type=”hidden”的表单元素。</li>
<li>它们的宽度和高度都显式设置为 0。</li>
<li>一个祖先元素是隐藏的，因此该元素是不会在页面上显示。</li>
</ul>
<p>元素 visibility:hidden 或 opacity:0 被认为是可见的，因为他们仍然占据布局空间。在动画，隐藏一个元素，该元素被认为是可见的直到动画结束。<br>不在文档中的元素是被认为是不可见的;如果当他们被插入到文档中，jQuery 没有办法知道他们是否是可见的，因为元素可见性依赖于适用的样式。<br>jQuery 3 稍微修改了:hidden (以及:visible)的含义。 这个版本开始，如果一个元素没有任何布局盒子，那么它将被视为:hidden。例如，br 元素和没有内容的内联元素将不能通过:hidden 选择器被选择。</p>
<h3 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h3><p>:button</p>
<p>:checkbox</p>
<p>:checked</p>
<p>:disabled</p>
<p>:enabled</p>
<p>:focus</p>
<p>:file</p>
<p>:image</p>
<p>:input</p>
<p>:password</p>
<p>:radio</p>
<p>:reset</p>
<p>:selected</p>
<p>:submit</p>
<p>:text</p>
<h2 id="属性-CSS-相关"><a href="#属性-CSS-相关" class="headerlink" title="属性/CSS 相关"></a>属性/CSS 相关</h2><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>属性有.attr()，.prop()，.removeAttr()，.removeProp()，.val()这 5 个方法。</p>
<p>1 .attr()</p>
<p>获取匹配的元素集合中的第一个元素的属性的值 或 设置每一个匹配元素的一个或多个属性。</p>
<p><em>jQuery 的很多方法都是默认获取的时候为第一个元素的值，而写入或设置的时候为修改所有匹配的元素</em></p>
<p>1.1 .attr( attributeName )</p>
<p>获取匹配的元素集合中的第一个元素的属性的值。</p>
<p>根据 W3C 的表单规范 ，checked 属性是一个布尔属性，这意味着,如果这个属性（attribute）是目前存在，即使，该属性没有对应的值，或者被设置为空字符串值，或甚至是”false”，相应的属性（property）为 true。这才是真正的所有布尔属性（attributes）。<br>checked 特性（attribute）值不会因为复选框的状态而改变，而 checked 属性（property）会因为复选框的状态而改变。因此，跨浏览器兼容的方法来确定一个复选框是否被选中，是使用该属性（property）：</p>
<pre><code>if ( elem.checked )
if ( $(elem).prop(&quot;checked&quot;) )
if ( $(elem).is(&quot;:checked&quot;) )
</code></pre>
<p><em>除了 checked，对于其他的动态属性 selected，disabled 和 value 也应该使用 prop()方法</em></p>
<p><em>在 Internet Explorer 9 之前的版本，使用.prop()设置 DOM 元素的属性进行赋值时，若所赋值的类型不是基本类型(number, string, 或 boolean)，而且也没有在 DOM 元素从文档中被移除之前使用 .removeProp() 方法。为了安全的在 DOM 对象上进行赋值而不用担心内存泄露问题，请使用 .data()方法。</em></p>
<p>1.2 .attr( attributeName, value )</p>
<p>value 类型: String or Number or Null。如果为 null， 指定的属性将被删除（就像.removeAttr()一样）</p>
<p>1.3 .attr( attributes )</p>
<p>attributes 类型: PlainObject，一个要设置的属性-值集合对象</p>
<p>1.4 .attr( attributeName, function(Integer index, String attr) )</p>
<p>这个函数返回用来设置的值。this 指向当前的元素。接收该元素在集合中索引位置（index）和 原来属性值（attr）作为参数。</p>
<p><em>注意 如果 setter 函数没有返回任何数据（例如：function(index, attr){})，属性的当前值返回值是 undefined，作为一个 getter 行为。实际上，如果不进行任何更改的 setter 函数不返回的东西。</em></p>
<p><em>警告： 当设置样式名（“class”）属性时，必须使用引号！</em></p>
<p><em>注意: 试图改变 由 document.createElement()创建的 input 或 button 的 type 属性，在 Internet Explorer 8 或更老的版本中将抛出一个例外。</em></p>
<p>2 .prop()</p>
<p>参见 attr().</p>
<p>禁用页面所有复选框</p>
<pre><code>&lt;script&gt;
$(&quot;input[type=&#39;checkbox&#39;]&quot;).prop(&#123;
  disabled: true
&#125;);
&lt;/script&gt;
</code></pre>
<p>3 .removeAttr( attributeName )</p>
<p>attributeName 类型: String，要移除的属性名,从 1.7 版本开始，它可以是一个空格分隔的属性列表。</p>
<p><em>注意: Internet Explorer 8， 9 ，和 11 中，使用.removeAttr()<br>删除一个内联 onclick 事件处理程序不会达到预期的效果，为了避免潜在的问题，使用 .prop()代替：</em></p>
<pre><code>$element.prop(&quot;onclick&quot;, null);
console.log(&quot;onclick property: &quot;, $element[0].onclick);
</code></pre>
<p>4 .removeProp( propertyName )</p>
<p>若尝试移除 DOM 元素或 window 对象上一些内建的 属性（ property ） ，浏览器可能会产生错误。如果真的那么做了，那么 jQuery 首先会将 属性（ property ） 设置成 undefined ，然后忽略任何浏览器产生的错误。一般来说,只需要移除自定义的 属性（ property ） ，而不是移除内建的（原生的）属性（ property ）。</p>
<p><em>注意: 不要使用此方法来删除原生的属性（ property ），比如 checked, disabled, 或者 selected。这将完全移除该属性，一旦移除，不能再次被添加到元素上。使用.prop()来设置这些属性设置为 false 代替。</em></p>
<p>5 .val()</p>
<p>5.1 .val()</p>
<p>当该集合中第一个元素是一个 select-multiple（即 select 元素设置了 multiple 属性），.val()返回一个包含每个选择项值的数组。在 jQuery 3.0 中， 如果没有选项被选中，它将返回一个空数组；在 jQuery 3.0 之前的版本中， 它将返回 null。</p>
<pre><code>function displayVals() &#123;
  var singleValues = $(&quot;#single&quot;).val();
  var multipleValues = $(&quot;#multiple&quot;).val() || []; //确保没有选项被选中时为[]
  $(&quot;p&quot;).html(&quot;&lt;b&gt;Single:&lt;/b&gt; &quot; +
              singleValues +
              &quot; &lt;b&gt;Multiple:&lt;/b&gt; &quot; +
              multipleValues.join(&quot;, &quot;));
&#125;

$(&quot;select&quot;).change(displayVals);
displayVals();
</code></pre>
<p>对于选择框（select），复选框（checkbox）和单选按钮（radio button），您也可以使用:selected 和 :checked 选择器来获取值。</p>
<p><em>注意: 通过 .val() 方法从 &lt;textarea&gt; 元素中获取的值是不含有回车（\r）字符的。但是如果该值是通过 XHR 传递给服务器的，回车（\r）字符会被保留（或者是被浏览器添加的，但是在原始数据中并不包含回车（\r））。可以使用下面的 valHook 方法解决这个问题：</em></p>
<pre><code>$.valHooks.textarea = &#123;
  get: function( elem ) &#123;
    return elem.value.replace( /\r?\n/g, &quot;\r\n&quot; );
  &#125;
&#125;;
</code></pre>
<p>5.2 .val( value )</p>
<p>value 类型: String or Number or Array，一个文本字符串,一个数字，或一个以字符串形式的数组来设定每个匹配元素的值。</p>
<p>val() 允许你传递一个元素值的数组。当使用在包含像<input type="checkbox">, <input type="radio">, 和<select>中的 <option>元素的 jQuery 对象上的时候是非常有用的。在这种情况下，input 和 option 的 value 与数组元素相匹配的情况下将被选中（checked）或选定（selected），而那些与数组元素值不匹配的 value 是未选中（unchecked）或未被选（unselected），这取决于元素类型。对于 <input type="radio"> 属于一个单选按钮组 ，还有<select>的其他元素都将被取消选中。</p>
<pre><code>&lt;select id=&quot;single&quot;&gt;
  &lt;option&gt;Single&lt;/option&gt;
  &lt;option&gt;Single2&lt;/option&gt;
&lt;/select&gt;

&lt;select id=&quot;multiple&quot; multiple=&quot;multiple&quot;&gt;
  &lt;option selected=&quot;selected&quot;&gt;Multiple&lt;/option&gt;
  &lt;option&gt;Multiple2&lt;/option&gt;
  &lt;option selected=&quot;selected&quot;&gt;Multiple3&lt;/option&gt;
&lt;/select&gt;&lt;br/&gt;
&lt;input type=&quot;checkbox&quot; name=&quot;checkboxname&quot; value=&quot;check1&quot;/&gt; check1
&lt;input type=&quot;checkbox&quot; name=&quot;checkboxname&quot; value=&quot;check2&quot;/&gt; check2
&lt;input type=&quot;radio&quot;  name=&quot;r&quot; value=&quot;radio1&quot;/&gt; radio1
&lt;input type=&quot;radio&quot;  name=&quot;r&quot; value=&quot;radio2&quot;/&gt; radio2
&lt;script&gt;

    $(&quot;#single&quot;).val(&quot;Single2&quot;);
    $(&quot;#multiple&quot;).val([&quot;Multiple2&quot;, &quot;Multiple3&quot;]);
    $(&quot;input&quot;).val([&quot;check1&quot;,&quot;check2&quot;, &quot;radio1&quot; ]);

&lt;/script&gt;
</code></pre>
<p>使用这个方法（或使用原生的 value 属性（property））设置值，不会触发 change 事件。为此，相关的事件处理程序不会被执行。如果要执行它们，你应该在设置值之后调用 .trigger( “change” )</p>
<p>5.3 .val( function( Integer index, String value ) )</p>
<pre><code>$(&#39;input:text.items&#39;).val(function( index, value ) &#123;
  return value + &#39; &#39; + this.className;
&#125;);
</code></pre>
<h3 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h3><p>CSS 主要有以下一些方法：</p>
<p>.addClass()</p>
<p>.css()</p>
<p>jQuery.cssHooks</p>
<p>jQuery.cssNumber</p>
<p>jQuery.escapeSelector()</p>
<p>.hasClass()</p>
<p>.removeClass()</p>
<p>.toggleClass()</p>
<p>1 .addClass()</p>
<p>1.1 .addClass( className )</p>
<p>1.2 .addClass( function(index, currentClass) )</p>
<p>在 jQuery 1.12/2.2 版本之前， .addClass()方法操纵是选定元素的 className 特性（property），不是 class 属性（attribute）。一旦特性（property）改变，浏览器就会更新相应地的属性（attribute）。此行为的一个言外之意是，这种方法只适用于 HTML DOM 语义的文档（例如，不是纯 XML 文档）。</p>
<p>在 jQuery1.12/2.2 中，改变了这种行为以改善对 XML 文档，包括 SVG 的支持。从这个版本开始，class 属性（attribute）被替换（愚人码头注：这个版本开始，.addClass()方法操作的是 class 属性（attribute），而不是 className 特性（property））。因此，.addClass()可以在 XML 或 SVG 文档中使用。</p>
<p>对所有匹配的元素可以一次添加多个用空格隔开的样式类名。</p>
<p>2 .hasClass( className )</p>
<p>在 jQuery 1.12/2.2 中, 这个方法支持 XML 文档, 包括 SVG。</p>
<p>3 .removeClass()</p>
<p>如果一个样式类名作为一个参数,只有这样式类会被从匹配的元素集合中删除 。 如果没有样式名作为参数，那么所有的样式类将被移除。</p>
<p>4 .toggleClass()</p>
<p>4.1 .toggleClass( className )</p>
<p>4.2 .toggleClass( className, state )</p>
<p>state 类型: Boolean,一个布尔值（不止是真值/假值），用于判断样式是否应该被添加或移除。</p>
<p>4.3 .toggleClass( function( Integer index, String className, Boolean state ) [, state ] )</p>
<p>5 .css()</p>
<p>.css( propertyName )</p>
<p>.css( propertyNames )</p>
<p>.css( propertyName, value )</p>
<p>.css( propertyName, function(index, value) )</p>
<p>.css( properties )</p>
<p>5.1 从 jQuery 1.9 开始, 传递一个 CSS 的样式属性的数组给.css()将返回 属性 - 值 配对的对象。例如，要获取元素 4 个边距宽度值 border-width，你可以使用$( elem ).css([ “borderTopWidth”, “borderRightWidth”, “borderBottomWidth”, “borderLeftWidth” ]).</p>
<p>5.2 当一个数只被作为值（value）的时候， jQuery 会将其转换为一个字符串，并添在字符串的结尾处添加 px(愚人码头注：.css(“width”,50})，.css(“width”,”50”})，.css(“width”,’50px’})这 3 条语句是等价的，具体可以查看 <a target="_blank" rel="noopener" href="http://jsfiddle.net/feiwen8772/b78mgmdd/)%E3%80%82">http://jsfiddle.net/feiwen8772/b78mgmdd/)。</a> 如果属性值需要非 px 的其他单位，请使用添加了合适单位的字符串（愚人码头注：例如，’12em’）</p>
<p>5.3 样式属性的值设置为空字符串 — 例如，$(‘#mydiv’).css(‘color’, ‘’) — 那么会从元素上移除该属性（若该属性存在的话）， 该属性之前可能是通过 jQuery 的 .css() 方法设置的 HTML style 属性，也有可能是通过直接对 style 属性进行 DOM 操作而被设置的。 因此，该属性的元素样式将恢复到之前应用的任何值。</p>
<p><em>注意: .css()忽略了!important 声明！ 因此，语句$( “p” ).css( “color”, “red !important” )，不会将页面中所有段落颜色转变为红色。 强烈建议使用类（class）来代替; 否则请使用 jQuery 插件。</em></p>
<p>5.4 从 jQuery1.6 开始，.css()接受类似于.animate()的相对值。相对值时以+= 或者 -=开头的字符串，表示递增或递减当前的值。 例如，如果一个元素的左边填充（padding-left）是 10px 的，.css( “padding-left”, “+=15” )将返回总的左填充（padding-left ）为 55px。</p>
<p>5.5 <em>注意: 如果设置函数没有返回任何东西(例如. function(index, style){})，或者如果返回 undefined，当前的值不会改变。只有当某些条件得到满足，选择性的设定值的时后是有用的。</em></p>
<p>6 jQuery.cssHooks</p>
<p>直接向 jQuery 中添加钩子，用于覆盖设置或获取特定 CSS 属性时的方法，目的是为了标准化 CSS 属性名或创建自定义属性。</p>
<pre><code>(function($) &#123;
  if ( !$.cssHooks ) &#123;
    throw(&quot;jQuery 1.4.3+ is needed for this plugin to work&quot;);
    return;
  &#125;

  function styleSupport( prop ) &#123;
    var vendorProp, supportedProp,
        capProp = prop.charAt(0).toUpperCase() + prop.slice(1),
        prefixes = [ &quot;Moz&quot;, &quot;Webkit&quot;, &quot;O&quot;, &quot;ms&quot; ],
        div = document.createElement( &quot;div&quot; );

    if ( prop in div.style ) &#123;
      supportedProp = prop;
    &#125; else &#123;
      for ( var i = 0; i &lt; prefixes.length; i++ ) &#123;
        vendorProp = prefixes[i] + capProp;
        if ( vendorProp in div.style ) &#123;
          supportedProp = vendorProp;
          break;
        &#125;
      &#125;
    &#125;

    div = null;
    $.support[ prop ] = supportedProp
    return supportedProp;
  &#125;

  var borderRadius = styleSupport( &quot;borderRadius&quot; );

  // Set cssHooks only for browsers that
  // support a vendor-prefixed border radius
  if ( borderRadius &amp;&amp; borderRadius !== &quot;borderRadius&quot; ) &#123;
    $.cssHooks.borderRadius = &#123;
      get: function( elem, computed, extra ) &#123;
        return $.css( elem, borderRadius );
      &#125;,
      set: function( elem, value) &#123;
        elem.style[ borderRadius ] = value;
      &#125;
    &#125;;
  &#125;
&#125;)(jQuery);
</code></pre>
<p>7 jQuery.cssNumber</p>
<p>一个对象，这个包含所有可以不使用单位的 CSS 属性。.css() 方法使用这个对象来确定是否可能附加 px 到无单位的值。</p>
<p>jQuery.cssNumber.someCSSProp = true;</p>
<p>默认情况下，这个对象包含以下属性：</p>
<ul>
<li>zIndex</li>
<li>fontWeight</li>
<li>opacity</li>
<li>zoom</li>
<li>lineHeight</li>
<li>widows (jQuery 1.6 开始添加)</li>
<li>orphans (jQuery 1.6 开始添加)</li>
<li>fillOpacity (jQuery 1.6.2 开始添加)</li>
<li>columnCount (jQuery 1.9 开始添加)</li>
<li>order (jQuery 1.10.2 开始添加)</li>
<li>flexGrow (jQuery 1.11.1 开始添加)</li>
<li>flexShrink (jQuery 1.11.1 开始添加)</li>
</ul>
<p>8 jQuery.escapeSelector()</p>
<p>转义 CSS 选择器中任何具有特殊的含义字符。</p>
<p>添加版本: 3.0</p>
<p>此方法对于一个 CSS 类名或一个 ID 包含的字符在 CSS 中具有特殊含义的情况下非常有用，如点或分号。</p>
<p>该方法本质上是<a target="_blank" rel="noopener" href="https://drafts.csswg.org/cssom/#the-css.escape()-method">CSS 工作组 CSS.escape()方法</a>的 shim（垫片）。 主要的区别在于，$.escapeSelector() 可以可靠地使用在所有 jQuery 支持的浏览器中。</p>
<p>转义包含 hash 的 ID.</p>
<pre><code>$.escapeSelector( &quot;#target&quot; ); // &quot;\#target&quot;
</code></pre>
<p>选择在一个 div 内，所有类名为.box 的元素。</p>
<pre><code>$( &quot;div&quot; ).find( &quot;.&quot; + $.escapeSelector( &quot;.box&quot; ) );
</code></pre>
<h3 id="尺寸"><a href="#尺寸" class="headerlink" title="尺寸"></a>尺寸</h3><p>主要有.height()，.width()，.innerHeight()，.innerWidth()，.outerHeight()，.outerWidth()</p>
<p>1 .height()</p>
<p>1.1 .height()</p>
<p>.css(‘height’) 和 .height()之间的区别是后者返回一个没有单位的数值（例如，400），前者是返回带有完整单位的字符串（例如，400px）。当一个元素的高度需要数学计算的时候推荐使用.height() 方法 。</p>
<p><em>注意.height()总是返回容器的高度,不管 CSS box-sizing 属性值。截至 jQuery 1.8，这可能需要检索的 CSS 的宽度加加上 box-sizing 的属性，然后当元素有 box-sizing: border-box 时候，减去个元素上任何潜在 border 和 padding 值。为了避免这种问题，使用.css( “height” )而非.height()。</em></p>
<p><em>尺寸相关的 API 返回的数字， 包括的 .height()， 在某些情况下可能带有小数。你的代码不应该假定它是一个整数。 另外，当页面被用户缩放时，返回的尺寸可能是不正确的;浏览器没有一个公开的 API 来检测这种情况。</em></p>
<p><em>当元素或其父元素被隐藏时，.height()得到的值不能保证准确。要得到准确的值，你应该确保该元素在使用.height()前可见。jQuery 将尝试临时显示，然后再隐藏元素来测量元素尺寸，但这是不可靠的，（即使得到准确的值）也会显著影响页面的性能。这总临时显示然后再隐藏的测量功能，可能在 jQuery 未来的版本中删除。</em></p>
<p>1.2 .height( value )</p>
<p>1.3 .height( function(index, height) )</p>
<p>当调用.height(value)方法的时候，这个“value”参数可以是一个字符串（数字加单位）或者是一个数字。如果这个“value”参数只提供一个数字，jQuery 会自动加上单位 px。如果只提供一个字符串，任何有效的 CSS 尺寸都可以为高度赋值（就像 100px, 50%, 或者 auto）。注意在现代浏览器中，CSS 高度属性不包含 padding, border, 或者 margin。</p>
<p>如果没有给定明确的单位（像’em’ 或者 ‘%’），那么默认情况下”px”会被直接添加上去（也理解为”px”是默认单位）。</p>
<p><em>注意.height(‘value’)设置的容器宽度是根据 CSS box-sizing 属性来定的, 将这个属性值改成 border-box，将造成这个函数改变这个容器的 outerHeight，而不是原来的内容高度。</em></p>
<p>以上的注意事项，尺寸的其他方法同理。</p>
<p>2 .width()</p>
<p>3 .innerHeight()</p>
<p>用于获得匹配集合中第一个元素的当前计算的内部高度（包括 padding，但不包括 border），或 设置每一个匹配元素的内部高度。</p>
<p>这个方法返回元素的高度，包括顶部和底部的 padding，单位是像素。</p>
<p>这个方法不适用于 window 和 document 对象，对于这些对象可以使用.height()代替。</p>
<p>4 .innerWidth()</p>
<p>5 .outerHeight()</p>
<p>获取匹配元素集合中第一个元素的当前计算宽度值,包括 padding，border 和选择性的 margin。返回一个整数（不包含“px”）表示的值 ，或如果在一个空集合上调用该方法，则会返回 null。</p>
<p>.outerHeight( [includeMargin ] )</p>
<p>includeMargin (默认: false),类型： Boolean,一个布尔值，表明是否在计算时包含元素的 margin 值。</p>
<p>6 .outerWidth()</p>
<h3 id="位置"><a href="#位置" class="headerlink" title="位置"></a>位置</h3><p>位置主要有.offset(),.offsetParent(),.position(),.scrollLeft(),.scrollTop()</p>
<p>1 .offset()</p>
<p>1.1 .offset()</p>
<p>在匹配的元素集合中，获取的第一个元素的当前坐标，坐标相对于文档。</p>
<p>.offset()返回一个包含 top 和 left 属性的对象 。</p>
<p><em>注意：jQuery 不支持获取隐藏元素的偏移坐标。同样的，也无法取得隐藏元素的 border, margin, 或 padding 信息。</em></p>
<p><em>若元素的属性设置的是 visibility:hidden，那么我们依然可以取得它的坐标。但是若设置的属性是 display:none，由于在绘制 DOM 树时根本就不绘制该元素，所以它的位置属性值是 undefined。</em></p>
<p>1.2 .offset( coordinates )</p>
<p>coordinates 类型: PlainObject,一个包含 top 和 left 属性的对象，用整数指明元素的新顶部和左边坐标。</p>
<p>1.3 .offset( function(index, coords) )</p>
<p>返回用于设置坐标的一个函数。接收元素在匹配的元素集合中的索引位置作为第一个参数，和当前坐标作为第二个参数。这个函数应该返回一个包含 top 和 left 属性的对象。</p>
<p>.offset()方法允许我们重新设置元素的位置，这个元素的位置是相对于 document 对象的。如果对象原先的.position()样式属性是 static 的话，会被改成 relative 来实现重定位。</p>
<p>2 .offsetParent()</p>
<p>取得离指定元素最近的含有定位信息的祖先元素。含有定位信息的元素指的是，CSS 的 position 属性是 relative, absolute, 或 fixed 的元素</p>
<p>3 .position()<br>获取匹配元素中第一个元素的当前坐标，相对于 offset parent 的坐标。( 译者注：offset parent 指离该元素最近的而且被定位过的祖先元素 )</p>
<p>.position()方法可以取得元素相对于父元素的偏移位置。与.offset()不同, .offset()是获得该元素相对于 documet 的当前坐标,当把一个新元素放在同一个容器里面另一个元素附近时，用.position()更好用。</p>
<p>.position()返回一个包含 top 和 left 属性的对象.</p>
<p>4 .scrollLeft()</p>
<p>4.1 .scrollLeft()</p>
<p>获取匹配的元素集合中第一个元素的当前水平滚动条的位置。</p>
<p><em>注意:.scrollLeft(), 当直接调用或使用.animate()做动画，当元素被应用了隐藏，将不做任何改变。</em></p>
<p>4.2 .scrollLeft( value )</p>
<p>5 .scrollTop()</p>
<h2 id="数据-data"><a href="#数据-data" class="headerlink" title="数据 data"></a>数据 data</h2><p>有三个底层的方法 jQuery.data()，jQuery.hasData()，jQuery.removeData()和两个元素上的方法.data()，.removeData()，一般不要使用底层的方法，而是使用元素上的方法。</p>
<p>1 jQuery.hasData()</p>
<p>jQuery.hasData( element )</p>
<p>确定任何一个元素是否有与之相关的 jQuery 数据。</p>
<p>jQuery.hasData()方法提供了一种方法来确定一个元素是否有任何数据，这些数据是使用 jQuery.data()设置的。如果一个元素没有关联的 data 对象，该方法返回 false ;否则返回 true 。</p>
<p>jQuery.hasData(element) 的主要优点是它并不创建 data 对象。如果元素上没有 data 对象，那么该方法也不会与元素上的 data 对象关联。相反，jQuery.data(element)总是向调用者返回一个 data 对象，即使该元素上不含有 data 对象，它也会创建一个。</p>
<p><em>请注意，jQuery 的事件系统是使用 jQuery 数据 存储事件处理程序的。 因此，使用.on(), .bind(), .live(), .delegate()，或一个速记事件方法 绑定事件到一个元素上的时候，也会在那个元素上关联一个 data 对象。</em></p>
<p>2 .data()</p>
<p>在匹配元素上存储任意相关数据 或 返回匹配的元素集合中的第一个元素的给定名称的数据存储的值。</p>
<p>2.1 .data( key, value )</p>
<p>key 类型: String，一个字符串，用户存储数据的名称。（译者注：存储的数据名）</p>
<p>value 类型: Anything，新的数据值；它可以是任意的 Javascript 数据类型，除了 undefined。</p>
<p>2.2 .data( obj )</p>
<p>obj 类型: Object，一个用于更新数据的 键/值对</p>
<p>.data() 方法允许我们在 DOM 元素上绑定任意类型的数据,避免了循环引用的内存泄漏风险。我们可以在一个元素上设置不同的值，并获取这些值：</p>
<p>由于浏览器用插件和外部代码相互作用,.data()方法不能在<object>（除非是 Flash 插件），<applet> 或 <embed>元素上使用。</p>
<p><em>注意这个方法目前并不提供在 XML 文档上跨平台设置数据，作为 Internet Explorer 不允许通过自定义属性附加数据。</em></p>
<p><em>undefined 不是认可的数据值。比如这样调用.data( “name”, undefined ) ，将返回 “name”对应的数据， 也就是等同于调用.data( “name” )。</em></p>
<p>2.3 .data( key )</p>
<p>返回匹配的元素集合中的第一个元素的给定名称的数据存储的值。 通过.data(name, value)或 HTML5 data-* 属性设置</p>
<p>2.4 .data()</p>
<p>从 jQuery 1.4.3 起， HTML 5 data- 属性 将自动被引用到 jQuery 的数据对象中。嵌入式破折号处理属性（ attributes）的方式在 jQuery 1.6 中已经改变，以使之符合 W3C HTML5 规范.</p>
<p>如果没有传递 key 参数的数据存储， jQuery 将在元素的属性中搜索， 将驼峰式字符串转化为中横线字符串，然后在结果前面加上 data-。 所以，该字符串 lastValue 将被转换为 data-last-value。</p>
<p>每次尝试将字符串转换为一个 JavaScript 值（包括布尔值（booleans），数字（numbers），对象（objects），数组（arrays）和空（null））。如果这样做不会改变值的表示，那么该值将转换为一个数字（number）。例如，“1E02”和“100.000”是等同于数字（数字值 100），但将转换它们会改变他们的表示，所以他们被保留为字符串。字符串值“100”被转换为数字 100。</p>
<p>如果数据(data)属性是一个对象（以“{”开始）或数组（以’[‘开始），可以用 jQuery.parseJSON 将其解析成字符串；它必须遵循<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/JSON#Data_types.2C_syntax_and_example">有效的 JSON 的语法</a>，包括带双引号的属性名称。如果该值不能解析为一个 JavaScript 值，它将被保留为字符串。</p>
<p>如果不想将取出的属性值直接当作字符串的话，请使用 attr()方法。</p>
<p>data-属性是在第一次使用这个数据属性后不再存取或改变（所有的数据值都在 jQuery 内部存储）。</p>
<p>调用 .data() 时如果不带参数，将会以 JavaScript 对象的形式获取所有数据。这个对象可以安全的存放在变量中，因为一旦这个新对象被提取出来，之后对元素进行的 .data(obj)操作，将不会再影响这个对象。另外，直接操作这个对象会比每次调用 .data() 来设置或获取值要快一些：</p>
<p>3 .removeData( [name ] )</p>
<p>在元素上移除绑定的数据</p>
<p>3.1 .removeData( [name ] )</p>
<p>name 类型: String,要移除的存储数据名.</p>
<p>3.2 .removeData( [list ] )</p>
<p>list 类型: Array or String,一个数组或空间分隔的字符串命名要删除的数据块。</p>
<p>.removeData()方法允许我们移除用.data()绑定的值。当带 name 参数调用的时候，.removeData()将删除那个特有的值，当不带任何参数的时候，.removeData()将移除所有的值。</p>
<p>需要注意的是.removeData()仅会删除来自 jQuery 内部.data()缓存中的数据， 并且元素上任何相应的 data-属性不会被删除。后调用 data()，会重新检索 data-的属性的值。 为了防止这种情况，可以在.removeData()旁边使用.removeAttr()来移除 data-属性。jQuery 1.4.3 以前,data()没有使用 data-属性，所以不存在这类问题。</p>
<p>从 jQuery 1.7 开始, 当键数组或一个空间分隔键的字符串作为参数，调用.removeData()时，将删除在该数组每一项元素或字符串的键值。</p>
<p>4 jQuery.data()</p>
<p>jQuery.data( element, key, value )</p>
<p>jQuery.data( element, key )</p>
<p>jQuery.data( element )</p>
<p>注意：这是一个底层的方法，你应该用.data()代替。</p>
<p>jQuery.data() 方法允许我们在 DOM 元素上附加任意类型的数据,避免了循环引用的内存泄漏风险。如果 DOM 元素是通过 jQuery 方法删除的或者当用户离开页面时，jQuery 同时也会移除添加在上面的数据。我们可以在一个元素上设置不同的值，并获取这些值：</p>
<p><em>.unload()方法只是作为.on( “unload”, handler )的一个速记写法，移除该事件可以使用.off( “unload” )。</em></p>
<p>关于 HTML5 data-* 属性: 这个低层次的方法不检索的 data-*属性， 除非.data()方法已经返回了它们。</p>
<p>调用 jQuery.data(element)时将获取一个 JavaScript 对象，它包含了元素上所有存储的数据。jQuery 内部自身使用这个方法来绑定数据，如事件处理器，所以不要以为这对象只包含你的代码中储存的数据。</p>
<p>其他和元素上的 data 方法一样</p>
<p>5 .removeData()</p>
<p>和元素上的 removeDate()同理</p>
<h2 id="DOM-操作"><a href="#DOM-操作" class="headerlink" title="DOM 操作"></a>DOM 操作</h2><h3 id="拷贝"><a href="#拷贝" class="headerlink" title="拷贝"></a>拷贝</h3><p>.clone( [withDataAndEvents ] )</p>
<p>withDataAndEvents (默认: false)<br>类型: Boolean，<br>一个 Boolean 值，表示是否会复制元素上的事件处理函数。从 jQuery 1.4 开始，元素数据也会被复制。</p>
<p>.clone( [withDataAndEvents ] [, deepWithDataAndEvents ] )</p>
<p>withDataAndEvents (默认: false)<br>类型: Boolean，<br>一个 Boolean 值，表示是否会复制元素上的事件处理函数。 默认值是 false。*对于 1.5.0 的默认值被不适当地设置成了 true，将在 1.5.1 以上改回 false 。</p>
<p>deepWithDataAndEvents (默认: value of withDataAndEvents)<br>类型: Boolean，<br>一个布尔值，指示是否对事件处理程序和克隆的元素的所有子元素的数据应该被复制。默认情况下它的值相匹配的第一个参数的值（ 默认值是 false）</p>
<p><em>注意:出于性能方面的考虑，表单元素动态的状态（例如，用户将数据输入到 textarea 中的值，或者用户在 select 中已经选中某一项）不会被复制到克隆元素。当克隆 input 元素时候，该元素的动态状态（例如，用户数据输入到文本输入框(愚人码头注： <input type="text">) 和用户选中一个复选框）将被保留在克隆元素中。</em></p>
<p>像我们讨论.append()一样，通常我们将页面上一个元素插入到 DOM 里另立个地方，它会被从老地方移走（愚人码头注：不是复制）</p>
<p>但是我们如果需要的是复制而不是移除，我们可以像下面这样写代码：</p>
<pre><code>$(&#39;.hello&#39;).clone().appendTo(&#39;.goodbye&#39;);
</code></pre>
<p>然而，元素数据（data）内对象和数组不会被复制，将继续被克隆元素和原始元素共享。深复制的所有数据，需要手动复制每一个：</p>
<pre><code>// Original element with attached data
var $elem = $( &quot;#elem&quot; ).data( &quot;arr&quot;, [ 1 ] ),
    $clone = $elem.clone( true )
      // Deep copy to prevent data sharing
      .data( &quot;arr&quot;, $.extend( [], $elem.data( &quot;arr&quot; ) ) );
</code></pre>
<p>在 jQuery 1.5，withDataAndEvents 可以选择性增强 deepWithDataAndEvents 复制元素的事件和数据的克隆的所有子元素。</p>
<p><em>注意: 使用.clone()可能产生 id 属性重复的元素的副作用，id 应该是唯一的。在可能的情况下，建议，应避免克隆有此属性或标识符的元素，使用类（class）属性代替。</em></p>
<p>当使用 .clone()克隆一组元素，并且这些克隆生成的元素尚未被添加到 DOM 中，那么当这些元素被插入到 DOM 中时，不能保证是按它们的原顺序被插入的。但是，可以像下面例子中提到的那样，保证顺序的正确性：</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;style&gt;
  #orig, #copy, #copy-correct &#123;
    float: left;
    width: 20%;
  &#125;
&lt;/style&gt;
  &lt;script src=&quot;http://code.jquery.com/jquery-latest.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;div id=&quot;orig&quot;&gt;
    &lt;div class=&quot;elem&quot;&gt;&lt;a&gt;1&lt;/a&gt;&lt;/div&gt;
    &lt;div class=&quot;elem&quot;&gt;&lt;a&gt;2&lt;/a&gt;&lt;/div&gt;
    &lt;div class=&quot;elem&quot;&gt;&lt;a&gt;3&lt;/a&gt;&lt;/div&gt;
    &lt;div class=&quot;elem&quot;&gt;&lt;a&gt;4&lt;/a&gt;&lt;/div&gt;
    &lt;div class=&quot;elem&quot;&gt;&lt;a&gt;5&lt;/a&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&quot;copy&quot;&gt;&lt;/div&gt;
&lt;div id=&quot;copy-correct&quot;&gt;&lt;/div&gt;

&lt;script&gt;
// sort order is not guaranteed here and may vary with browser
$(&#39;#copy&#39;).append($(&#39;#orig .elem&#39;)
          .clone()
          .children(&#39;a&#39;)
          .prepend(&#39;foo - &#39;)
          .parent()
          .clone());

// correct way to approach where order is maintained
$(&#39;#copy-correct&#39;)
          .append($(&#39;#orig .elem&#39;)
          .clone()
          .children(&#39;a&#39;)
          .prepend(&#39;bar - &#39;)
          .end());
&lt;/script&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="DOM-插入-包裹"><a href="#DOM-插入-包裹" class="headerlink" title="DOM 插入, 包裹"></a>DOM 插入, 包裹</h3><p>有三个方法：.wrap()，.wrapAll()，.wrapInner()</p>
<p>1 .wrap()</p>
<p>在集合中匹配的每个元素周围包裹一个 HTML 结构。</p>
<p>.wrap( wrappingElement )</p>
<p>wrappingElement<br>类型: Selector 或 htmlString 或 Element 或 jQuery，<br>一个选择器，元素，HTML 字符串，或 jQuery 对象指定的 html 结构环绕包裹的匹配元素。 当你传递一个包含多个元素一个 jQuery 集合， 或选择器的匹配多个元素时， 第一元素将被使用。</p>
<p>.wrap( function )<br>function<br>类型: Function( Integer index ) =&gt; String 或 jQuery，<br>一个回调函数，返回用于包裹匹配元素的 HTML 内容或 jQuery 对象。接受的 index 参数表示匹配元素在集合中的索引位置。该函数内的 this 指向集合中的当前元素。</p>
<pre><code>$(&#39;.inner&#39;).wrap(function() &#123;
  return &#39;&lt;div class=&quot;&#39; + $(this).text() + &#39;&quot; /&gt;&#39;;
&#125;);

&lt;div class=&quot;container&quot;&gt;
  &lt;div class=&quot;Hello&quot;&gt;
    &lt;div class=&quot;inner&quot;&gt;Hello&lt;/div&gt;
  &lt;/div&gt;
  &lt;div class=&quot;Goodbye&quot;&gt;
    &lt;div class=&quot;inner&quot;&gt;Goodbye&lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<p>使用一个嵌套深度为两层 div 的 jQuery 对象来包裹所有的段落。注意，这并不会移动用于包裹的对象，只是将克隆后的对象用于包裹。</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;style&gt;

  div &#123; border: 2px solid blue; margin:2px; padding:2px; &#125;
  .doublediv &#123; border-color:red; &#125;
  p &#123; background:yellow; margin:4px; font-size:14px; &#125;
  &lt;/style&gt;
  &lt;script src=&quot;http://code.jquery.com/jquery-latest.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;p&gt;Hello&lt;/p&gt;
  &lt;p&gt;cruel&lt;/p&gt;
  &lt;p&gt;World&lt;/p&gt;
  &lt;div class=&quot;doublediv&quot;&gt;&lt;div&gt;&lt;/div&gt;&lt;/div&gt;
&lt;script&gt;$(&quot;p&quot;).wrap($(&quot;.doublediv&quot;));&lt;/script&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>2 .wrapAll()</p>
<p>.wrapAll( wrappingElement )</p>
<p>wrappingElement</p>
<p>类型: Selector 或 htmlString 或 Element 或 jQuery</p>
<p>一个选择器，元素，HTML 字符串，或 jQuery 对象指定的 html 结构环绕包裹的匹配元素。</p>
<p>.wrapAll( function )</p>
<p>function</p>
<p>类型: Function() =&gt; String 或 jQuery，</p>
<p>一个回调函数，返回的 HTML 内容或 jQuery 对象将包裹所有匹配的元素。函数内的 this 指向集合中的第一个元素。在 jQuery 3.0 之前，回调函数错误地调用集合中的每一个元素并且接收所述集合中这个元素的索引位置作为参数。</p>
<p>.wrapAll()函数可以接受任何字符串或对象，可以传递给$()工厂函数来指定一个 DOM 结构。这种结构可以嵌套多层，但是最内层只能有一个元素。所有匹配元素将会被当作是一个整体，在这个整体的外部用指定的 HTML 结构进行包裹。</p>
<p>为 span 标签包裹一个对象树。注意，任何 span 之间的元素都不会被包裹，例如例子中使用的 <strong> (红色文本)。即使是 span 之间的空格也不会被包裹。可以查看原始 HTML 的源代码。</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;style&gt;

  div &#123; border:2px blue solid; margin:2px; padding:2px; &#125;
  p &#123; background:yellow; margin:2px; padding:2px; &#125;
  strong &#123; color:red; &#125;
  &lt;/style&gt;
  &lt;script src=&quot;http://code.jquery.com/jquery-latest.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;span&gt;Span Text&lt;/span&gt;
  &lt;strong&gt;What about me?&lt;/strong&gt;
  &lt;span&gt;Another One&lt;/span&gt;
&lt;script&gt;$(&quot;span&quot;).wrapAll(&quot;&lt;div&gt;&lt;div&gt;&lt;p&gt;&lt;em&gt;&lt;b&gt;&lt;/b&gt;&lt;/em&gt;&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&quot;);&lt;/script&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>3 .wrapInner()</p>
<p>注意: 当通过一个选择器字符串传递给.wrapInner() 函数，其参数应该是格式正确的 HTML，并且 HTML 标签应该是被正确关闭的。下面是一些正确的例子：</p>
<pre><code>$(elem).wrapInner(&quot;&lt;div class=&#39;test&#39; /&gt;&quot;);
$(elem).wrapInner(&quot;&lt;div class=&#39;test&#39;&gt;&lt;/div&gt;&quot;);
$(elem).wrapInner(&quot;&lt;div class=\&quot;test\&quot;&gt;&lt;/div&gt;&quot;);
</code></pre>
<h3 id="DOM-插入-内部插入"><a href="#DOM-插入-内部插入" class="headerlink" title="DOM 插入, 内部插入"></a>DOM 插入, 内部插入</h3><p>有.append()，.appendTo()，.prepend()，.prependTo()，.html()，.text()</p>
<p>1 .append()</p>
<p>.append( content [, content ] )</p>
<p>content<br>类型: String, Element, jQuery，<br>DOM 元素，文本节点，元素和文本节点的数组，HTML 字符串，或者 jQuery 对象，用来插在每个匹配元素里面的末尾。</p>
<p>content<br>类型: String, Element, Array, jQuery，<br>一个或多个 DOM 元素，文本节点，元素和文本节点的数组，HTML 字符串，或 jQuery 对象插入到每个匹配元素的末尾。</p>
<p>.append( function(index, html) )</p>
<p>function(index, html)<br>类型: Function()，<br>一个返回 HTML 字符串，DOM 元素（或多个），文本节点（或多个），jQuery 对象的函数，该字符串用来插入到匹配元素的末尾。接收 index 参数表示元素在匹配集合中的索引位置和 html 参数表示元素上原来的 HTML 内容。在函数中 this 指向元素集合中的当前元素。</p>
<p>如果一个被选中的元素被插入到另外一个地方，这是移动而不是复制。</p>
<p>和其他添加内容的方法类似， 例如.prepend() 和 .before(), .append() 还支持传递输入多个参数。支持的输入包括 DOM 元素，jQuery 对象，HTML 字符串，DOM 元素的数组。</p>
<p>.append() 可以接受任何数量的额外的参数</p>
<p><em>设计上，任何 jQuery 的构造或方法，都接受一个 HTML 字符串（作为参数） - jQuery(),.append(), .after()等 -可以潜在地执行代码。这可能会出现注入 script 标签或使用 HTML 属性执行的代码（例如，<img onload="">）。不要使用这些方法来插入来自不受信任来源的内容，如网址查询参数，Cookie 或表单输入获得的字符串。这样做可能会引起跨站点脚本（XSS）漏洞。将内容添加到文档之前删除或避免用户任何输入内容。</em></p>
<p><em>jQuery 没有正式的支持 SVG。在 SVG 文档上使用 jQuery 方法，除非该方法有明确的说明，否则可能会导致意外的行为。例如 jQuery 3.0 中支持 SVG 的方法有 addClass 和 removeClass。</em></p>
<p>2 .appendTo()</p>
<p>然而，如果有多个目标元素，插入元素的克隆副本被创建到每个目标元素，而不是只插入到最后一个目标元素，并且新的集合（原始元素加克隆元素）被返回。</p>
<p>在 jQuery 1.9 以前，追加到单个元素的情况下没有创建一个新的集合，而是返回原来的集合，当被用与数目不详的元素时，使得它难以可靠地使用.end()方法。</p>
<p>3 .prepend()</p>
<p>4 .prependTo()</p>
<p>5 .html()</p>
<p>5.1 .html()</p>
<p>这种方法使用浏览器的 innerHTML 属性。有些浏览器返回的结果可能不是原始文档的 HTML 源代码。例如，如果属性值只包含字母数字字符，Internet Explorer 有时丢弃包裹属性值的引号。</p>
<p>5.2 .html( htmlString )</p>
<p>5.3 .html( function(index, oldhtml) )</p>
<p>这个 .html() 方法对 XML 文档无效.</p>
<p>我们可以使用 .html() 来设置元素的内容，这些元素中的任何内容会完全被新的内容取代。此外，用新的内容替换这些元素前，jQuery 从子元素删除其他结构，如数据和事件处理程序。（愚人码头注：这样可以防止内存溢出。）</p>
<p>这种方法使用浏览器的 innerHTML 属性。有些浏览器可能不完全复制所提供的 HTML 源代码生成 DOM。例如，Internet Explorer 的版本 8 之前转换所有链接的 href 属性为绝对 URL 路径，和 Internet Explorer 第 9 版之前，不增加一个单独的兼容层的情况下，将无法正确处理 HTML5 元素。</p>
<p><em>要设置一个&lt;script&gt;元素的内容， 其不包含 HTML， 使用的 .text()方法，而不是.html()。所以在定义在 script 标签中的模板应该用.html()方法获取</em></p>
<p><em>注意:在 Internet Explorer 中，包括第 9 版， 设置 HTML 元素的文本内容可能会破坏其子节点的文本节点，结果导致子节点的文本节点从文档中被删除。如果你想保留这些 DOM 元素的引用，需要他们将保持不变，请使用.empty().html(string)来代替.html(string)，以便从文档中删除元素之前的元素被分配到新的字符串</em></p>
<p>6 .text()</p>
<p>6.1 .text()</p>
<p>和 .html() 方法不同， .text() 在 XML 和 HTML 文档中都能使用。.text() 方法返回一个字符串，包含所有匹配元素的合并文本。 （由于在不同的浏览器中的 HTML 解析器的变化，返回的文本中换行和其他空白可能会有所不同。）</p>
<p>.text() 方法不能使用在 input 元素或 scripts 元素上。 input 或 textarea 需要使用 .val() 方法获取或设置文本值。得到 scripts 元素的值，使用.html()方法</p>
<p>从 jQuery 1.4 开始， .text()方法返回文本内容和作为元素节点的 CDATA 节点。</p>
<p>6.2 .text( text )</p>
<p>text<br>类型: String or Number or Boolean,<br>用于设置匹配元素内容的文本。当提供的是一个数值或布尔值得时候，那么将被转换成一个字符串表现形式，提供给这个方法。</p>
<p>6.3 .text( function(index, text) )</p>
<p>function(index, text)<br>类型: Function(),<br>用来返回设置文本内容的一个函数。接收元素的索引位置和文本值作为参数。</p>
<h3 id="DOM-插入-外部插入"><a href="#DOM-插入-外部插入" class="headerlink" title="DOM 插入, 外部插入"></a>DOM 插入, 外部插入</h3><p>有.after()，.before()，.insertAfter()，.insertBefore()</p>
<p>1 .after()</p>
<p>1.1 .after( content [, content ] )</p>
<p>1.2 .after( function )</p>
<p>function 类型: Function( Integer index ) =&gt; htmlString or Element or jQuery</p>
<p>一个返回 HTML 字符串，DOM 元素（或多个），文本节点（或多个），或 jQuery 对象的函数，返回的内容用来插入到集合中每个匹配元素的后面（愚人码头注：外部插入）。 接收元素集合中该元素的索引位置作为一个参数（index 参数）。在函数中 this 指向元素集合中的当前元素。</p>
<p>1.3 .after( function-html ),1.10 版本添加</p>
<p>function 类型: Function( Integer index, String html ) =&gt; htmlString or Element or jQuery<br>一个返回 HTML 字符串，DOM 元素，jQuery 对象的函数，返回的内容用来插入到集合中每个匹配元素的后面（愚人码头注：外部插入）。接收元素集合中该元素的索引位置（愚人码头注：index 参数）和元素的原来 HTML 值（愚人码头注：html 参数）作为参数。在函数中 this 指向元素集合中的当前元素。</p>
<p><em>在此之前的 jQuery1.9， 如果该集合中的第一个节点没有在文档中， .after()将尝试添加 或 在当前的 jQuery 集合改变节点，在这种情况下返回一个新的 jQuery 集合，而不是原来的集合。该方法可能会或可能不会返回一个新的结果，这取决于它的参数个数或参数的连贯性！ 从 jQuery1.9 开始，.after(), .before(), 和 .replaceWith()总是返回原始未修改的集合。 试图在一个没有父级元素的节点上使用这些方法是没有效果的，也就是说，集合和它包含的节点都不会改变。</em></p>
<p>2 .before()</p>
<p>3 .insertAfter()</p>
<p>4 .insertBefore()</p>
<h3 id="DOM-移除"><a href="#DOM-移除" class="headerlink" title="DOM 移除"></a>DOM 移除</h3><p>有.detach()，.empty()，.remove()，.unwrap()</p>
<p>1 .detach()</p>
<p>.detach( [selector ] )，从 DOM 中去掉所有匹配的元素。</p>
<p>.detach() 方法和.remove()一样, 除了 .detach()保存所有 jQuery 数据和被移走的元素相关联。当需要移走一个元素，不久又将该元素插入 DOM 时，这种方法很有用。</p>
<p>2 .empty()</p>
<p>从 DOM 中移除集合中匹配元素的所有子节点。</p>
<p>为了避免内存泄漏，jQuery 先移除子元素的数据和事件处理函数，然后移除子元素。</p>
<p>如果你想删除元素，不破坏他们的数据或事件处理程序（这些绑定的信息还可以在之后被重新添加回来），请使用.detach()代替</p>
<p>3 .remove()</p>
<p>.remove( [selector ] )，将匹配元素集合从 DOM 中删除。</p>
<p>和 .empty()相似。.remove() 将元素移出 DOM。 当我们想将元素自身移除时我们用 .remove()，同时也会移除元素内部的一切，包括绑定的事件及与该元素相关的 jQuery 数据。要删除的元素不删除数据和事件的情况下，使用.detach()来代替。</p>
<p>4 .unwrap()</p>
<p>将匹配元素集合的父级元素删除，保留自身（和兄弟元素，如果存在）在原来的位置。</p>
<p>4.1 .unwrap()</p>
<p>4.2 .unwrap( [selector ] )，添加版本 3.0</p>
<p>selector 类型: String，<br>一个选择器，用来检查匹配的父元素。如果一个元素的父不匹配该选择器，该元素将不会被解开。 (愚人码头注：该签名官网还未提供示例，可以查看我写的简单示例：<a target="_blank" rel="noopener" href="http://jsbin.com/rufaqu/edit?html,css,js,output">http://jsbin.com/rufaqu/edit?html,css,js,output</a>)</p>
<p>.unwrap()删除元素的父级元素。和 .wrap()的功能相反。匹配的元素（以及他们的兄弟元素，如果有的话）取代他们的父母在 DOM 结构。</p>
<h3 id="DOM-替换"><a href="#DOM-替换" class="headerlink" title="DOM 替换"></a>DOM 替换</h3><p>有.replaceAll()，.replaceWith()</p>
<p>1 .replaceAll()</p>
<p>.replaceAll( target )，用集合的匹配元素替换每个目标元素。</p>
<p>.replaceAll() 方法会删除与节点相关联的所有数据和事件处理程序 。</p>
<p>2 .replaceWith()</p>
<p>.replaceWith()方法，和大部分其他 jQuery 方法一样，返回 jQuery 对象，所以可以和其他方法链接使用， 但是需要注意的是： （original）原始 jQuery 对象被返回。该对象指向已经从 DOM 中被移除的对象，而不是指向已经取代了它的新元素。</p>
<h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><h3 id="筛选"><a href="#筛选" class="headerlink" title="筛选"></a>筛选</h3><p>有.eq(),.filter(),.first(),.has(),.is(),.last(),.map(),.not(),.slice()</p>
<p>1 .eq()</p>
<p>.eq( index ),支持负值，负值从最后一个元素倒数</p>
<p>2 .first()</p>
<p>3 .last()</p>
<p>4 .has()</p>
<p>.has( selector )</p>
<p>.has( contained )</p>
<p>contained<br>类型: Element，<br>用于匹配元素的 DOM 元素。</p>
<p>5 .is()</p>
<p>5.1 .is( selector )</p>
<p>5.2 .is( function(index) )</p>
<p>5.3 .is( jQuery object )</p>
<p>5.4 .is( element )</p>
<p>6 .filter()</p>
<p>参数种类同上</p>
<p>7 .not()</p>
<p>从匹配的元素集合中移除指定的元素。参数同理</p>
<p>8 .map()</p>
<p>.map( callback(index, domElement) )</p>
<p>如果你想处理一个简单的数组或对象中，使用 jQuery.map()代替。</p>
<p>由于返回值是一个 jQuery 包裹的数组，所以通常会使用 get()方法将其转换成普通的数组。</p>
<p>.map()方法特别适用于获取或设置元素集合中的值,如下获取一组 checkbox 的值</p>
<pre><code>$(&#39;:checkbox&#39;).map(function() &#123;
  return this.id;
&#125;).get().join();
</code></pre>
<p>在回调函数中，this 指向每次迭代中的当前 DOM 元素。该函数可以返回一个单独的数据或数据数组，并在结果集合中插入。如果数组返回，数组中的元素插入到集合。如果函数返回 null 或 undefined ，没有元素将被插入。</p>
<p>将一组 div 等高：</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;style&gt;
div &#123; width: 40px; float:left; &#125;
input &#123; clear:left&#125;
  &lt;/style&gt;
  &lt;script src=&quot;http://code.jquery.com/jquery-latest.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;


&lt;input type=&quot;button&quot; value=&quot;equalize div heights&quot;&gt;

&lt;div style=&quot;background:red; height: 40px; &quot;&gt;&lt;/div&gt;
&lt;div style=&quot;background:green; height: 70px;&quot;&gt;&lt;/div&gt;
&lt;div style=&quot;background:blue; height: 50px; &quot;&gt;&lt;/div&gt;


&lt;script&gt;
$.fn.equalizeHeights = function() &#123;
  var maxHeight = this.map(function(i,e) &#123; //this为实例，即jquery对象
    return $(e).height();
  &#125;).get();

  return this.height( Math.max.apply(this, maxHeight) );
&#125;;

$(&#39;input&#39;).click(function()&#123;
  $(&#39;div&#39;).equalizeHeights();
&#125;);

&lt;/script&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>9 .slice()</p>
<p>.slice( start [, end ] )</p>
<p>根据指定的下标范围，过滤匹配的元素集合，并生成一个新的 jQuery 对象。</p>
<p>jQuery 的.slice()方法是仿照的 JavaScript 数组的.slice()方法。其中的一个功能就是允许传入负的 start 和 end 参数。如果传递的是负数，那么下标位置是从结尾开始的，而不是从起始位置开始。</p>
<h3 id="各种遍历"><a href="#各种遍历" class="headerlink" title="各种遍历"></a>各种遍历</h3><p>.add()，.contents()，.each()，.end()</p>
<p>1 .add()</p>
<p>创建一个新的 jQuery 对象 ，元素添加到匹配的元素集合中。</p>
<p>1.1 .add( selector )</p>
<p>1.2 .add( elements )</p>
<p>1.3 .add( html )</p>
<p>1.4 .add( jQuery object )</p>
<p>1.5 .add( selector, context )</p>
<p>2 .contents()</p>
<p>获得匹配元素集合中每个元素的子元素，包括文字和注释节点。</p>
<p>给定一个 jQuery 对象，表示一个 DOM 元素的集合，.contents()方法允许我们通过 DOM 树中查找集合中的直接子元素，并根据匹配的元素创建一个新的 jQuery 对象。.contents()和.children()方法类似，只不过前者包括文本节点和注释节点，以及 jQuery 对象中产生的 HTML 元素。请注意，虽然这种方式可以传递文本节点和注释节点给一个 jQuery 集合，但是大多数操作不会支持他们。少数几个支持的操作将在他们的 API 文档页面中有一个明确的说明。</p>
<p>如果 iframe 与主页同域，.contents()方法也可用于获取 iframe 中的文件内容。</p>
<p>3 .each()</p>
<p>遍历一个 jQuery 对象，为每个匹配元素执行一个函数。</p>
<p>我们可以通过返回 false 以便在回调函数内中止循环。</p>
<p>注意: jQuery 的方法，返回一个 jQuery 对象遍历 jQuery 集合中的元素 - 被称为隐式迭代的过程。当这种情况发生时，它通常不需要显式地循环的.each()方法：</p>
<p>4 .end()</p>
<p>终止在当前链的最新过滤操作，并返回匹配的元素的以前状态。</p>
<p>大多数 jQueryDOM 遍历 方法来操作 jQuery 对象实例，并创建一个新的对象，匹配一个不同的 DOM 元素集合。当发生这种情况时，实际上是新的元素集合被压入到对象内部维护的栈中。每次过滤方法都会被压入栈中。当我们需要返回到前一个状态时，我们可以使用 end() 进行出栈操作，来返回栈中的前一个状态。</p>
<h3 id="树遍历"><a href="#树遍历" class="headerlink" title="树遍历"></a>树遍历</h3><p>有.addBack()，.children()，.find()，.closest()，.parent()，.parents()，.parentsUntil()，.next()，.nextAll()，.nextUntil()，.prev()，.prevAll()，.prevUntil()，.siblings()</p>
<p>1 .addBack()</p>
<p>.addBack( [selector ] )</p>
<p>添加堆栈中元素集合到当前集合，一个选择性的过滤选择器。</p>
<p>如上所述在讨论中的.end()， jQuery 对象维护一个堆栈内部来跟踪匹配的元素集合的变化。当一个 DOM 遍历方法被调用时，新的元素集合推入到堆栈中。 如果还需要包含先前的元素集合，.addBack() 可以提供帮助。</p>
<pre><code>$(&#39;li.third-item&#39;).nextAll().addBack()
</code></pre>
<p>.css(‘background-color’, ‘red’);</p>
<p>2 .children()</p>
<p>.children()方法允许我们通过在 DOM 树中对这些元素的直接子元素进行搜索，并且构造一个新的匹配元素的 jQuery 对象。.find()和.children()方法是相似的，但后者只是针对向下一个级别的 DOM 树。还要注意的是和大多数的 jQuery 方法一样，.children()不返回文本节点;让所有子元素包括使用文字和注释节点，建议使用.contents()。</p>
<p>3 .find()</p>
<p>.find( selector )</p>
<p>.find( element ) 元素或 jQuery 对象</p>
<p>4 .closest()</p>
<p>从元素本身开始，在 DOM 树上逐级向上级元素匹配，并返回最先匹配的祖先元素。</p>
<p>.parents()和.closest()方法类似，它们都在 DOM 树遍历了。两者之间的差异，尽管细微，是重要的：</p>
<ul>
<li>.closest()开始于当前元素，.parents()开始于父元素</li>
<li>.closest()在 DOM 树中向上遍历，直到找到与提供的选择器相匹配的元素，.parents()向上遍历 DOM 树到文档的根元素，每个祖先元素加入到临时集合，如果提供一个选择器，则会使用该选择器在集合中进行过滤</li>
<li>.closest()返回包含零个或一个元素的 jQuery 对象，.parents()返回包含零个，一个或多个元素的 jQuery 对象</li>
</ul>
<p>5 .parent()</p>
<p>6 .parents()</p>
<p>.parents()和.parent()方法是相似的，但后者只是进行了一个单级的 DOM 树查找（愚人码头注：也就是只查找一层，直接的父元素，而不是更加上级的祖先元素）。此外，$( “html” ).parent()方法返回一个包含document的集合，而$( “html” ).parents()返回一个空集合。</p>
<p>7 ..parentsUntil()</p>
<p>8 .next()</p>
<p>9 .nextAll()</p>
<p>10 .nextUntil()</p>
<p>11 .prev()</p>
<p>12 .prevAll()</p>
<p>13 .prevUntil()</p>
<p>14 .siblings()</p>
<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><h3 id="浏览器事件"><a href="#浏览器事件" class="headerlink" title="浏览器事件"></a>浏览器事件</h3><p>1 .resize()</p>
<p>1.1 .resize( handler(eventObject) )</p>
<p>1.2 .resize( [eventData ], handler(eventObject) )</p>
<p>1.3 .resize()</p>
<p>这个函数的前两个用法是 .bind(‘resize’, handler) 的快捷方式，第 3 个不带参数的用法是 .trigger(‘resize’) 的快捷方式。</p>
<p>当浏览器 window 的尺寸改变时，window 元素上绑定的 resize 事件将被触发</p>
<p>2 .scroll()</p>
<p>当用户在元素内执行了滚动操作，就会在这个元素上触发 scroll 事件。它适用于 window 对象，但也可以是可滚动 frames 与 CSS overflow 属性设置为 scroll 的元素（或 auto 时，元素的显示高度小于其内容高度）</p>
<p>每当元素的滚动位置的变化时，该元素就会触发 scroll 事件，不管什么原因。鼠标点击或拖动滚动条，拖动里面的元素，按箭头键，或使用鼠标的滚轮都可能导致触发此事件。</p>
<h3 id="文档加载"><a href="#文档加载" class="headerlink" title="文档加载"></a>文档加载</h3><p>1 jQuery.holdReady()</p>
<p>暂停或恢复.ready() 事件的执行。</p>
<p>jQuery.holdReady( hold )</p>
<p>hold 类型: Boolean</p>
<p>指示是否暂停或恢复被请求的 ready 事件</p>
<p>在$.holdReady()方法允许调用者延迟 jQuery 的 ready 事件。这种先进的功能，通常会被用来允许在 ready 事件发生之前，动态加载其它的 JavaScript，例如 jQuery 插件，即使 DOM 可能已经准备就绪。该方法必须在文档早期被调用，例如，在 <head> 中加载完 jQuery 脚本之后，立刻调用该方法。如果在 ready 事件已经被调用后再调用该方法，将不会起作用。</p>
<p>为了延迟 ready 事件，首先要调用 $.holdReady(true)，当 ready 事件准备执行时，再调用 $.holdReady(false) 。注意，在 ready 事件中可以设置多个 hold。每一个都对应一次 $.holdReady(true) 调用。直到所有的 hold 都被释放，也就是调用了对应数量的 $.holdReady(false)之后，并且满足正常的文档 ready 条件时，ready 事件才会被真正执行。（见 ready 的更多信息。）)</p>
<pre><code>$.holdReady(true);
$.getScript(&quot;myplugin.js&quot;, function() &#123;
  $.holdReady(false);
&#125;);
</code></pre>
<p>2 .ready()</p>
<p>当 DOM 准备就绪时，指定一个函数来执行。</p>
<p>大多数浏览器提供了 DOMContentLoaded 事件形式的类似功能。 然而，jQuery 的 .ready() 方法的不同之处在于它是一个重要并且有效的方法：在代码调用.ready( handler )之前，如果 DOM 已经准备就绪并且浏览器已经触发 DOMContentLoaded，handler 处理函数仍然会被执行。 相反，如果 DOMContentLoaded 事件侦听器在这个事件触发后才被添加进来，那么这个 DOMContentLoaded 事件的处理程序将永远不会被执行。</p>
<p>浏览器还提供了 window 对象上的 load 事件。当这个事件触发时候，表明该网页上的所有资源已加载，包括图像。此事件可以使用 jQuery 的$( window ).on( “load”, handler )监听。当代码依赖加载的资源情况下，（例如，必需知道图像的尺寸时），那么代码应放置在一个 load 事件的处理程序中。</p>
<p>值得注意的是，虽然 DOM 准备就绪（ready）总是在页面被完全加载之前，但是在已经生效执行的 .ready() 处理程序代码中绑定 load 事件侦听器，通常是不安全的。例如，在页面加载后，可以使用一些方法动态加载脚本，如$.getScript() 。虽然动态加载的脚本中的 .ready() 处理程序始终会被执行， 但是在动态加载脚本中的 window 的 load 事件已经触发过了，所以那些 load 事件监听器将永远不会运行。</p>
<p>jQuery 提供了几种方法来绑定函数，当 DOM 已准备就绪时，绑定的函数将会运行。在 jQuery 3.0 中，只建议使用第一种语法（愚人码头注：即 $( handler )）; 其他语法仍然能正常工作，但已被标记为弃用（愚人码头注：将来的某个版本会被删除）。$(document).on( “ready”, handler ),从 jQuery 1.8 开始已被标记为弃用，在 jQuery 3.0 中已经被删除。请注意。</p>
<p>当$快捷方式不再可用时，$.noConflict()可以用于避免命名空间冲突。然而，传递给.ready() 的处理函数可以传递一个引用 jQuery 对象的参数。这使得处理程序中能够使用 jQuery 对象，例如，用作$,这样就可以不用关心它的别名：</p>
<pre><code>jq2 = jQuery.noConflict();
jq2(function( $ ) &#123;
  // 在这个代码块中可以像往常一样使用 $ ;实际的jQuery 对象是 jq2
&#125;);
</code></pre>
<h3 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h3><p>1 .bind()</p>
<p>在 jQuery 3.0 中，.bind()已被标记为弃用。从 jQuery 1.7 开始，.on() 方法是将事件处理程序绑定到文档（document）的首选方法。所以我们不建议使用该方法。</p>
<p>2 .delegate()</p>
<p>在 jQuery 3.0 中，.delegate()已被标记为弃用。从 jQuery 1.7 开始，它已经被.on()方法取代。所以我们不建议使用该方法。</p>
<p>3 .on()</p>
<p>3.1 .on( events [, selector ] [, data ], handler(eventObject) )</p>
<p>events<br>类型: String，<br>一个或多个空格分隔的事件类型和可选的命名空间，或仅仅是命名空间，比如”click”, “keydown.myPlugin”, 或者 “.myPlugin”。</p>
<p>selector<br>类型: String，<br>一个选择器字符串，用于过滤出被选中的元素中能触发事件的后代元素。如果选择器是 null 或者忽略了该选择器，那么被选中的元素总是能触发事件。，</p>
<p>data<br>类型: Anything，<br>当一个事件被触发时，要传递给事件处理函数的 event.data。</p>
<p>handler(eventObject)<br>类型: Function()，<br>事件被触发时，执行的函数。若该函数只是要执行 return false 的话，那么该参数位置可以直接简写成 false。</p>
<p>3.2 .on( events [, selector ] [, data ] )</p>
<p>events<br>类型: PlainObject，<br>一个对象，键是由一个或多个由空格分隔的事件类型及可选的名字空间，值是这些事件类型所对应的事件处理函数。</p>
<p>selector<br>类型: String，<br>一个选择器字符串，用于过滤出被选中的元素中能触发事件的后代元素。如果选择器是 null 或者忽略了该选择器，那么被选中的元素总是能触发事件。</p>
<p>data<br>类型: Anything，<br>当一个事件被触发时，要传递给事件处理函数的 event.data。</p>
<p>（1）Event names and namespaces（事件名称和命名空间）</p>
<p>事件名称可以添加指定的 event namespaces（命名空间） 来简化删除或触发事件。例如，”click.myPlugin.simple”为 click 事件同时定义了两个命名空间 myPlugin 和 simple。通过上述方法绑定的 click 事件处理，可以用.off(“click.myPlugin”) 或 .off(“click.simple”)删除绑定到相应元素的 Click 事件处理程序，而不会干扰其他绑定在该元素上的“click（点击）” 事件。命名空间类似 CSS 类，因为它们是不分层次的;只需要有一个名字相匹配即可。以下划线开头的名字空间是供 jQuery 使用的。</p>
<p>在.on()方法的第二种用法中，events 参数是一个 JavaScript 对象或者键值对。键等同于 events 参数，用空格分隔的事件名称字符串和可选命名空间。每个键的值是一个函数（或 false 的值），相当于 handler 参数，但是该值并不是方法中的最后一个参数。在其它方面，这两种形式在下面描述的内容中其行为都是相同的。</p>
<p>（2）Direct and delegated events（直接和委托的事件）</p>
<p>除了可以给未创建的后代元素绑定事件外，代理事件的另一个好处就是，当需要监视很多元素的时候，代理事件的开销更小。</p>
<p>注意: 委托事件不能用于 SVG.</p>
<p>（3）The event handler and its environment（事件处理程序和它的环境）</p>
<p>默认情况下，大多数事件的冒泡从最初的 event target（目标元素） 开始的，直到 document 元素。每个元素都沿着 DOM 层级这条路，jQuery 会调用任何匹配的已被绑定的事件处理程序。一个处理程序可以调用的 event.stopPropagation()防止事件向上冒泡文档树（从而防止这些元素的处理程序运行）。任何绑定到当前元素上的其他处理程序都将运行，为了防止这种情况，可以调用 event.stopImmediatePropagation()。（绑定在元素上的事件被调用的顺序和它们被绑定的顺序时一样的。 ）</p>
<p>类似地，一个处理程序可以调用的 event.preventDefault()取消浏览器默认操作行为。</p>
<p>调用 event.stopPropagation() 和 event.preventDefault()会从一个事件处理程序会自动返回 false。也可以直接将 false 当作 handler 的参数，作为 function(){ return false; } 的简写形式。</p>
<p>当 jQuery 的调用处理程序时，this 关键字指向的是当前正在执行事件的元素。对于直接事件而言，this 代表绑定事件的元素。对于代理事件而言，this 则代表了与 selector 相匹配的元素。(注意，如果事件是从后代元素冒泡上来的话，那么 this 就有可能不等于 event.target。)若要使用 jQuery 的相关方法，可以根据当前元素创建一个 jQuery 对象，即使用 $(this)。</p>
<p>（4） Passing data to the handler（将数据传递到处理程序）</p>
<p>如果 data 参数给.on()并且不是 null 或者 undefined，那么每次触发事件时，event.data 都传递给处理程序。data 参数可以是任何类型，但如果是字符串类型时，那么 selector 参数必须提供，或明确地传递 null，这样的 data 参数不会误认为是选择器。最好是使用一个对象（键值对） ，所以可以作为属性传递多个值。</p>
<p>jQuery 的 1.4 以后 ，相同的事件处理程序可以多次绑定到一个元素。这对于使用 event.data 功能，或者在闭包中使用唯一的数据时是特别有用的。例如：</p>
<pre><code>function greet( event ) &#123;
  alert( &quot;Hello &quot; + event.data.name );
&#125;
$( &quot;button&quot; ).on( &quot;click&quot;, &#123;
  name: &quot;Karl&quot;
&#125;, greet );
$( &quot;button&quot; ).on( &quot;click&quot;, &#123;
  name: &quot;Addy&quot;
&#125;, greet );
</code></pre>
<p>按一下按钮时，上面的代码会产生两个不同的警告（alert）。</p>
<p>除了可以向 .on() 方法传入 data 参数外，还可以向 .trigger() 或 .triggerHandler() 中传入该参数。 这种方式提供数据（Data）被传递给事件处理程序的 Event 对象内，作为进一步的参数。 如果传递给.trigger() 和 .triggerHandler()的第二个参数是一个数组， 数组中的每个元素将作为事件处理程序的单独参数。</p>
<p>（5）Event performance（事件性能）</p>
<p>对于高频率事件，可以按如下的办法提高事件的性能：</p>
<ul>
<li>减少事件处理函数中的工作量；</li>
<li>对于在事件处理函数中要用到的信息做好缓存而不是再重新计算一次；</li>
<li>或使用 setTimeout 限制的页面更新的实际次数。</li>
</ul>
<p>为了获得更好的性能，在绑定代理事件时，绑定的元素最好尽可能的靠近目标元素。避免在大型文档中，过多的在 document 或 document.body 上添加代理事件。</p>
<p>若代理事件的选择器使用了过于复杂的形式，特别是使用了分层选择器的情况，虽然说这样做会大大的降低性能，但是对于大多数应用而言，它的速度依然是足够快的。通过为寻找更合适的元素绑定事件的方法，就可以很简单的避免使用分层选择器的情况。</p>
<p>（6）Additional notes（其他注意事项）</p>
<p>虽然不建议，伪类事件名称”hover”可以作为”mouseenter mouseleave”的缩写使用。不要与 接受两个函数的.hover()方法混淆，这里只用一个处理函数绑定到伪类事件名称”hover”;处理程序应该检查的 event.type 以确定是否是 mouseenter 或 mouseleave 事件。</p>
<p>jQuery 的事件系统需要一个 DOM 元素可以通过元素的属性附加数据，使事件就可以被跟踪和传递。object, embed, 和 applet 元素不能绑定数据，因此不能有 jQuery 的事件绑定。</p>
<p>W3C 指定明确指定 focus 和 blur 事件没有冒泡，但是 jQuery 定义的跨浏览器的 focusin 和 focusout 事件，并且可以冒泡。当 focus 和 blur 绑定委派的事件处理程序时，jQuery 分析名称，并提供将他们分别交付给 focusin 和 focusout。为了保持一致性和清晰度，使用冒泡事件类型的名称。</p>
<p>在所有的浏览器，load ，scroll, 和 error 事件(例如, 在一个 <img> 元素上)不会冒泡。在 Internet Explorer 8 和更低，paste 和 reset 事件不会冒泡，这样的事件是不支持委派使用，但若事件处理函数是直接绑定在产生事件的元素上的话，是可以使用这些事件的。</p>
<p>window 对象上的 error 事件使用非标准的参数和返回值约定，所以 jQuery 不支持该事件。作为替代，直接用 window.onerror 属性分配一个处理函数。</p>
<p>当事件被首次触发时，处理函数列表才会被设置到元素上。当前元素上添加或删除事件处理函数不会立即生效，直到下一次的事件被处理。 为了避免任何后续事件处理函数在一个元素的事件处理函数中执行，调用 event.stopImmediatePropagation() 这种行为违反了<a target="_blank" rel="noopener" href="https://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-EventTarget-removeEventListener">W3C 的事件规范</a>。 为了更好地了解这种情况下，考虑下面的代码：</p>
<pre><code>var $test = $( &quot;#test&quot; );

function handler1() &#123;
  console.log( &quot;handler1&quot; );
  $test.off( &quot;click&quot;, handler2 );
&#125;

function handler2() &#123;
  console.log( &quot;handler2&quot; );
&#125;

$test.on( &quot;click&quot;, handler1 );
$test.on( &quot;click&quot;, handler2 );
</code></pre>
<p>在上面的代码，handler2 第一次无论如何都会被执行，即使使用.off()删除。 然而，该处理函数在下一次 click 事件被触发时将不执行。（愚人码头注：查看代码运行效果：<a target="_blank" rel="noopener" href="http://jsfiddle.net/feiwen8772/dgxru81d/%EF%BC%89">http://jsfiddle.net/feiwen8772/dgxru81d/）</a></p>
<p>（7）一些事例</p>
<p>传递一个数组给.trigger()的事件处理程序，作为第二个参数。</p>
<pre><code>$( &quot;div&quot; ).on( &quot;click&quot;, function( event, salutation, name ) &#123;
  alert( salutation + &quot;, &quot; + name );
&#125;);
$( &quot;div&quot; ).trigger( &quot;click&quot;, [ &quot;Goodbye&quot;, &quot;Jim&quot; ] );
</code></pre>
<p>添加并触发自定义事件（非浏览器事件）。</p>
<pre><code>&lt;!doctype html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;utf-8&quot;&gt;
  &lt;title&gt;on demo&lt;/title&gt;
  &lt;style&gt;
  p &#123;
    color: red;
  &#125;
  span &#123;
    color: blue;
  &#125;
  &lt;/style&gt;
  &lt;script src=&quot;//code.jquery.com/jquery-1.10.2.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;p&gt;Has an attached custom event.&lt;/p&gt;
&lt;button&gt;Trigger custom event&lt;/button&gt;
&lt;span style=&quot;display:none;&quot;&gt;&lt;/span&gt;

&lt;script&gt;
$( &quot;p&quot; ).on( &quot;myCustomEvent&quot;, function( event, myName ) &#123;
  $( this ).text( myName + &quot;, hi there!&quot; );
  $( &quot;span&quot; )
    .stop()
    .css( &quot;opacity&quot;, 1 )
    .text( &quot;myName = &quot; + myName )
    .fadeIn( 30 )
    .fadeOut( 1000 );
&#125;);
$( &quot;button&quot; ).click(function () &#123;
  $( &quot;p&quot; ).trigger( &quot;myCustomEvent&quot;, [ &quot;John&quot; ] );
&#125;);
&lt;/script&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>使用 对象 同时添加多个事件处理函数。</p>
<pre><code>$( &quot;div.test&quot; ).on(&#123;
  click: function() &#123;
    $( this ).toggleClass( &quot;active&quot; );
  &#125;, mouseenter: function() &#123;
    $( this ).addClass( &quot;inside&quot; );
  &#125;, mouseleave: function() &#123;
    $( this ).removeClass( &quot;inside&quot; );
  &#125;
&#125;);
</code></pre>
<p>在同一个元素上绑定多个事件，一个 mouseenter 和 mouseleave：</p>
<pre><code>$( &quot;#cart&quot; ).on( &quot;mouseenter mouseleave&quot;, function( event ) &#123;
  $( this ).toggleClass( &quot;active&quot; );
&#125;);
</code></pre>
<p>4 .off()</p>
<p>5 .one()</p>
<p>6 .trigger()</p>
<pre><code>$(&#39;#foo&#39;).on(&#39;custom&#39;, function(event, param1, param2) &#123;
  alert(param1 + &quot;\n&quot; + param2);
&#125;);
$(&#39;#foo&#39;).trigger(&#39;custom&#39;, [&#39;Custom&#39;, &#39;Event&#39;]);
</code></pre>
<p>注意: 对于非 window 的普通的对象和 DOM 对象， 如果一个触发事件名称和对象的一个属性名称相匹配， 如果事件处理程序没有调用 event.preventDefault()，jQuery 将尝试调用属性的方法。 如果不希望这种行为发生，请使用.triggerHandler() 来代替。（愚人码头注 .triggerHandler() 方法并不会触发事件的默认行为。）</p>
<p>注意: 和.triggerHandler()一样， 当调用.trigger()时，当一个事件名称匹配对象上属性名称时，属性名称会加上 on 前缀（如，在 具有非空 onclick 方法的 window 上触发 click）， jQuery 将尝试调用该属性作为方法。</p>
<p>注意: 当通过一个普通的对象不是类数组触发时 但仍然包含了 length 属性， 你应该传递对象到数组中（例如：[ { length: 1 } ]）。</p>
<p>7 .triggerHandler()</p>
<p>这个方法的行为与 .trigger() 相似，不同之处有如下几点：</p>
<ul>
<li><p>.triggerHandler( “event” )方法被触发时不会调用元素上的 .event()。 这意味着在表单上触发 .triggerHandler( “submit” )将不会调用表单上的.submit()。（愚人码头注：可以理解为.triggerHandler() 方法并不会触发事件的默认行为。(例如，表单提交)。）</p>
</li>
<li><p>.trigger() 会影响所有与 jQuery 对象相匹配的元素，而 .triggerHandler() 仅影响第一个匹配到的元素。</p>
</li>
<li><p>使用 .triggerHandler() 触发的事件，并不会在 DOM 树中向上冒泡。 如果它们不是由目标元素直接触发的，那么它就不会进行任何处理。<br>与普通的方法返回 jQuery 对象(这样就能够使用链式用法)相反，.triggerHandler()返回最后一个处理的事件的返回值。如果没有触发任何事件，会返回 undefined。</p>
</li>
</ul>
<p>8 .unbind()</p>
<p>在 jQuery 3.0 中，.unbind()已被标记为弃用。从 jQuery 1.7 开始，它已经被.off()方法取代。所以我们不建议使用该方法。</p>
<p>9 .undelegate()</p>
<p>在 jQuery 3.0 中，.undelegate()已被标记为弃用。从 jQuery 1.7 开始，它已经被.off()方法取代。所以我们不建议使用该方法。</p>
<h3 id="表单事件"><a href="#表单事件" class="headerlink" title="表单事件"></a>表单事件</h3><p>1 .blur()</p>
<p>一个元素失去焦点将触发 blur 事件。起初，这个事件仅适用于表单元素，如元素<input> 。在最新的浏览器中，这个事件适用范围已经扩大到包括所有元素类型。一个元素可以通过键盘命令失去焦点，比如 tab 键，或用鼠标点击网页上的其他地方。</p>
<p>应用不带参数的.blur()，我们可以手动触发这个事件:</p>
<p>2 .change()</p>
<p>一个元素的值改变的时候将触发 change 事件。此事件仅限用于<input>元素，<textarea>和<select>元素。对于下拉选择框，复选框和单选按钮，当用户用鼠标作出选择，该事件立即触发，但对于其他类型的 input 元素，该事件触发将推迟，直到元素失去焦点才会触发。</p>
<p>注意: 使用 JavaScript 改变输入元素的值，例如使用.val()，将不会触发该事件。</p>
<p>3 .focus()</p>
<p>当一个元素获得焦点时，focus 事件被触发。此事件起初适用于有限的元素，比如表单元素（<input>, <select>等）和链接元素（<a href>）。在最近版本的浏览器中，该事件可以扩展到所有包括通过显式设置 tabindex 属性的元素类型。一个元素可以通过键盘命令获得焦点，如 Tab 键，或按鼠标点击的元素。</p>
<p>试图将焦点设置到一个隐藏的元素在 Internet Explorer 中导致错误。请注意，.focus()只能在可见元素上使用。要在一个元素执行 focus 事件却又不想让这个元素获取焦点的话， 请使用.triggerHandler(“focus”) 来代替 .focus()。</p>
<p>focus 事件不会在 Internet Explorer 中冒泡。因此，用 focus 事件委派，跨浏览器无法正常工作。但是，在 1.4.2 版本， jQuery 的解决此限制，将 focus 模拟为 focusin 事件</p>
<p>4 .select()</p>
<p>当用户在一个元素中进行文本选择时，这个元素上的 select 事件就会被触发。此事件只能用在<input type="text"> 和<textarea>。</p>
<p>用于检索当前选定文本的方法在各个浏览器中是不同的。jQuery 的一个插件都提供跨平台的解决方案。</p>
<p>5 .submit()</p>
<p>当用户试图提交表单时，就会在这个表单元素上触发 submit 事件。它只能绑定在<form>元素上。以下几种情况会导致表单被提交：用户点击了<input type="submit">, <input type="image">, 或者 <button type="submit">，或者当某些表单元素获取焦点时，敲击 Enter（回车键），都可以提交。</p>
<p>根据不同的浏览器，Enter 键可能会导致表单被提交，如果这个表单只有一个文本框或只有一个 submit 按钮的话。界面不应该依赖于这个键的特殊行为，除非已经使用了 keypress 事件来监听 Enter 键的按下。</p>
<p>我们可以通过调用事件对象的.preventDefault()或在处理函数中返回 false 来取消提交：</p>
<p>在 Internet Explorer 中，JavaScript 的 submit 事件不会冒泡。但是，依赖 submit 事件代理的脚本，从 jQuery 1.4 开始，可以跨浏览器正常使用。</p>
<h3 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件"></a>键盘事件</h3><p>1 .keydown()</p>
<p>当用户在一个元素上按下键盘上的键的时候，keydown 事件就会发送给这个元素。 如果按下该键不放（保持按下状态），事件被重复发送到该键，时间间隔取决于操作系统。它可以绑定到任何元素，但该事件只是发送到具有焦点的元素上。不同的浏览器中，可获得焦点的元素略有不同，但是表单元素总是能获取焦点，所以对于此事件类型表单元素是最合适的。</p>
<p>如果需要任何按键被捕获（例如，要实现网页全局上的快捷键），那么把这个事件附加到 document 对象上是非常有用的。所有的按键事件都会沿着各自的 DOM 树冒泡到 document 对象上，除非明确停止。</p>
<p>要确定哪个键被按下，我们可以检测传递给处理函数的 event 对象。而浏览器使用不同的属性来存储这些信息，jQuery 的规范了.which 属性，以便我们能够可靠地使用它来检索关键代码。此代码对应一个键盘上的按键，包括像方向键这种特殊键的代码，如果要捕获实际输入文本， .keypress()可能是一个更好的选择。</p>
<p>2 .keypress()</p>
<p>注意:：由于 keypress 事件没有统一的官方规范说明，所以在不同的浏览器，不同的浏览器版本，和不同的平台实际使用这个事件时可能遇到的问题。</p>
<p>当浏览器捕获一个元素上键盘输入时，keypress 就会发送个元素。这是类似 keydown 事件，除了当按键被一直按下（即连续插入字符的场合）时的处理。如果用户按下并按住这个键（不松开释放）的时候，keydown 事件只触发一次，但是 keypress 会在每个字符插入的时候都会触发事件。此外，组合键（如 Shift）会触发 keydown 事件，但不会触发 keypress 事件。</p>
<p>值得注意的是 keydown 和 keyup 提供一个代码，表示哪一个键被按下，而 keypress 表示被输入哪个字符。例如，按下了小写的 “a”，在 keydown 和 keyup 中，对应该键的代码是 65，但是对于 keypress 而言，接收到的代码是 97。如果是大写 “A” 的话，则所有的相关事件接收到的代码都是 65。由于这个区别，若想捕获敲击了哪个特殊键的话，例如，方向键，使用 .keydown()或.keyup() 更好。</p>
<p>在文本框中按下某个键时，显示 event 对象。注意：输出 event 对象时，要依赖一个简单的 $.print() 插件 (<a target="_blank" rel="noopener" href="http://api.jquery.com/scripts/events.js)%E3%80%82">http://api.jquery.com/scripts/events.js)。</a></p>
<p>3 .keyup()</p>
<h3 id="鼠标事件"><a href="#鼠标事件" class="headerlink" title="鼠标事件"></a>鼠标事件</h3><p>1 .click()</p>
<p>2 .contextmenu()</p>
<p>当在一个元素上点击鼠标的右键时,contextmenu 事件被发送到这个元素上,但在显示的上下文菜单(右键菜单)之前。 这时上下文菜单键被按下，该事件在 html 元素上被触发。 任何 HTML 元素都可以接受此事件。</p>
<p>3 .dblclick()</p>
<p>在同一元素上同时绑定 click 和 dblclick 事件是不可取的。各个浏览器事件触发的顺序是不同的，一些浏览器在 dblclick 之前接受两个 click 事件 ，而和其它浏览器只接受一个 click 事件。用户往往可通过不同的操作系统和浏览器配置双击灵敏度（两次点击之间的最大时间被检测为双击）</p>
<p>4 .focusin()</p>
<p>focusin 事件会在元素（或者其内部的任何元素）获得焦点时触发。这跟 focus 事件的显著区别在于，它可以在父元素上检测子元素获得焦点的情况(换而言之，它支持事件冒泡)。</p>
<p>5 .focusout()</p>
<p>focusout 事件会在元素（或者其内部的任何元素）失去焦点时触发。这跟 blur 事件的显著区别在于，它可以在父元素上检测子元素失去焦点的情况(换而言之，它支持事件冒泡)。</p>
<p>6 .hover()</p>
<p>.hover()方法是同时绑定 mouseenter 和 mouseleave 事件</p>
<p>7 .mousedown()</p>
<p>任何鼠标按钮被按下时 mousedown 事件就会被发送。若要区分是哪个键被按下了，我们可以使用 event 对象的 which 属性。并非所有浏览器都支持这个属性（在 IE 中，要使用 button 属性来代替），但是 jQuery 对该属性进行了标准化，因此你可以放心的在任何浏览器中使用该属性。敲击鼠标左键 which 的值是 1，敲击鼠标中键 which 的值是 2，敲击鼠标右键 which 的值是 3。</p>
<p>此事件主要用于确保主要按钮是用来开始拖动操作;如果不进行这样的判断，当用户尝试使用上下文菜单，可能会出现奇怪的结果。虽然可以通过这些属性，来检测鼠标中键和右键的点击，但不一定是可靠的。例如，在 Opera 和 Safari 中，默认情况下是无法检测鼠标右键的点击的。</p>
<p>如果在一个元素按住了鼠标不放，并且拖动鼠标离开这个元素，并释放鼠标键，这仍然是算作 mousedown 事件。在大多数的用户界面，这个动作的顺序被视为一个“取消”的按键，所以通常最好使用 click 事件，除非我们知道 mousedown 事件针对一个特定情况较好。</p>
<p>8 .mouseup()</p>
<p>9 .mouseenter()</p>
<p>mouseenter 事件和 mouseover 的不同之处是事件的冒泡的方式。如果 mouseover 在这个例子中使用了，然后当鼠标指针在 Inner 元素上移动，该处理程序将被触发。这通常是不受欢迎的行为。另一方面, mouseenter 事件只会在绑定它的元素上被调用，而不会在后代节点上被触发。</p>
<p>10 .mouseleave()</p>
<p>mouseleave 事件和 mouseover 的不同之处是事件的冒泡的方式。如果 mouseover 在这个例子中使用了，然后当鼠标指针在 Inner 元素上移出，该处理程序将被触发。这通常是不受欢迎的行为。另一方面, mouseleave 事件只会在绑定它的元素上被调用，而不会在后代节点上被触发</p>
<p>11 .mousemove()</p>
<p>当跟踪鼠标移动时，我们通常需要知道实际的鼠标指针的位置。event 对象传递给处理程序包含了一些有关鼠标的坐标信息。比如.clientX, .offsetX, 和 .pageX 属性是有效的，但对他们的支持不同浏览器。幸运的是，jQuery 的规范了.pageX 和.pageY 属性，以便他们能够在所有浏览器上使用。这些属性提供了鼠标指针位置相对于页面的左上角的 X 和 Y 坐标。</p>
<p>我们必须记住， mousemove 事件是当鼠标指针移动时触发的，即使是一个像素。这意味着多个事件在短时间内被触发。如果处理器做任何重大的处理，或者如果该事件存在多个处理函数，这可能造成浏览器的严重的性能问题。因此，优化 mousemove 处理程序尽可能，这一点很重要，当不再需要他们时应尽快解除绑定。</p>
<p>一个常见的模式是在 mousedown 处理器内部绑定 mousemove 处理器，并在一个相应 mouseup 处理函数解除绑定。要实现这一系列事件，请记住，与 mouseup 事件相比，mouseup 事件可能会被发送到不同的 HTML 元素上。由于这个原因，mouseup 事件通常应该绑定在更高的 DOM 树中，例如 <body>。</p>
<p>12 .mouseout()</p>
<p>由于此事件类型冒泡，可能导致引起的很多头痛的问题。例如，在这个例子中当鼠标指针移出 Inner 元素，mouseout 事件将被发送到 Inner 元素，然后冒泡到 Outer 元素 。这可能会不合时宜的触发绑定的 mouseout 处理函数。这可以用一个替代方法，见讨论. mouseleave ()。</p>
<p>13 .mouseover()</p>
<p>由于此事件类型冒泡，可能导致引起的很多头痛的问题。例如，在这个例子中当鼠标指针移出 Inner 元素，mouseover 事件将被发送到 Inner 元素，然后冒泡到 Outer 元素 。这可能会不合时宜的触发绑定的 mouseover 处理函数。这可以用一个替代方法，见讨论. mouseenter ()。</p>
<h3 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h3><p>1 event.currentTarget</p>
<p>在事件冒泡过程中的当前 DOM 元素。</p>
<p>这个属性总是等于函数的 this。</p>
<p>如果您使用 jQuery.proxy 或另一种形式操作作用域，this 将等于您所提供的 context（上下文），而不是 event.currentTarget</p>
<p>2 event.target</p>
<p>target 属性可以是注册事件时的元素，或者它的子元素。通常用于比较 event.target 和 this 来确定事件是不是由于冒泡而触发的。经常用于事件冒泡时处理事件委托。</p>
<p>3 event.relatedTarget</p>
<p>在事件中涉及的其它任何 DOM 元素。</p>
<p>对于 mouseout 事件，它指向被进入的元素；对于 mouseover 事件，它指向被离开的元素。</p>
<p>4 event.data</p>
<p>当当前正在执行的处理程序绑定时，一个可选的数据对象传递给一个事件方法。</p>
<p>5 event.type</p>
<p>6 event.timeStamp</p>
<p>通过在代码中获得两个点之间的 event.timeStamp 值，并给出差值来分析事件的性能，此属性是很有用的。如果只是要确定当前的时间内的事件处理程序，使用(new Date).getTime()来代替。</p>
<p>7 event.which</p>
<p>event.which 将 event.keyCode 和 event.charCode 标准化了。推荐用 event.which 来监视键盘输入。更多细节请参阅： event.charCode on the MDN.</p>
<p>event.which 也将正常化的按钮按下(mousedown 和 mouseupevents)，左键报告 1，中间键报告 2，右键报告 3。使用 event.which 代替 event.button。</p>
<p>8 event.namespace</p>
<p>当事件被触发时此属性包含指定的命名空间。</p>
<p>这属性主要提供给插件作者用来处理的不同任务，具体取决于事件使用的命名空间。</p>
<p>9 event.result</p>
<p>事件被触发的一个事件处理程序的最后返回值，除非值是 undefined。</p>
<p>此属性当获取自定义事件前一个返回值时非常有用的。</p>
<p>10 event.pageX</p>
<p>11 event.pageY</p>
<p>12 event.isDefaultPrevented()</p>
<p>13 event.isImmediatePropagationStopped()</p>
<p>14 event.isPropagationStopped()</p>
<p>15 event.stopImmediatePropagation()</p>
<p>阻止剩余的事件处理函数执行并且防止事件冒泡到 DOM 树上。</p>
<p>16 event.stopPropagation()</p>
<h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p>1 .hide()</p>
<p>1.1 .hide()</p>
<p>1.2 .hide( [duration ] [, complete ] )</p>
<p>duration (默认: 400)<br>类型: Number or String，<br>一个字符串或者数字决定动画将运行多久。</p>
<p>complete<br>类型: Function()，<br>在动画完成时执行的函数。</p>
<p>1.3 .hide( [duration ] [, easing ] [, complete ] )</p>
<p>1.4 .hide( options )</p>
<p>options<br>类型: PlainObject，<br>一组包含动画选项的值的集合。 支持的选项：</p>
<p>duration (default: 400)</p>
<p>easing (default: swing)，jQuery 自身提供”linear” 和 “swing”，其他效果可以使用<a target="_blank" rel="noopener" href="http://gsgd.co.uk/sandbox/jquery/easing/">jQuery Easing Plugin</a>插件）</p>
<p>queue (default: true)<br>Type: Boolean or String,<br>一个布尔值，指示是否将动画放置在效果队列中。如果为 false 时，将立即开始动画。 从 jQuery1.7 开始，队列选项也可以接受一个字符串，在这种情况下，在动画被添加到由该字符串表示的队列中。当一个自定义的队列名称被使用，动画不会自动启动;你必须调用.dequeue(“queuename”)来启动它。</p>
<p>specialEasing,<br>Type: PlainObject,<br>一组一个或多个通过相应的参数和相对简单函数定义的 CSS 属性 ( 1.4 新增)</p>
<p>step,<br>Type: Function( Number now, Tween tween ),<br>每个动画元素的每个动画属性将调用的函数。这个函数为修改 Tween 对象提供了一个机会来改变设置中得属性值。</p>
<p>progress,<br>Type: Function( Promise animation, Number progress, Number remainingMs ),<br>每一步动画完成后调用的一个函数，无论动画属性有多少，每个动画元素都执行单独的函数。 (version added: 1.8)</p>
<p>complete,<br>Type: Function(),<br>在动画完成时执行的函数。</p>
<p>done<br>Type: Function( Promise animation, Boolean jumpedToEnd )<br>在动画完成时执行的函数。 (他的 Promise 对象状态已完成). (version added: 1.8)</p>
<p>fail<br>Type: Function( Promise animation, Boolean jumpedToEnd )<br>动画失败完成时执行的函数。(他的 Promise 对象状态未完成)。 (version added: 1.8)</p>
<p>always<br>Type: Function( Promise animation, Boolean jumpedToEnd )<br>在动画完成或未完成情况下停止时执行的函数。(他的 Promise 对象状态已完成或未完成)。 (version added: 1.8)</p>
<p><em>所有 jQuery 效果，包括.hide(),都能通过设置 jQuery.fx.off = true 全局的关闭，效果等同于持续时间设置为 0。更多信息查看 jQuery.fx.off</em></p>
<p>2 .show()</p>
<p>注意: 如果使用!important 在你的样式中，比如 display: none !important，如果你希望.show()方法才能正常工作，必须使用.css(‘display’, ‘block !important’)重写样式。</p>
<p>3 .toggle()</p>
<p>3.1 .toggle( [duration ] [, complete ] )</p>
<p>3.2 .toggle( options )</p>
<p>3.3 .toggle( [duration ] [, easing ] [, complete ] )</p>
<p>3.4 .toggle(display)</p>
<p>display<br>类型: Boolean,<br>一个布尔值，使用 true 来显示元素，或者 false 隐藏它.</p>
<p>注意: 事件处理套件也有一个名为.toggle()方法(.toggle( handler(eventObject), handler(eventObject) [, handler(eventObject) ] ),在 1.8 被宣布过时，1.9 已删除),哪一个被调用取决于传递的参数的设置。</p>
<h3 id="自定义"><a href="#自定义" class="headerlink" title="自定义"></a>自定义</h3><p>1 .animate()</p>
<p>.animate()方法允许我们在任意的数值的 CSS 属性上创建动画。唯一必要的属性就是一组 CSS 属性键值对。这组属性和用于设置.css()方法的属性键值对类似，除了属性范围做了更多限制。</p>
<p>所有用于动画的属性必须是数字的，除非另有说明；这些属性如果不是数字的将不能使用基本的 jQuery 功能。（例如，width, height 或者 left 可以执行动画，但是 background-color 不能，除非使用 jQuery.Color 插件。）属性值的单位像素（px）,除非另有说明。单位 em 和 %需要指定使用。</p>
<p>除了样式属性， 一些非样式的属性，如 scrollTop 和 scrollLeft，以及自定义属性，也可应用于动画。</p>
<p>CSS 简写属性（例如 font, background, border）没有得到充分的支持。例如， 如果你想边框宽度做动画呈现，至少边框样式和边框宽度必须预先设定不为”auto” 。或者，如果你想字体大小做动画， 你可以使用 fontSize 的或相当于 CSS 的 ‘font-size’ ，而不是简单的’font’。</p>
<p>除了定义数值，每个属性能使用’show’, ‘hide’, 和 ‘toggle’。这些快捷方式允许定制隐藏和显示动画用来控制元素的显示或隐藏。为了使用 jQuery 内置的切换状态跟踪，’toggle’关键字必须在动画开始前给定属性值。（愚人码头注：jquery 中有两个.toggle()方法，一个是显示或隐藏匹配元素。另一个是绑定两个或多个处理程序绑定到匹配的元素，用来执行在交替的点击。哪一个被调用取决于传递的参数的设置。所以这里’toggle’关键字必须在动画开始前给定属性值，以确认调用哪个’toggle’方法。）</p>
<p>动画属性也可以是一个相对值。如果提供一个以+= 或 -=开始的值，那么目标值就是以这个属性的当前值加上或者减去给定的数字来计算的。</p>
<p><em>注意: 不同于动画的简便方法，比如.slideDown() 和 .fadeIn(),.animate()方法不会影响隐藏元素的可见性部分的效果。例如，给定$(‘someElement’).hide().animate({height:’20px’}, 500)，动画将执行，但该元素将保持隐藏。</em><br>$(‘#clickme’).click(function() {<br>$(‘#book’).animate({<br>opacity: 0.25,<br>left: ‘+=50’,<br>height: ‘toggle’<br>}, 5000, function() {<br>// Animation complete.<br>});<br>});</p>
<p>Step Function</p>
<p>第二个版本的.animate()提供了一个 step 选项- 每步动画执行后调用的回调函数。启用自定义动画类型或改变正在执行的动画，此功能是非常有用。它接受两个参数（now 和 fx），this 是当前正在执行动画的 DOM 元素集合。</p>
<p>now: 每一步动画属性的数字值</p>
<p>fx: jQuery.fx 原型对象的一个引用，其中包含了多项属性，比如 elem 表示前正在执行动画的元素，start 和 end 分别为动画属性的第一个和最后一个的值，prop 为进行中的动画属性。</p>
<p>需要注意的是 step 函数被每个动画元素的每个动画属性调用。例如，给定两个列表项，step 函数会被激发四次：</p>
<pre><code>$(&#39;li&#39;).animate(&#123;
  opacity: .5,
  height: &#39;50%&#39;
&#125;,
&#123;
  step: function(now, fx) &#123;
    var data = fx.elem.id + &#39; &#39; + fx.prop + &#39;: &#39; + now;
    $(&#39;body&#39;).append(&#39;&lt;div&gt;&#39; + data + &#39;&lt;/div&gt;&#39;);
  &#125;
&#125;);
</code></pre>
<p>Per-property Easing</p>
<pre><code>$(&#39;#clickme&#39;).click(function() &#123;
  $(&#39;#book&#39;).animate(&#123;
    width: [&#39;toggle&#39;, &#39;swing&#39;],
    height: [&#39;toggle&#39;, &#39;swing&#39;],
    opacity: &#39;toggle&#39;
  &#125;, 5000, &#39;linear&#39;, function() &#123;
      $(this).after(&#39;&lt;div&gt;Animation complete.&lt;/div&gt;&#39;);
  &#125;);
&#125;);
</code></pre>
<p>在.animate()的第二个版本中，选项对象能包含 specialEasing 属性，该属性本身是一组 CSS 属性与相应的缓冲函数。例如，我们可以同时的使用 linear 缓冲函数来做 width 动画，并且用 easeOutBounce 缓冲函数来做 height 动画：</p>
<pre><code>$(&#39;#clickme&#39;).click(function() &#123;
  $(&#39;#book&#39;).animate(&#123;
    width: &#39;toggle&#39;,
    height: &#39;toggle&#39;
  &#125;, &#123;
    duration: 5000,
    specialEasing: &#123;
      width: &#39;linear&#39;,
      height: &#39;easeOutBounce&#39;
    &#125;,
    complete: function() &#123;
      $(this).after(&#39;&lt;div&gt;Animation complete.&lt;/div&gt;&#39;);
    &#125;
  &#125;);
&#125;);
</code></pre>
<p>2 .delay()</p>
<p>.delay( duration [, queueName ] )</p>
<p>设置一个延时来推迟执行队列中后续的项。</p>
<p>queueName<br>类型: String,<br>一个作为队列名的字符串。默认是动画队列 fx。标准的效果队列。</p>
<p><em>.delay()是用来在 jQuery 动画效果和类似队列中是最好的。但是，由于其本身的限制，比如无法取消延时,.delay()，它不是 JavaScript 的原生 setTimeout 函数的替代品，这可能是更适合某些使用情况。</em></p>
<p>3 .queue()</p>
<p>显示或操作匹配的元素上已经执行的函数列队。</p>
<p>3.1 .queue( [queueName ] )</p>
<p>3.2 .queue( [queueName ], newQueue )</p>
<p>3.3 .queue( [queueName ], callback( next ) )</p>
<p>显示列队的长度: $div.queue(“fx”).length</p>
<p>值得注意的是，当使用.queue()添加一个函数的时候，我们应该保证在函数最后调用了 jQuery.dequeue()，这样就能让队列中的其它函数按顺序执行。</p>
<p>从 jQuery 1.4 开始，向队列中追加函数时，可以向该函数中传入另一个函数，作为第一个参数。当调用函数时，会自动从函数队列中弹出下一个项目，保证队列中函数的继续进行。我们可以像下面这样使用：</p>
<pre><code>$(&quot;#test&quot;).queue(function(next) &#123;
    // Do some stuff...
    next();
&#125;);
</code></pre>
<p>4 .dequeue()</p>
<p>执行匹配元素队列的下一个函数。</p>
<p>.dequeue( [queueName ] )</p>
<p>当.dequeue()被调用的时候，列队中的下一个函数将从这个列队中被移除，然后再执行。这个执行的函数中也应当直接或间接的包含 .dequeue()语句，这样才能继续执行队列中的其它函数，所以,这个序列可以继续。</p>
<p>5 jQuery.queue()</p>
<p>6 jQuery.dequeue()</p>
<p>7 jQuery.fx.interval</p>
<p>此属性在 3.0 版本中已经标记为弃用， 并在支持 requestAnimationFrame 方法的浏览器中没有效果。</p>
<p>对于不支持 requestAnimationFrame 的浏览器，该属性可以被改变，以调整动画将运行的时间间隔。默认为 13 毫秒。</p>
<p>由于 jQuery 中，该属性是全局性的，因此在没有动画正在运行或停止所有动画时，此属性的变化才能生效。</p>
<p>8 jQuery.fx.off</p>
<p>当这个属性设置为 true 的时候，调用时所有动画方法将立即设置元素为他们的最终状态，而不是显示效果。有时候确实有必要这样做：</p>
<p>jQuery 是被用在低资源设备。</p>
<p>动画使用户遇到可访问性问题(查看这篇文章获得更多信息 Turn Off Animation)。</p>
<p>动画可以通过设置这个属性为 false 重新打开</p>
<p>9 .stop()</p>
<p>9.1 .stop( [clearQueue ] [, jumpToEnd ] )</p>
<p>clearQueue (默认: false)<br>类型: Boolean，<br>一个布尔值，指示是否取消列队动画。默认 false.</p>
<p>jumpToEnd (默认: false)<br>类型: Boolean，<br>一个布尔值指示是否当前动画立即完成。默认 false.</p>
<p>9.2 .stop( [queue ] [, clearQueue ] [, jumpToEnd ] )</p>
<p>当一个元素调用.stop()，当前正在运行的动画（如果有的话）立即停止。</p>
<p>如果同一元素调用多个动画方法，尚未被执行的动画被放置在元素的效果队列中。这些动画不会开始，直到第一个完成。当调用.stop()的时候，队列中的下一个动画立即开始。如果 clearQueue 参数提供 true 值,那么在队列中的动画其余被删除并永远不会运行。</p>
<p>如果提供 jumpToEnd 参数，并且值为 true 时，当前动画将停止，但该元素上的 CSS 属性会被立刻修改成动画的目标值。</p>
<p>当我们需要对元素做 mouseenter 和 mouseleave 动画时，.stop()方法明显是有效的：</p>
<p>10 .finish()</p>
<p>停止当前正在运行的动画，删除所有排队的动画，并完成匹配元素所有的动画</p>
<p>.finish( [queue ] )</p>
<p>当.finish()在一个元素上被调用，立即停止当前正在运行的动画和所有排队的动画（如果有的话），并且他们的 CSS 属性设置为它们的目标值（愚人码头注：就是所有动画的目标值）。所有排队的动画将被删除。</p>
<p>.finish()方法和.stop(true, true)很相似，.stop(true, true)将清除队列，并且目前的动画跳转到其最终值。但是，不同的是，.finish() 会导致所有排队的动画的 CSS 属性跳转到他们的最终值。</p>
<p>.stop(true, true)等于.clearQueue().finish();</p>
<h3 id="渐变"><a href="#渐变" class="headerlink" title="渐变"></a>渐变</h3><p>.fadeIn()</p>
<p>.fadeOut()</p>
<p>.fadeTo()</p>
<p>.fadeToggle()</p>
<h3 id="滑动"><a href="#滑动" class="headerlink" title="滑动"></a>滑动</h3><p>.slideDown()</p>
<p>.slideToggle()</p>
<p>.slideUp()</p>
<h2 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h2><h3 id="全局-Ajax-事件处理程序"><a href="#全局-Ajax-事件处理程序" class="headerlink" title="全局 Ajax 事件处理程序"></a>全局 Ajax 事件处理程序</h3><p>这些方法用于注册事件处理器，用来处理页面上的任何 Ajax 请求，当某些事件触发后，这些事件处理器被调用。如何 jQuery.ajaxSetup() 中的 global 属性被设置为 true （这也是默认设置），那么，每个 Ajax 请求都会触发全局事件。注意：全局事件绝对不会被跨域（cross-domain）脚本或 JSONP 请求触发，和 global 属性的设置毫无关系。</p>
<p>1 .ajaxStart()</p>
<p>在 AJAX 请求刚开始时执行一个处理函数</p>
<p><em>在 jQuery1.9 中，jQuery 全局 AJAX 事件的所有处理程序， 包括那些.ajaxStart()添加的方法，必须 附加到 document 上。</em></p>
<p><em>如果 $.ajax() 或 $.ajaxSetup()调用时， global 选项设置为 false， .ajaxStart()将不会触发。</em></p>
<p>2 .ajaxSend()</p>
<p>在 Ajax 请求发送之前绑定一个要执行的函数</p>
<p>无论哪一个 Ajax 请求被发送，所有 ajaxSend 处理器都将被执行。如果我们必须区分不同的请求,我们可以使参数传递给这个处理器。 每次 ajaxSend 处理器执行，它传递事件对象，jqXHR 对象（在 jQuery 1.4 中是 XMLHttpRequest 对象），和用来创建请求的设置（settings object）对象。如果请求失败，因为 JavaScript 抛出一个异常，并且作为第四个参数的异常对象被传递给处理程序。举个例子,我们能限制我们的回调到只处理事件处理某一特定的 URL:</p>
<pre><code>$(document).ajaxSend(function(event, jqxhr, settings) &#123;
  if ( settings.url == &quot;ajax/test.html&quot; ) &#123;
    $( &quot;.log&quot; ).text( &quot;Triggered ajaxSend handler.&quot; );
  &#125;
&#125;);
</code></pre>
<p>3 .ajaxStop()</p>
<p>在 AJAX 请求完成时执行一个处理函数。</p>
<p>每当一个 Ajax 请求完成，jQuery 检查是否有任何其他响应过程中的 Ajax 请求（愚人码头注：未完成的请求）。如果都执行完成，jQuery 就会触发 ajaxStop 事件，在这个时间点所有处理函数都会使用.ajaxStop()方法注册并执行。如果一个未处理完成的 Ajax 请求用 beforeSend 回调函数返回 false 取消，ajaxStop 事件也被触发</p>
<p>4 .ajaxSuccess()</p>
<p>绑定一个函数当 Ajax 请求成功完成时执行</p>
<p>.ajaxSuccess( handler(event, XMLHttpRequest, ajaxOptions) )</p>
<p>5 .ajaxError()</p>
<p>Ajax 请求出错时注册一个回调处理函数</p>
<p>.ajaxError( handler(event, jqXHR, ajaxSettings, thrownError) )</p>
<p>6 .ajaxComplete()</p>
<p>当 Ajax 请求完成后注册一个回调函数</p>
<p>每当一个 Ajax 请求完成，jQuery 就会触发 ajaxComplete 事件，在这个时间点所有处理函数会使用.ajaxComplete()方法注册并执行。</p>
<h3 id="辅助函数"><a href="#辅助函数" class="headerlink" title="辅助函数"></a>辅助函数</h3><p>1 jQuery.param()</p>
<p>创建一个数组，一个普通的对象，或一个 jQuery 对象的序列化表示形式，用于 URL 查询字符串或 Ajax 请求。 如果传递一个 jQuery 对象传递，它应该包含输入元素（愚人码头注：input，textarea 等）的名称/值属性。</p>
<p>1.1 jQuery.param( obj )</p>
<p>obj<br>类型: Array 或 PlainObject 或 jQuery，<br>一个用来序列化的一个数组，一个普通的对象，或一个 jQuery 对象。</p>
<p>1.2 jQuery.param( obj, traditional )</p>
<p>traditional<br>类型: Boolean，<br>一个布尔值，指示是否执行了传统的“shallow”的序列化。</p>
<p>在 jQuery 1.4 中, $.param() 方法将会通过深度递归的方式序列化对象，以便符合现代化脚本语言和框架的需求，比如 PHP 和 Ruby on Rails。 你可以通过设置 jQuery.ajaxSettings.traditional = true;废除这个全局功能。</p>
<p>在 jQuery 3.0 中，$.param()方法，不再使用 jQuery.ajaxSettings.traditional 作为其默认设置，将默认为 false。对于最好的跨版本兼容性，调用 $.param()时传递明确的值给第二个参数，不使用默认值。</p>
<p>如果传递的对象是一个数组，它必须是一个对象数组，其格式要跟.serializeArray()返回的格式一样：</p>
<pre><code>[
  &#123; name: &quot;first&quot;, value: &quot;Rick&quot; &#125;,
  &#123; name: &quot;last&quot;, value: &quot;Astley&quot; &#125;,
  &#123; name: &quot;job&quot;, value: &quot;Rock Star&quot; &#125;
]
</code></pre>
<p><em>因为一些框架解析序列化的数字的能力有限， 在传递 obj 参数时我们应该谨慎，尽量不要传递含有对象的数组，或者数组中嵌套其它数组。</em></p>
<p><em>由于目前对序列化字符串没有统一的规约，此方法无法对复杂数据结构进行编码，使之可以支持所有语言。在此之前，$.param 方法将继续保持其目前的形式。</em></p>
<p>2 .serialize()</p>
<p>将用作提交的表单元素的值编译成字符串。</p>
<p>注意: 只有 “successful controls”可以被序列化成字符串。其中，提交按钮的值不会被序列化。另外，如果想要一个表单元素的值被序列化成字符串，这个元素必须含有 name 属性。此外，复选框（checkbox）和单选按钮（radio）(input 类型为 “radio” 或 “checkbox”)的值只有在被选中时才会被序列化。另外，文件选择元素的数据也不会被序列化。</p>
<pre><code>$(&quot;form&quot;).serialize();
</code></pre>
<p>3 .serializeArray()</p>
<p>将用作提交的表单元素的值编译成拥有 name 和 value 对象组成的数组。例如[ { name: a value: 1 }, { name: b value: 2 },…]</p>
<p>.serializeArray()方法使用标准的 W3C”successful controls”的标准来检测哪些元素应当包括在内。被禁用的元素不会被包括在内。并且,元素必须含有 name 属性。此外，提交按钮的值也不会被序列化。文件选择元素的数据也不会被序列化。</p>
<h3 id="底层接口"><a href="#底层接口" class="headerlink" title="底层接口"></a>底层接口</h3><p>1 jQuery.ajax()</p>
<p>jQuery 最复杂的一个 API，因为参数实在是太多了。</p>
<p>1.1 jQuery.ajax( url [, settings ] )</p>
<p>1.2 jQuery.ajax( [settings ] )</p>
<p>settings</p>
<p>类型: PlainObject</p>
<p>一个以”{键:值}”组成的 AJAX 请求设置。所有选项都是可选的。可以使用$.ajaxSetup()设置任何默认参数。</p>
<p>1）accepts (默认: 取决于数据类型)</p>
<p>类型: PlainObject</p>
<p>一个键/值对集合映射给定的 dataType 到其的 MIME 类型，它可以从发送 Accept 请求头信息中获得。</p>
<p>请求头信息通知服务器该请求需要接收何种类型的返回结果。 例如，下面定义一个自定义类型的 mycustomtype 与请求一起发送：</p>
<pre><code>$.ajax(&#123;
  accepts: &#123;
    mycustomtype: &#39;application/x-some-custom-type&#39;
  &#125;,

  // Instructions for how to deserialize a `mycustomtype`
  converters: &#123;
    &#39;text mycustomtype&#39;: function(result) &#123;
      // Do Stuff
      return newresult;
    &#125;
  &#125;,

  // Expect a `mycustomtype` back from server
  dataType: &#39;mycustomtype&#39;
&#125;);
</code></pre>
<p>注意: 对于这种类型，为了使其正常工作，您将需要在 converters 中指定补充项。</p>
<p>2）async (默认: true)</p>
<p>跨域请求和 dataType: “jsonp” 请求不支持同步操作。</p>
<p>3）beforeSend</p>
<p>类型: Function( jqXHR jqXHR, PlainObject settings )<br>请求发送前的回调函数，用来修改请求发送前 jqXHR（在 jQuery 1.4.x 的中，XMLHttpRequest）对象，此功能用来设置自定义 HTTP 头信息，等等。在 beforeSend 函数中返回 false 将取消这个请求</p>
<p>4）cache (默认: true, dataType 为”script”和”jsonp”时默认为 false)</p>
<p>如果设置为 false ，浏览器将不缓存此页面。注意: 设置 cache 为 false 将在 HEAD 和 GET 请求中正常工作。它的工作原理是在 GET 请求参数中附加”_={timestamp}”（译者注：时间戳）。该参数不是其他请求所必须的，除了在 IE8 中，当一个 POST 请求一个已经用 GET 请求过的 URL。</p>
<p>5）complete</p>
<p>6）contents</p>
<p>类型: PlainObject，<br>一个以”{字符串/正则表达式}”配对的对象，根据给定的内容类型，解析请求的返回结果。 (1.5 新增)</p>
<p>7）contentType (default: ‘application/x-www-form-urlencoded; charset=UTF-8’)</p>
<p>从 jQuery 1.6 开始，你可以传递 false 来告诉 jQuery，没有设置任何内容类型头信息。 注意：W3C 的 XMLHttpRequest 的规范规定，数据将总是使用 UTF-8 字符集传递给服务器；指定其他字符集无法强制浏览器更改编码。 注意:对于跨域请求，内容类型设置为 application/x-www-form-urlencoded, multipart/form-data, 或 text/plain 以外， 将触发浏览器发送一个预检 OPTIONS 请求到服务器。</p>
<p>8）context</p>
<p>类型: Object</p>
<p>这个对象用于设置 Ajax 相关回调函数的上下文。 默认情况下，这个上下文是一个 ajax 请求使用的参数设置对象。比如指定一个 DOM 元素作为 context 参数，这样就设置了 complete 回调函数的上下文为这个 DOM 元素。</p>
<pre><code>$.ajax(&#123;
  url: &quot;test.html&quot;,
  context: document.body
&#125;).done(function() &#123;
  $(this).addClass(&quot;done&quot;);
&#125;);
</code></pre>
<p>9)converters (默认: {“* text”: window.String, “text html”: true, “text json”: jQuery.parseJSON, “text xml”: jQuery.parseXML})</p>
<p>类型: PlainObject</p>
<p>一个数据类型到数据类型转换器的对象。每个转换器的值是一个函数，返回经转换后的请求结果</p>
<p>10)crossDomain (默认: 同域请求为 false， 跨域请求为 true</p>
<p>如果你想在同一域中强制跨域请求（如 JSONP 形式），例如，想服务器端重定向到另一个域，那么需要将 crossDomain 设置为 true 。</p>
<p>11)data</p>
<p>类型: PlainObject 或 String 或 Array</p>
<p>发送到服务器的数据。它被转换成一个查询字符串,如果已经是一个字符串的话就不会转换。查询字符串将被追加到 GET 请求的 URL 后面。参见 processData 选项说明，以防止这种自动转换。对象必须为”{键:值}”格式。如果这个参数是一个数组，jQuery 会按照 traditional 参数的值， 将自动转化为一个同名的多值查询字符串(查看下面的说明)。愚人码头注：如 {foo:[“bar1”, “bar2”]} 转换为 ‘&amp;foo=bar1&amp;foo=bar2’。</p>
<p>12)dataFilter</p>
<p>类型: Function( String data, String type ) =&gt; Anything</p>
<p>一个函数被用来处理 XMLHttpRequest 的原始响应数据。这是一个预过滤功能，净化响应。您应该返回安全数据。提供 data 和 type 两个参数：data 是 Ajax 返回的原始数据，type 是调用 jQuery.ajax 时提供的 dataType 参数。</p>
<p>13)dataType (default: Intelligent Guess (xml, json, script, or html))</p>
<p>从服务器返回你期望的数据类型。 如果没有指定，jQuery 将尝试通过 MIME 类型的响应信息来智能判断（一个 XML MIME 类型就被识别为 XML，在 1.4 中 JSON 将生成一个 JavaScript 对象，在 1.4 中 script 将执行该脚本，其他任何类型会返回一个字符串）。</p>
<p>可用的类型（以及结果作为第一个参数传递给成功回调函数）有：</p>
<ul>
<li><p>xml 返回 XML 文档</p>
</li>
<li><p>html 返回纯文本 HTML 文本；包含的 script 标签会在插入 DOM 时执行。</p>
</li>
<li><p>script 把响应的结果当作 JavaScript 执行，并将其当作纯文本返回。默认情况下会通过在 URL 中附加查询字符串变量 _=[TIMESTAMP]， 禁用缓存结果，除非设置了 cache 参数为 true。注意: 在远程请求时(不在同一个域下)，所有 POST 请求都将转为 GET 请求。(愚人码头注：因为将使用 DOM 的 script 标签来加载)</p>
</li>
<li><p>json 把响应的结果当作 JSON 执行，并返回一个 JavaScript 对象。跨域”json” 请求转换为”jsonp”，除非该请求在其请求选项中设置了 jsonp:false。JSON 数据以严格的方式解析; 任何畸形的 JSON 将被拒绝，并且抛出解析错误信息。在 jQuery1.9 中，一个空响应也将被拒绝;服务器应该返回 null 或 {}响应代替。（见<a target="_blank" rel="noopener" href="http://json.org/">json.org</a>的更多信息，正确的 JSON 格式。）</p>
</li>
<li><p>jsonp 以 JSONP 的方式载入 JSON 数据块。会自动在所请求的 URL 最后添加”?callback=?”。默认情况下会通过在 URL 中附加查询字符串变量 _=[TIMESTAMP]， 禁用缓存结果，除非设置了 cache 参数为 true。</p>
</li>
<li><p>text 返回纯文本字符串</p>
</li>
</ul>
<p>多个用空格分割的值:从 jQuery 1.5 开始， jQuery 可以内容类型（Content-Type）头收到并转换一个您需要的数据类型。例如，如果你想要一个文本响应为 XML 处理，使用”text xml”数据类型。您也可以将一个 JSONP 的请求，以文本形式接受，并用 jQuery 以 XML 解析: “jsonp text xml”。同样地可以使用”jsonp xml”简写,首先会尝试从 jsonp 到 xml 的转换，如果转换失败，就先将 jsonp 转换成 text, 然后再由 text 转换成 xml。</p>
<p>14)error</p>
<p>类型: Function( jqXHR jqXHR, String textStatus, String errorThrown )</p>
<p>如果发生了错误，错误信息（第二个参数）除了得到 null 之外，还可能是”timeout”, “error”, “abort” ，和 “parsererror”。 当一个 HTTP 错误发生时，errorThrown 接收 HTTP 状态的文本部分，比如： “Not Found”（没有找到） 或者 “Internal Server Error.”（服务器内部错误）。 从 jQuery 1.5 开始, 在 error 设置可以接受函数组成的数组。每个函数将被依次调用。 注意：此处理程序在跨域脚本和 JSONP 形式的请求时不被调用。</p>
<p>15)global (默认: true)</p>
<p>16)headers (默认: {})</p>
<p>一个额外的”{键:值}”对映射到请求一起发送。此设置会在 beforeSend 函数调用之前被设置 ;因此，请求头中的设置值，会被 beforeSend 函数内的设置覆盖 。</p>
<p>17)ifModified (默认: false)</p>
<p>只有上次请求响应改变时，才允许请求成功。使用 HTTP 包 Last-Modified 头信息判断。默认值是 false，忽略 HTTP 头信息。</p>
<p>18)isLocal (默认: 取决于当前的位置协议)</p>
<p>允许当前环境被认定为“本地”，（如文件系统），即使 jQuery 默认情况下不会这么做。以下协议目前公认为本地：file, *-extension, and widget。如果 isLocal 设置需要修改，建议在$.ajaxSetup()方法中这样做一次。</p>
<p>19)jsonp</p>
<p>在一个 JSONP 请求中重写回调函数的名字。这个值用来替代在”callback=?”这种 GET 或 POST 请求中 URL 参数里的”callback”部分，比如{jsonp:’onJsonPLoad’}会导致将”onJsonPLoad=?”传给服务器。在 jQuery 1.5，，设置 jsonp 选项为 false，阻止了 jQuery 从加入”?callback”字符串的 URL 或试图使用”=?”转换。在这种情况下，你也应该明确设置 jsonpCallback 设置。例如, { jsonp: false, jsonpCallback: “callbackName” }。如果你不信任你的 Ajax 请求的目标，出于安全原因， 考虑 设置 jsonp 属性为 false。</p>
<p>20)jsonpCallback</p>
<p>类型: String, Function</p>
<p>为 jsonp 请求指定一个回调函数名。这个值将用来取代 jQuery 自动生成的随机函数名。这主要用来让 jQuery 生成一个独特的函数名，这样管理请求更容易，也能方便地提供回调函数和错误处理。你也可以在想让浏览器缓存 GET 请求的时候，指定这个回调函数名。从 jQuery 1.5 开始，你也可以使用一个函数作为该参数设置，在这种情况下，该函数的返回值就是 jsonpCallback 的结果。</p>
<p>21)method (default: ‘GET’)</p>
<p>HTTP 请求方法 (比如：”POST”, “GET “, “PUT”)。 (添加版本: 1.9.0)。（愚人码头注：如果你使用 jQuery 1.9.0 之前的版本，你需要使用 type 选项。）</p>
<p>22)mimeType</p>
<p>一个 mime 类型用来覆盖 XHR 的 MIME 类型。</p>
<p>23)password</p>
<p>用于响应 HTTP 访问认证请求的密码</p>
<p>24)processData (默认: true)</p>
<p>默认情况下，通过 data 选项传递进来的数据，如果是一个对象(技术上讲只要不是字符串)，都会处理转化成一个查询字符串，以配合默认内容类型 “application/x-www-form-urlencoded”。如果要发送 DOM 树信息或其它不希望转换的信息，请设置为 false。</p>
<p>25)scriptCharset</p>
<p>仅适用于当”script”传输使用时（例如，跨域的”jsonp”或 dataType 选项为”script” 和 “GET”类型）。请求中使用在 script 标签上设置 charset 属性。通常只在本地和远程的内容编码不同时使用。</p>
<p>26)statusCode (默认: {})</p>
<p>一个 HTTP 响应状态码 和 当请求响应相应的状态码时执行的函数 组成的对象。例如： 下面的代码将在 http 响应状态码为 404 时弹出“page not found”。</p>
<pre><code>$.ajax(&#123;
  statusCode: &#123;
    404: function() &#123;
      alert(&quot;page not found&quot;);
    &#125;
  &#125;
&#125;);
</code></pre>
<p>如果请求成功，响应状态代码对应的函数会带着 success 回调函数相同的参数；如果请求结果是错误的（包含 3xx 之类的重定向），他们会采用 error 回调函数相同的参数。</p>
<p>27)success</p>
<p>28)timeout</p>
<p>设置请求超时时间（毫秒）。此设置将覆盖$.ajaxSetup() 里的全局设置。</p>
<p>29)traditional</p>
<p>如果你想要用传统的方式来序列化数据，那么就设置为 true。请参考工具分类下面的 jQuery.param 方法.</p>
<p>30)type (默认: ‘GET’)</p>
<p>method 选项的别名。如果你使用 jQuery 1.9.0 之前的版本，你需要使用 type 选项</p>
<p>31)url (默认: 当前页面地址)</p>
<p>32)username</p>
<p>响应 HTTP 访问认证请求的用户名</p>
<p>33)xhr (默认: 当可用的 ActiveXObject（IE）中，否则为 XMLHttpRequest)</p>
<p>类型: Function()</p>
<p>回调创建 XMLHttpRequest 对象。当可用时默认为 ActiveXObject（IE）中，否则为 XMLHttpRequest。提供覆盖你自己的执行的 XMLHttpRequest 或增强工厂。</p>
<p>34)xhrFields</p>
<p>类型: PlainObject</p>
<p>一对“文件名-文件值”组成的映射，用于设定原生的 XHR 对象。例如，如果需要的话，在进行跨域请求时，你可以用它来设置 withCredentials 为 true。</p>
<pre><code>$.ajax(&#123;
   url: a_cross_domain_url,
   xhrFields: &#123;
      withCredentials: true
   &#125;
&#125;);
</code></pre>
<h4 id="ajax"><a href="#ajax" class="headerlink" title=".ajax()"></a>.ajax()</h4><p>jQuery 发送的所有 Ajax 请求，内部都会通过调用 $.ajax() 函数来实现。通常没有必要直接调用这个函数，可以使用几个已经封装的简便方法，如$.get()和.load()。如果你需要用到那些不常见的选项，那么， $.ajax()使用起来更灵活。</p>
<p>注意: 所有的选项都可以通过$.ajaxSetup() 函数来全局设置</p>
<h4 id="jqXHR-对象"><a href="#jqXHR-对象" class="headerlink" title="jqXHR 对象"></a>jqXHR 对象</h4><p>从 jQuery 1.5 开始，$.ajax() 返回 XMLHttpRequest（jqXHR）对象，该对象是浏览器的原生的 XMLHttpRequest 对象的一个超集。例如，它包含 responseText 和 responseXML 属性，以及一个 getResponseHeader()方法。当传输机制不是是 XMLHttpRequest 时（例如，一个 JSONP 请求脚本，返回一个脚本 tag 时），jqXHR 对象尽可能的模拟原生的 XHR 功能。</p>
<p>从 jQuery 1.5.1 开始， jqXHR 对象还包含了 overrideMimeType 方法 (它在 jQuery 1.4.x 中是有效的，但是在 jQuery 1.5 中暂时的被移除)。.overrideMimeType() 方法可能用在 beforeSend()的回调函数中，例如，修改响应的 Content-Type 信息头：</p>
<p>从 jQuery 1.5 开始，$.ajax()返回的 jqXHR 对象 实现了 Promise 接口, 使它拥有了 Promise 的所有属性，方法和行为</p>
<p>jqXHR.done(function(data, textStatus, jqXHR) {});</p>
<p>jqXHR.fail(function(jqXHR, textStatus, errorThrown) {});</p>
<p>jqXHR.always(function(data|jqXHR, textStatus, jqXHR|errorThrown) { });</p>
<p>jqXHR.then(function(data, textStatus, jqXHR) {}, function(jqXHR, textStatus, errorThrown) {});</p>
<p>推荐使用的注意事项: jqXHR.success(), jqXHR.error(), 和 jqXHR.complete()回调从 jQuery 1.8 开始 被弃用过时。他们将最终被取消，您的代码应做好准备， 从 jQuery 3.0 开始被删除，你可以使用 jqXHR.done(), jqXHR.fail(), 和 jqXHR.always() 代替。</p>
<p>this 在所有的回调中的引用，是这个对象在传递给$.ajax 的设置中上下文；如果没有指定 context（上下文），this 引用的是 Ajax 设置的本身。</p>
<p>为了向后兼容 XMLHttpRequest ，jqXHR 对象将公开下列属性和方法：</p>
<p>readyState</p>
<p>status</p>
<p>statusText</p>
<p>responseXML and/or responseText 当底层的请求分别作出 XML 和/或文本响应</p>
<p>setRequestHeader(name, value) 从标准出发，通过替换旧的值为新的值，而不是替换的新值到旧值</p>
<p>getAllResponseHeaders()</p>
<p>getResponseHeader()</p>
<p>abort()</p>
<p>这里有$.ajax()提供的回调钩子 （hooks），如下：</p>
<ul>
<li><p>beforeSend 在发送请求之前调用，它接收 jqXHR 对象和 settings 作为参数对象。</p>
</li>
<li><p>error 在请求出错时调用。如果请求失败，在它们的顺序依次登记。他们接受 jqXHR ，字符串表示的错误类型，以及异常对象（如果有的话）。一些内置的错误会将 “abort”, “timeout”, “No Transport” 等字符串作为异常对象。</p>
</li>
<li><p>dataFilter 在请求成功之后调用。传入返回的数据以及 dataType 参数的值。并且必须返回新的数据（可能是处理过的）传递给 success 回调函数。</p>
</li>
<li><p>success 当请求成功并接收到返回数据之后调用。传入返回后的数据，以及包含成功代码的字符串和 jqXHR 对象。</p>
</li>
<li><p>Promise callbacks — .done(), .fail(), .always(), and .then() — 根据他们注册的顺序被调用。</p>
</li>
<li><p>complete 请求完成时，无论是在失败或成功，它们按顺序依次执行回调。他们收到 jqXHR 对象，以及一个包含成功或错误代码。</p>
</li>
</ul>
<h4 id="Data-Types（数据类型）"><a href="#Data-Types（数据类型）" class="headerlink" title="Data Types（数据类型）"></a>Data Types（数据类型）</h4><p>$.ajax()调用不同类型的响应，被传递到成功处理函数之前，会经过不同种类的预处理。 预处理的类型取决于由更加接近默认的 Content-Type 响应，但可以明确使用 dataType 选项进行设置。如果提供了 dataType 选项， 响应的 Content-Type 头信息将被忽略。</p>
<p>有效的数据类型是 text， html， xml， json，jsonp，和 script.</p>
<p>如果指定的是 text 或 html， 则不会预处理。 这些数据被简单地传递给成功处理函数， 并通过该 jqXHR 对象的 responseText 属性获得的。</p>
<p>如果指定的是 xml， 响应结果作为 XMLDocument，在传递给成功处理函数之前使用 jQuery.parseXML 进行解析。 XML 文档是可以通过该 jqXHR 对象的 responseXML 属性获得的。</p>
<p>如果指定的是 json，响应结果作为一个对象，在传递给成功处理函数之前使用 jQuery.parseJSON 进行解析。 解析后的 JSON 对象可以通过该 jqXHR 对象的 responseJSON 属性获得的。</p>
<p>如果指定的是 script ，$.ajax() 执行这段 JavaScript，这段 JavaScript 从服务器接收到，在传递给成功处理函数之前是一个字符串。</p>
<p>如果指定的是 jsonp ，$.ajax()会自动在请求的URL后面增加一个查询字符串参数 callback=?（默认） 。传递给$.ajax() 设置中的 jsonp 和 jsonpCallback 属性可以被用来指定， 分别为 查询字符串参数的名称和 JSONP 回调函数的名称。服务器应返回有效的 JavaScript，传递 JSON 响应到回调函数（愚人码头注：例如，flightHandler({“code”: “CA1998”,”price”: 1780,”tickets”: 5});等）。 在包含 JSON 对象的相应结果传递给成功处理函数之前，$.ajax() 将执行返回的 JavaScript， 调用 JSONP 回调函数。</p>
<h4 id="Sending-Data-to-the-Server（发送数据到服务器）"><a href="#Sending-Data-to-the-Server（发送数据到服务器）" class="headerlink" title="Sending Data to the Server（发送数据到服务器）"></a>Sending Data to the Server（发送数据到服务器）</h4><p>data 选项既可以包含一个查询字符串，比如 key1=value1&amp;key2=value2，也可以是一个映射，比如 {key1: ‘value1’, key2: ‘value2’} 。如果使用了后者的形式，则数据再发送前会用 jQuery.param() 将其转换成查询字符串。这个处理过程也可以通过设置 processData 选项为 false 来回避。如果我们希望发送一个 XML 对象给服务器时，这种处理可能并不合适。并且在这种情况下，我们也应当改变 contentType 选项的值，用其他合适的 MIME 类型来取代默认的 application/x-www-form-urlencoded 。</p>
<h4 id="Advanced-Options（高级选项）"><a href="#Advanced-Options（高级选项）" class="headerlink" title="Advanced Options（高级选项）"></a>Advanced Options（高级选项）</h4><p>global 选项用于阻止响应注册的回调函数，比如.ajaxSend(), .ajaxError()，以及类似的方法。这在有些时候很有用，比如发送的请求非常频繁且简短的时候，就可以在.ajaxSend()里禁用这个。跨域脚本和 JSONP 请求，全局选项自动设置为 false。更多关于这些方法的详细信息，请参阅下面的内容。</p>
<p>如果服务器需要 HTTP 认证，可以使用用户名和密码可以通过 username 和 password 选项来设置。</p>
<p>默认情况下，请求总会被发出去，但浏览器有可能从他的缓存中调取数据。要禁止使用缓存的结果，可以设置 cache 参数为 false。如果希望判断数据自从上次请求后没有更改过就报告出错的话，可以设置 ifModified 为 true。</p>
<p>$.ajax()函数返回他创建的 XMLHttpRequest 对象。通常 jQuery 只在内部处理并创建这个对象，但用户也可以通过 xhr 选项来传递一个自己创建的 xhr 对象。返回的对象通常已经被丢弃了，但依然提供一个底层接口来观察和操控请求。比如说，调用对象上的.abort() 可以在请求完成前挂起请求。</p>
<p>目前, 在 Firefox 中有一个 bug，虽然.getResponseHeader(‘Content-Type’)返回一个非空的字符串，但是 .getAllResponseHeaders()还是返回空字符串， 在 Firefox 中使用 jQuery 不支持自动解码 JSON CORS 响应。</p>
<h4 id="Using-Converters（使用转换器）"><a href="#Using-Converters（使用转换器）" class="headerlink" title="Using Converters（使用转换器）"></a>Using Converters（使用转换器）</h4><p>$.ajax()的转换器支持的数据类型映射到其它数据类型。但是，如果你想把自定义数据类型映射到一个已知的类型（json 等）,您必须 contents 选项在响应的 Content-Type 和实际的数据类型之间的添加一个相关的转换函数：<br>$.ajaxSetup({<br>contents: {<br>mycustomtype: /mycustomtype/<br>},<br>converters: {<br>“mycustomtype json”: function ( result ) {<br>// do stuff<br>return newresult;<br>}<br>}<br>});</p>
<p>这额外的对象是必要的，因为响应内容类型(Content-Types)和数据类型从来没有一个严格的一对一对应关系（正则表达式表示结果）。</p>
<p>转换一个支持的类型（例如 text, json）成自定义数据类型，然后再返回，使用另一个直通转换器：</p>
<pre><code>$.ajaxSetup(&#123;
  contents: &#123;
    mycustomtype: /mycustomtype/
  &#125;,
  converters: &#123;
    &quot;text mycustomtype&quot;: true,
    &quot;mycustomtype json&quot;: function ( result ) &#123;
      // do stuff
      return newresult;
    &#125;
  &#125;
&#125;);
</code></pre>
<p>现在上面的代码允许通过从 text 为 mycustomtype ，进而，mycustomtype 转换为 json。</p>
<p><em>由于浏览器的安全限制，大多数“Ajax”的要求，均采用同一起源的政策 ;该请求不能成功地检索来自不同的域，子域或协议的数据。<br>Script 和 JSONP 形式请求不受同源策略的限制</em></p>
<p>2 jQuery.ajaxSetup()</p>
<p>为以后要用到的 Ajax 请求设置默认的值</p>
<p>用于设置$.ajaxSetup()的详细参数, 参见 $.ajax().</p>
<p>所有后面的 Ajax 调用任何函数都将使用新的设置参数,除非它们调用时设置了各自的参数重载了这个默认值。 直到下一次调用$.ajaxSetup().</p>
<p>注意： 此处指定的设置会影响所有 $.ajax或基于AJAX的衍生方法，如$.get()的调用。这可能会导致不良的行为因为其他调用（例如，插件）可能希望正常的默认设置。出于这个原因，我们强烈建议您不要使用此 API。相反我们建议，在调用时明确设置选项或定义一个简单的插件。</p>
<p>注意: 全局回调函数应使用他们各自的全局 Ajax 事件处理方法-.ajaxStart(), .ajaxStop(), .ajaxComplete(), .ajaxError(), .ajaxSuccess(), .ajaxSend()-设置，而不是为 $.ajaxSetup() 设置 options 对象。</p>
<h3 id="快捷方法"><a href="#快捷方法" class="headerlink" title="快捷方法"></a>快捷方法</h3><p>1 jQuery.get()</p>
<p>jQuery.get( url [, data ] [, success ] [, dataType ] )</p>
<p>2 jQuery.getJSON()</p>
<p>jQuery.getJSON( url [, data ] [, success(data, textStatus, jqXHR) ] )</p>
<pre><code>$.getJSON(&#39;ajax/test.json&#39;, function(data) &#123;
  var items = [];

  $.each(data, function(key, val) &#123;
    items.push(&#39;&lt;li id=&quot;&#39; + key + &#39;&quot;&gt;&#39; + val + &#39;&lt;/li&gt;&#39;);
  &#125;);

  $(&#39;&lt;ul/&gt;&#39;, &#123;
    &#39;class&#39;: &#39;my-new-list&#39;,
    html: items.join(&#39;&#39;)
  &#125;).appendTo(&#39;body&#39;);
&#125;);
</code></pre>
<p>3 jQuery.getScript()</p>
<p>使用一个 HTTP GET 请求从服务器加载并执行一个 JavaScript 文件</p>
<p>定义了一个$.cachedScript（）方法可以获取缓存的脚本：</p>
<pre><code>jQuery.cachedScript = function(url, options) &#123;

  // allow user to set any option except for dataType, cache, and url
  options = $.extend(options || &#123;&#125;, &#123;
    dataType: &quot;script&quot;,
    cache: true,
    url: url
  &#125;);

  // Use $.ajax() since it is more flexible than $.getScript
  // Return the jqXHR object so we can chain callbacks
  return jQuery.ajax(options);
&#125;;

// Usage
$.cachedScript(&quot;ajax/test.js&quot;).done(function(script, textStatus) &#123;
  console.log( textStatus );
&#125;);
</code></pre>
<p>4 .load()</p>
<p>.load( url [, data ] [, complete(responseText, textStatus, XMLHttpRequest) ] )</p>
<p>默认使用 GET 方式 ， 如果 data 参数提供一个对象，那么使用 POST 方式。</p>
<h4 id="Loading-Page-Fragments（加载页面片段）"><a href="#Loading-Page-Fragments（加载页面片段）" class="headerlink" title="Loading Page Fragments（加载页面片段）"></a>Loading Page Fragments（加载页面片段）</h4><p>如果 url 参数的字符串中包含一个或多个空格，那么第一个空格后面的内容，会被当成是 jQuery 的选择器，从而决定应该加载返回结果中的哪部分内容。</p>
<pre><code>$(&#39;#result&#39;).load(&#39;ajax/test.html #container&#39;);
</code></pre>
<p>5 jQuery.post()</p>
<p>用 POST 获取的页面是从来不会被缓存, 所以这些请求中的 cache 和 ifModified 选项在 jQuery.ajaxSetup() 是无效的。</p>
<h2 id="jQuery-核心"><a href="#jQuery-核心" class="headerlink" title="jQuery 核心"></a>jQuery 核心</h2><p>1 jQuery()</p>
<p>1.1 jQuery( selector [, context ] )</p>
<p>jQuery( selector [, context ] )</p>
<p>jQuery( element )</p>
<p>jQuery( elementArray )</p>
<p>jQuery( object )</p>
<p>jQuery( jQuery object )</p>
<p>jQuery()</p>
<p>1）Cloning jQuery Objects(克隆 jQuery 对象)</p>
<p>当一个 jQuery 对象作为一个参数传递给$()方法时，这个对象的一个克隆对象将被创建。这个新的 jQuery 对象引用同一 DOM 元素。</p>
<p>2）Returning an Empty Set(返回一个空集合)</p>
<p>在 jQuery 1.4 中，如果你传递给 jQuery()方法一个空参数，一个空的 jQuery 设置将被返回（.length 属性为 0）。 在以前的 jQuery 版本中，一个包含整个文档节点的集合将被返回。</p>
<p>3）Working With Plain Objects（使用普通的对象）</p>
<p>目前，只支持包裹在 jQuery 中的普通的 JavaScript 对象是：.data(),.prop(),.bind(), .unbind(), .trigger() 和 .triggerHandler()。使用.data()（或者任何返回.data()的方法），在一个普通的对象会产生一个新的属性的名为 jQuery{randomNumber}（如 jQuery123456789）。</p>
<pre><code>// define a plain object
var foo = &#123;foo: &quot;bar&quot;, hello: &quot;world&quot;&#125;;

// Pass it to the jQuery function
var $foo = $( foo );

// test accessing property values
var test1 = $foo.prop( &quot;foo&quot; ); // bar

// test setting property values
$foo.prop( &quot;foo&quot;, &quot;foobar&quot; );
var test2 = $foo.prop( &quot;foo&quot; ); // foobar

// test using .data() as summarized above
$foo.data( &quot;keyName&quot;, &quot;someValue&quot;);
console.log( $foo ); // will now contain a jQuery&#123;randomNumber&#125; property

// test binding an event name and triggering
$foo.bind( &quot;eventName&quot;, function () &#123;
  console.log(&quot;eventName was called&quot;);
&#125;);

$foo.trigger( &quot;eventName&quot; ); // logs &quot;eventName was called&quot;
</code></pre>
<p>1.2 jQuery( html [, ownerDocument ] )</p>
<p>jQuery( html [, ownerDocument ] )</p>
<p>jQuery( html, attributes )</p>
<p>从 jQuery 1.4 开始，给 jQuery() 的第二个参数可以接受一个简单的对象组成的一个属性集合，可以传递.attr()方法。</p>
<p>重要提示： 如果第二个参数被传递，第一个参数中的 HTML 字符串 必须代表一个没有任何属性简单的元素。 从 jQuery 1.4 开始，一些 event type（事件类型）可以传递进来， 而且能够调用以下 jQuery 方法： val, css, html, text, data, width, height, or offset。</p>
<p>从 jQuery 1.8 开始, 任何 jQuery 实例方法（一个 jQuery.fn 的方法），可以被用来作为一个该对象的属性传递给第二个参数：</p>
<pre><code>$( &quot;&lt;div&gt;&lt;/div&gt;&quot;, &#123;
  &quot;class&quot;: &quot;my-div&quot;,
  on: &#123;
    touchstart: function( event ) &#123;
      // do something
    &#125;
  &#125;
&#125;).appendTo( &quot;body&quot; );
</code></pre>
<p>在这个对象中，”class”（类）的名称必须使用引号括起来，因为它是一个 JavaScript 保留字，还有不能使用”className”，因为它是指的 DOM 属性（property），不是属性（attribute）。</p>
<p>虽然第二个参数是方便，它的灵活性可能会导致意想不到的后果（例如$(“<input>“, {size: “4”})调用.size()方法，代替设置 size 属性）。上面的代码块可以被写入，代替为：</p>
<pre><code>$( &quot;&lt;div&gt;&lt;/div&gt;&quot; )
.addClass( &quot;my-div&quot; )
.on(&#123;
  touchstart: function( event ) &#123;
    // do something
  &#125;
&#125;).appendTo( &quot;body&quot; );
</code></pre>
<p>1.3 jQuery( callback )</p>
<p>2 jQuery.noConflict()</p>
<p>jQuery.noConflict( [removeAll ] )</p>
<p>removeAll<br>类型: Boolean，<br>一个布尔值，判断是否从全局作用域中内去除所有 jQuery 变量(包括 jQuery 本身)。</p>
<h2 id="jQuery-杂项"><a href="#jQuery-杂项" class="headerlink" title="jQuery 杂项"></a>jQuery 杂项</h2><h3 id="DOM-元素方法"><a href="#DOM-元素方法" class="headerlink" title="DOM 元素方法"></a>DOM 元素方法</h3><p>1 .get()</p>
<p>1.1 .get( index )</p>
<p>1.2 .get()</p>
<p>调用这个方法将会返回所有匹配的 DOM 节点，这些节点包含在一个标准的数组中</p>
<p>选择文档中的所有 div，并且作为一个数组返回。然后使用浏览器原生的 reverse 方法将数组翻转。</p>
<pre><code>function disp(divs) &#123;
    var a = [];
    for ( var i = 0; i &lt; divs.length; i++) &#123;
      a.push( divs[i].innerHTML );
    &#125;
    $( &quot;span&quot; ).text( a.join(&quot; &quot;) );
&#125;

disp( $( &quot;div&quot; ).get().reverse() );
</code></pre>
<p>2 .toArray()</p>
<p>和.get()方法效果相同</p>
<p>3 .index()</p>
<p>3.1 .index()</p>
<p>3.2 .index( selector )</p>
<p>3.3 .index( element )</p>
<p>如果不传递任何参数给 .index() 方法，则返回值就是 jQuery 对象中第一个元素相对于它同辈元素的位置。</p>
<p>如果在一组元素上调用 .index() ，并且参数是一个 DOM 元素或 jQuery 对象， .index() 返回值就是传入的元素相对于原先集合的位置。</p>
<p>如果参数是一个选择器， .index() 返回值就是原先元素相对于选择器匹配元素的位置。如果找不到匹配的元素，则 .index() 返回 -1.</p>
<h3 id="内部构件"><a href="#内部构件" class="headerlink" title="内部构件"></a>内部构件</h3><p>1 .jquery</p>
<p>.jquery 原型指向 jQuery 的原型， 通常被称为它的别名$.fn。它是一个字符串，其中包含的 jQuery 的版本号，如“1.5.0”或“1.4.4”。</p>
<p>2 jQuery.error()</p>
<p>jQuery.error( message )</p>
<p>接受一个字符串，并抛出包含这个字符串的异常。</p>
<p>这个方法主要是为了让插件开发人员可以重载此方法，并以更好的方式显示错误消息，或者提供更多相关信息。</p>
<p>3 .length</p>
<p>4 .pushStack()</p>
<p>将一个 DOM 元素集合加入到 jQuery 栈。</p>
<p><a target="_blank" rel="noopener" href="http://www.cnblogs.com/AndyWithPassion/archive/2012/02/06/jquery_pushStack_javascript.html">更多参考</a></p>
<h2 id="实用工具"><a href="#实用工具" class="headerlink" title="实用工具"></a>实用工具</h2><p>1 jQuery.contains()</p>
<p>jQuery.contains( container, contained )</p>
<p>检查一个 DOM 元素是另一个 DOM 元素的后代。</p>
<p>如果第二个参数所提供的 DOM 元素是第一个参数 DOM 元素的后裔，那么$.contains() 方法返回true，无论是直接的子元素或者是后代元素。否则，返回false。只支持 element 节点;如果第二个参数是一个文本或注释节点，$.contains()将返回 false。</p>
<p><em>注意: 第一个参数必须是一个 DOM 元素，不是一个 jQuery 对象或普通的 JavaScript 对象。</em></p>
<p>2 jQuery.each()</p>
<p>注意: $.each()函数会在内部检索并且使用传递集合的 length 属性。 所以，如果集合有一个名为 length 的属性 - 比如 {bar: ‘foo’, length: 10} - 这个函数可能无法正常工作。</p>
<p>我们可以在$.each()返回 false 来终止迭代。返回非 false 相当于一个循环中的 continue 语句，这意味着，它会立即跳出当前的迭代，转到下一个迭代。</p>
<p><em>jQuery 中的 each 方法和 ES5、underscore、Angular 都不同，它的回调函数第一个参数为 index/key，第二个为 value，其他刚好相反</em></p>
<p>3 jQuery.extend()</p>
<p>jQuery.extend( [deep ], target, object1 [, objectN ] )</p>
<p>如果只有一个参数提供给$.extend()，这意味着目标参数被省略。在这种情况下，jQuery 对象本身被默认为目标对象。这样，我们可以在 jQuery 的命名空间下添加新的功能。这对于插件开发者希望向 jQuery 中添加新函数时是很有用的。</p>
<p>请记住，目标对象（第一个参数）将被修改，并且将通过$.extend()返回。然而，如果我们想保留原对象，我们可以通过传递一个空对象作为目标对象：</p>
<pre><code>var object = $.extend(&#123;&#125;, object1, object2);
</code></pre>
<p>在默认情况下，通过$.extend()合并操作不是递归的;如果第一个对象的属性本身是一个对象或数组，那么它将完全用第二个对象相同的 key 重写一个属性。这些值不会被合并。可以通过检查下面例子中 banana 的值，就可以了解这一点。然而，如果将 true 作为该函数的第一个参数，那么会在对象上进行递归的合并。</p>
<p>警告:不支持第一个参数传递 false 。</p>
<p>未定义的属性不会被复制。然而，从对象原型的继承属性将被复制。如果属性（Properties）是一个通过构造函数 new MyCustomObject(args)定义的，或 JavaScript 中内置类型，如 Date 或 RegExp，是不会重新创建的，并且将被当作普通的对象出在返回的对象或数组中。</p>
<p>若设置了 deep 参数，对象和数组也会被合并进来，但是对象包裹的原始类型，比如 String, Boolean, 和 Number 是不会被合并进来的。</p>
<p>4 jQuery.fn.extend()</p>
<p>一个对象的内容合并到 jQuery 的原型，以提供新的 jQuery 实例方法。</p>
<p>jQuery.fn.extend()方法继承了 jQuery 原型($.fn)对象，以提供 jQuery 原型新的方法，可以链式调用 jQuery()函数。</p>
<pre><code>jQuery.fn.extend(&#123;
  check: function() &#123;
    return this.each(function() &#123; this.checked = true; &#125;);
  &#125;,
  uncheck: function() &#123;
    return this.each(function() &#123; this.checked = false; &#125;);
  &#125;
&#125;);

// Use the newly created .check() method
$( &quot;input[type=&#39;checkbox&#39;]&quot; ).check();
</code></pre>
<p>5 jQuery.globalEval()</p>
<p>在全局上下文下执行一些 JavaScript 代码</p>
<p>此方法的表现不同于正常使用的 JavaScript eval()，因为它是在全局上下文下执行（这对加载外部动态脚本很重要）。</p>
<pre><code>function test()&#123;
    jQuery.globalEval(&quot;var newVar = true;&quot;)
&#125;
test();
// newVar === true
</code></pre>
<p>6 jQuery.grep()</p>
<p>jQuery.grep( array, function(elementOfArray, indexInArray) [, invert ] )</p>
<p>查找满足过滤函数的数组元素。原始数组不受影响。类似 underscore 的 filter</p>
<p>7 jQuery.inArray()</p>
<p>jQuery.inArray( value, array [, fromIndex ] )</p>
<p>8 jQuery.isArray()</p>
<p>9 jQuery.isEmptyObject()</p>
<p>从 jQuery 1.4 开始，这个方法既检测对象本身的属性，也检测从原型继承的属性（因此没有使用 hasOwnProperty）。参数应当是一个普通的 JavaScript 对象， 对于其他类型的对象（DOM 元素，原始 strings/numbers，host 对象）在跨浏览器中可能无法提供一致的结果。 要确定一个对象是否是一个普通的 JavaScript 对象，使用$.isPlainObject()</p>
<p>10 jQuery.isFunction()</p>
<p>11 jQuery.isNumeric()</p>
<p>$.isNumeric()方法检查它的参数是否能代表一个数值。如果是这样，则返回 true。否则返回 false。该参数可以是任何类型。（愚人码头注：jQuery 3.0 之前，这个方法会强制转换参数为 Number，转换后的值类型如果是如果是 Number，也会返回 true）</p>
<p>在 jQuery 3.0 中，$.isNumeric()方法只有接收 number 类型的参数时候，或者是可以被强制为有限数值的 string 类型的参数，才会返回 true，在其他情况下，返回 false。</p>
<p>12 jQuery.isPlainObject()</p>
<p>注意: Host 对象（或浏览器宿主环境中所使用的对象，用来完成的 ECMAScript 执行环境）在检测跨平台时存在很多的不一致，难以提供跨平台的强劲的检测函数。在某些情况下，$.isPlainObject()的结果可能在不同的浏览器评估不一致</p>
<p>13 jQuery.isWindow()</p>
<p>这个方法在 jQuery 很多地方用到，用来确定我们的操作是否为一个浏览器窗口操作。（如当前窗口或一个 iframe）。</p>
<p>14 jQuery.isXMLDoc()</p>
<p>检查一个 DOM 节点是否在 XML 文档中（或者是一个 XML 文档）。</p>
<p>15 jQuery.makeArray()</p>
<p>转换一个类似数组的对象成为真正的 JavaScript 数组。</p>
<p>16 jQuery.map()</p>
<p>17 jQuery.merge()</p>
<p>合并两个数组内容到第一个数组。</p>
<p>18 jQuery.noop()</p>
<p>当你仅仅想要传递一个空函数的时候，就用他吧。</p>
<p>这对一些插件作者很有用，当插件提供了一个可选的回调函数接口，那么如果调用的时候没有传递这个回调函数，就用 jQuery.noop 来代替执行。</p>
<p>19 jQuery.now()</p>
<p>20 jQuery.parseHTML()</p>
<p>jQuery.parseHTML( data [, context ] [, keepScripts ] )</p>
<p>大多数的 jQuery 的 API 接受的 HTML 字符串将运行所包含在 HTML 中的脚本。jQuery.parseHTML 不运行 HTML 中解析出来的脚本，除非 keepScripts 参数为 true。然而，它仍然是可能在大多数环境中间接地执行脚本，例如通过<img onerror>属性。调用者应该意识到这一点，并通过清理或避免任何不可信来源的输入，如 URL 或 cookies，来防止它。为了未来的兼容性，当 keepScripts 为不确定的或 false 时，调用者不应该依赖于这个能力来运行任何脚本内容。</p>
<p>21 jQuery.parseJSON()</p>
<p>在 jQuery 1.9 之前,如果传递给$.parseJSON 一个空字符串，null, 或者 undefined,，将返回 null，而不是抛出一个错误，即使这些都不是有效的 JSON。</p>
<p>jQuery 3.0 开始，$.parseJSON 已经过时（愚人码头注：不建议使用）。要将字符串解析成 JSON 对象，请使用原生的 JSON.parse 方法来代替</p>
<p>22 jQuery.parseXML()</p>
<p>23 jQuery.proxy()</p>
<p>24 jQuery.readyException()</p>
<p>jQuery.readyException( error )</p>
<p>处理包裹在 jQuery()中函数同步抛出的错误。</p>
<p>25 jQuery.trim()</p>
<p>26 jQuery.type()</p>
<p>确定 JavaScript 对象的类型[[Class]] 。</p>
<p>27 jQuery.unique()</p>
<p>在 jQuery 3.0 中，这种方法已被弃用，只是 jQuery.uniqueSort()的别名。请使用该方法代替。</p>
<p>$.unique()函数通过搜索的数组对象，排序数组，并移除任何重复的节点。 如果一个节点和已经在数组中的节点完全相同，那么它被认为是重复的; 两个不同的节点具有相同的属性是被认为不重复的。 此功能只适用于普通的 JavaScript DOM 元素的数组，主要是 jQuery 内部使用。你可能永远都不需要使用它。</p>
<h2 id="延迟对象（deferred-对象）"><a href="#延迟对象（deferred-对象）" class="headerlink" title="延迟对象（deferred 对象）"></a>延迟对象（deferred 对象）</h2><p>deferred 对象就是 jQuery 的回调函数解决方案。</p>
<p>1 $.deferred()方法</p>
<p>作用是生成一个 deferred 对象。</p>
<p>2 deferred.done()</p>
<p>当 Deferred（延迟）对象解决时，调用添加处理程序。</p>
<p>deferred.done( doneCallbacks [, doneCallbacks ] )</p>
<p>当 Deferred（延迟）解决时，doneCallbacks 被调用。回调是依照他们添加的顺序执行。</p>
<p>3 deferred.fail()</p>
<p>当 Deferred（延迟）对象拒绝时，调用添加的处理程序。</p>
<p>4 deferred.progress()</p>
<p>当 Deferred（延迟）对象生成正在执行中的进度通知时，调用添加处理程序。</p>
<p>5 deferred.always()</p>
<p>当 Deferred（延迟）对象解决或拒绝时，调用添加处理程序。</p>
<p>6 deferred.then()</p>
<p>deferred.then( doneFilter [, failFilter ] [, progressFilter ] )</p>
<p>有时为了省事，可以把 done()和 fail()合在一起写，这就是 then()方法。</p>
<p>7 deferred.promise()</p>
<p>返回 Deferred(延迟)的 Promise（承诺）对象。</p>
<p>deferred.promise( [target ] )</p>
<p>大多数情况下，我们不想让用户从外部更改 deferred 对象的状态。这时，你可以在 deferred 对象的基础上，返回一个针对它的 promise 对象。我们可以把后者理解成，promise 是 deferred 的只读版，或者更通俗地理解成 promise 是一个对将要完成的任务的承诺。promise 对象只开放与改变执行状态无关的方法（比如 done()方法和 fail()方法），屏蔽与改变执行状态有关的方法（比如 resolve()方法和 reject()方法），从而使得执行状态不能被改变</p>
<p>你可以通过 promise 对象，为原始的 deferred 对象添加回调函数，查询它的状态，但是无法改变它的状态，也就是说 promise 对象不允许你调用 resolve 和 reject 方法。</p>
<p>jQuery 的 ajax() 方法返回的就是一个 promise 对象。此外，Animation 类操作也可以使用 promise 对象。</p>
<p>8 deferred.state()</p>
<p>deferred.state() 方法返回一个字符串，代表 Deferred（延迟）对象的当前状态。Deferred 对象可以在三种状态之一：</p>
<ul>
<li><p>“pending”: Deferred 对象是尚未完成状态 (不是 “rejected” 或 “resolved”).</p>
</li>
<li><p>“resolved”: Deferred 对象是在解决状态，这意味着，deferred.resolve() 或者 deferred.resolveWith()被对象访问和 doneCallbacks 被访问（或在被调用的过程中） 。</p>
</li>
<li><p>“rejected”: Deferred 对象是在被拒绝的状态，这意味着，deferred.reject() 或者 deferred.rejectWith() 被对象访问和 failCallbacks 被访问（或在被调用的过程中） 。</p>
</li>
</ul>
<p>这种方法主要是有用的调试，例如，在准备拒绝（reject）一个延迟对象前，判断它是否已经处于 resolved 状态。</p>
<p>9 deferred.notify()</p>
<p>deferred.notify( args )</p>
<p>根据给定的 args 参数 调用 Deferred（延迟）对象上进行中的回调 （progressCallbacks）。</p>
<p>通常情况下，只有递延对象（Deferred）的创建者才能调用此方法; 您可以通过 deferred.promise()返回的受限制的 Promise 对象，来防止其他代码改变递延的状态 。</p>
<p>当 deferred.notify 被访问时， 任何 progressCallbacks 可以通过访问 deferred.then 好或者 deferred.progress 来添加。回调是依照他们添加的顺序执行的。</p>
<p>10 deferred.notifyWith( context [, args ] )</p>
<p>Context（上下文） 作为 this 对象传递给进行中的回调（progressCallbacks ）</p>
<p>11 deferred.reject()</p>
<p>拒绝 Deferred（延迟）对象，并根据给定的 args 参数调用任何失败回调函数（failCallbacks）。</p>
<p>12 deferred.rejectWith()</p>
<p>13 deferred.resolve()</p>
<p>解决 Deferred（延迟）对象，并根据给定的 args 参数调用任何完成回调函数（doneCallbacks）。</p>
<p>14 deferred.resolveWith()</p>
<p>15 .promise()</p>
<p>.promise( [type ] [, target ] )</p>
<p>type (默认: fx),<br>类型: String,<br>需要待观察队列类型。</p>
<p>target<br>类型: PlainObject,<br>将要绑定 promise 方法的对象。</p>
<p>注意: 返回的 Promise 被链接到延迟对象上，保存在元素的 .data() 中。由于 .remove() 方法会移除元素上的 data，同时也会移除元素本身。所以，使用它会防止任何元素上未被受理的（unresolved） Promise 被受理（resolving）。如果有必要在元素的 Promise 被受理（resolved）之前，从 DOM 中移除该元素的话，请使用 .detach() 来代替。之后再调用 .removeData()</p>
<p>当所有的动画结果时(包括那些在动画回调函数和之后添加的回调函数中初始化的动画），受理（Resolve）返回的 Promise：</p>
<pre><code>&lt;script&gt;
$(&quot;button&quot;).bind( &quot;click&quot;, function() &#123;
  $(&quot;p&quot;).append( &quot;Started...&quot;);

  $(&quot;div&quot;).each(function( i ) &#123;
    $( this ).fadeIn().fadeOut( 1000 * (i+1) );
  &#125;);

  $( &quot;div&quot; ).promise().done(function() &#123;
    $( &quot;p&quot; ).append( &quot; Finished! &quot; );
  &#125;);
&#125;);
&lt;/script&gt;
</code></pre>
<p>16 deferred.catch()</p>
<p>当 Deferred 对象被拒绝(reject)时，调用添加的处理程序。</p>
<p>deferred.catch( failFilter )</p>
<p>failFilter<br>Type: Function(),<br>一个函数，当 Deferred 对象被拒绝(reject)时被调用</p>
<p>jQuery3.0 添加</p>
<p>deferred.catch( fn ) 是 deferred.then( null, fn )的一个别名</p>
<h2 id="回调对象"><a href="#回调对象" class="headerlink" title="回调对象"></a>回调对象</h2><p>jQuery.Callbacks()</p>
<p>jQuery.Callbacks( flags )</p>
<p>flags<br>类型: String，<br>一个用空格标记分隔的标志可选列表,用来改变回调列表中的行为。</p>
<p>$.Callbacks用来管理函数队列。采用了观察者模式，通过add添加操作到队列当中，通过fire去执行这些操作。实际上$.Callbacks 是 1.7 版本从$.Deferred对象当中分离出来的，主要是实现$.Deferred 功能。</p>
<p>$.Callbacks()的内部提供了jQuery的$.ajax() 和 $.Deferred() 基本功能组件。它可以用来作为类似基础定义的新组件的功能。</p>
<p>$.Callbacks() 支持的方法，包括 callbacks.add(),callbacks.remove(), callbacks.fire() 和 callbacks.disable().</p>
<h3 id="支持的-Flags"><a href="#支持的-Flags" class="headerlink" title="支持的 Flags"></a>支持的 Flags</h3><p>这个 flags 参数是$.Callbacks()的一个可选参数, 结构为一个用空格标记分隔的标志可选列表,用来改变回调列表中的行为 (比如. $.Callbacks( ‘unique stopOnFalse’ )).</p>
<p>可用的 flags:</p>
<ul>
<li><p>once: 函数队列只执行一次</p>
</li>
<li><p>memory: 当函数队列 fire 或 fireWith 一次过后，内部会记录当前 fire 或 fireWith 的参数。当下次调用 add 的时候，会把记录的参数传递给新添加的函数并立即执行这个新添加的函数</p>
</li>
<li><p>unique: 往内部队列添加的函数保持唯一，不能重复添加。</p>
</li>
<li><p>stopOnFalse: 内部队列里的函数是依次执行的，当某个函数的返回值是 false 时，停止继续执行剩下的函数。</p>
</li>
</ul>
<p>默认情况下，回调列表将像事件的回调列表中可以多次触发。</p>
<p>这四种基本类型可以相互组合起来使用，例如$.Deferred 就使用了 once 和 memory 的组合。</p>
<h3 id="Callbacks-支持的方法"><a href="#Callbacks-支持的方法" class="headerlink" title="$.Callbacks() 支持的方法"></a>$.Callbacks() 支持的方法</h3><p>1 add()</p>
<p>向内部队列添加函数，总有三种参数形式:</p>
<ul>
<li><p>单个函数参数</p>
</li>
<li><p>多个函数参数</p>
</li>
<li><p>数组参数</p>
</li>
</ul>
<p>2 fire()</p>
<p>依次执行队列里的函数</p>
<p>3 fire 的参数会传递给我们添加的函数</p>
<p>4 fireWith</p>
<p>fire 调用的时候，我们添加函数当中的 this 指向我们的 Callbacks 实例</p>
<p>fireWith 就是改变我们添加函数的 context，即 this 指向</p>
<p>fireWith 第一个参数是我们的 context，第二个参数是我们需要传递的内容数组，注意了是数组！</p>
<p>5 empty</p>
<p>清空函数队列</p>
<p>6 has</p>
<p>判断函数队列中是否存在某个函数</p>
<p>7 remove</p>
<p>从内部队列中移除某些函数</p>
<p>8 disable</p>
<p>禁用回调列表中的回调</p>
<p>9 disabled</p>
<p>回调管理是否被禁用</p>
<p>10 lock</p>
<p>锁定回调列表的当前状态。</p>
<p>disable 和 lock 的区别</p>
<p>两者唯一的区别就是添加了 memory 参数，看一下对比</p>
<pre><code>var cb = $.Callbacks(&#39;memory&#39;);

cb.add(function () &#123;
    console.log(&#39;one&#39;);
&#125;);
cb.fire();
cb.disable();
//cb.lock();
cb.add(function () &#123;
    console.log(&#39;two&#39;);
&#125;);
</code></pre>
<p>毫无疑问，disable 就是禁用所有功能，无论添加什么参数。而在 memory 的情况下，fire 过后再 lock，继续 add 新的函数依旧会立即执行。</p>
<p>11 locked</p>
<p>回调管理是否被锁</p>
<p>12 fired</p>
<p>回调队列是否执行过</p>
<h3 id="Callbacks-Deferred-and-Pub-Sub"><a href="#Callbacks-Deferred-and-Pub-Sub" class="headerlink" title="$.Callbacks, $.Deferred and Pub/Sub"></a>$.Callbacks, $.Deferred and Pub/Sub</h3><p>pub / sub（观察者模式）背后的一般思路 是促进应用程序的松散耦合。而比对其他对象的方法调用的单个对象，一个对象，而不是另一个对象的一个特定的任务或活动，并通知当它发生。观察家也被称为订阅者，它指向观察对象。观察者（Publisher）事件发生时通知用户</p>
<p>作为 $.Callbacks() 的创建组件的一个演示，只使用回调函数列表，就可以实现 Pub/Sub 系统。</p>
<pre><code>var topics = &#123;&#125;;

jQuery.Topic = function( id ) &#123;
    var callbacks,
        method,
        topic = id &amp;&amp; topics[ id ];

    if ( !topic ) &#123;
        callbacks = jQuery.Callbacks();
        topic = &#123;
            publish: callbacks.fire,
            subscribe: callbacks.add,
            unsubscribe: callbacks.remove
        &#125;;
        if ( id ) &#123;
            topics[ id ] = topic;
        &#125;
    &#125;
    return topic;
&#125;;
</code></pre>
<p>然后，可以很容易的使用这部分应用程序的发布和订阅感兴趣的事件：</p>
<pre><code>// Subscribers
$.Topic( &quot;mailArrived&quot; ).subscribe( fn1 );
$.Topic( &quot;mailArrived&quot; ).subscribe( fn2 );
$.Topic( &quot;mailSent&quot; ).subscribe( fn1 );

// Publisher
$.Topic( &quot;mailArrived&quot; ).publish( &quot;hello world!&quot; );
$.Topic( &quot;mailSent&quot; ).publish( &quot;woo! mail!&quot; );

// Here, &quot;hello world!&quot; gets pushed to fn1 and fn2
// when the &quot;mailArrived&quot; notification is published
// with &quot;woo! mail!&quot; also being pushed to fn1 when
// the &quot;mailSent&quot; notification is published.

/*
output:
hello world!
fn2 says: hello world!
woo! mail!
*/
</code></pre>
<p>尽管上面的代码很有用，但是可以进一步改进其实现。使用 $.Deferreds，可以保证当特定的任务被完成（或被解决）时，发布者只能向订阅者发布通知。参见下面的示例代码，进一步讨论如何在实践中使用这种情况：</p>
<pre><code>// subscribe to the mailArrived notification
$.Topic( &quot;mailArrived&quot; ).subscribe( fn1 );

// create a new instance of Deferreds
var dfd = $.Deferred();

// define a new topic (without directly publishing)
var topic = $.Topic( &quot;mailArrived&quot; );

// when the deferred has been resolved, publish a
// notification to subscribers
dfd.done( topic.publish );

// Here the Deferred is being resolved with a message
// that will be passed back to subscribers. It&#39;s possible to
// easily integrate this into a more complex routine
// (eg. waiting on an ajax call to complete) so that
// messages are only published once the task has actually
// finished.
dfd.resolve( &quot;it&#39;s been published!&quot; );
</code></pre>
<h3 id="use-JQuery-Callbacks"><a href="#use-JQuery-Callbacks" class="headerlink" title="use JQuery.Callbacks"></a>use JQuery.Callbacks</h3><p><a target="_blank" rel="noopener" href="http://stackoverflow.com/questions/8070894/when-would-i-use-jquery-callbacks">When would I use JQuery.Callbacks?</a></p>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">Angus</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://github.com/SilenceZeng/posts/25542.html">https://github.com/SilenceZeng/posts/25542.html</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">Angus</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/%E5%89%8D%E7%AB%AF/">
                                    <span class="chip bg-color">前端</span>
                                </a>
                            
                                <a href="/tags/%E7%A7%AF%E7%B4%AF/">
                                    <span class="chip bg-color">积累</span>
                                </a>
                            
                                <a href="/tags/javascript/">
                                    <span class="chip bg-color">javascript</span>
                                </a>
                            
                                <a href="/tags/jQuery/">
                                    <span class="chip bg-color">jQuery</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
        </div>
    </div>

    

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/posts/31836.html">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/12.jpg" class="responsive-img" alt="js高级程序设计学习之高级函数">
                        
                        <span class="card-title">js高级程序设计学习之高级函数</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2017-03-21
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E5%89%8D%E7%AB%AF/" class="post-category">
                                    前端
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E5%89%8D%E7%AB%AF/">
                        <span class="chip bg-color">前端</span>
                    </a>
                    
                    <a href="/tags/javascript/">
                        <span class="chip bg-color">javascript</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/posts/18778.html">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/0.jpg" class="responsive-img" alt="fiddler学习总结">
                        
                        <span class="card-title">fiddler学习总结</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2016-09-06
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E5%89%8D%E7%AB%AF/" class="post-category">
                                    前端
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/fiddler/">
                        <span class="chip bg-color">fiddler</span>
                    </a>
                    
                    <a href="/tags/%E8%B0%83%E8%AF%95/">
                        <span class="chip bg-color">调试</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="503838841"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>

    

    <div class="container row center-align"
         style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2015-2022</span>
            
            <span id="year">2015</span>
            <a href="/about" target="_blank">Angus</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            
            
            
            
            <br>

            <!-- 运行天数提醒. -->
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link ">
    <a href="https://github.com/SilenceZeng" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:tsang1205@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>













    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    

    

    

    <!--腾讯兔小巢-->
    
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
