<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="Promise小书（长文）, 秋山的技术博客">
    <meta name="description" content="行之于途而应于心">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>Promise小书（长文） | 秋山的博客</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="秋山的博客" type="application/atom+xml">
</head>




<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">秋山的博客</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">秋山的博客</div>
        <div class="logo-desc">
            
            行之于途而应于心
            
        </div>
    </div>

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/SilenceZeng" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/SilenceZeng" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/13.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">Promise小书（长文）</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        padding-bottom: 30px;
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/javascript/">
                                <span class="chip bg-color">javascript</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/%E5%89%8D%E7%AB%AF/" class="post-category">
                                前端
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2021-10-10
                </div>
                

                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    12.2k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    53 分
                </div>
                

                
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="/libs/prism/prism.css">
        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文主要参考了 JavaScript Promise 迷你书，链接在文末与其他参考一起列出。</p>
<h2 id="promise-基础"><a href="#promise-基础" class="headerlink" title="promise 基础"></a>promise 基础</h2><p>Promise 是异步编程的一种解决方案。ES6 Promise 的规范来源于 Promises/A+社区，它有很多版本的实现。</p>
<p>Promise 比传统的解决方案（回调函数和事件）更合理和更强大，可以避免回调地狱。使用 Promise 来统一处理异步操作，更具语义化、易于理解、有利维护。</p>
<p>Promise 接口的基本思想是让异步操作返回一个 Promise 对象，我们可以对这个对象进行一些操作。</p>
<h3 id="三种状态和两种变化途径"><a href="#三种状态和两种变化途径" class="headerlink" title="三种状态和两种变化途径"></a>三种状态和两种变化途径</h3><p>Promise 对象只有三种状态。</p>
<ul>
<li>异步操作“未完成”，promise 对象刚被创建后的初始化状态（unresolved，Promises/A+中称 pending）</li>
<li>异步操作“已完成”（resolved，Promises/A+中称 fulfilled）</li>
<li>异步操作“失败”（rejected）</li>
</ul>
<p>这三种的状态的变化途径只有两种。</p>
<ul>
<li>异步操作从“未完成”到“已完成”</li>
<li>异步操作从“未完成”到“失败”。</li>
</ul>
<p>这种变化只能发生一次，一旦当前状态变为“已完成”或“失败”，就意味着不会再有新的状态变化了。因此，Promise 对象的最终结果只有两种。</p>
<p>异步操作成功，Promise 对象传回一个值，状态变为 resolved。</p>
<p>异步操作失败，Promise 对象抛出一个错误，状态变为 rejected。</p>
<h3 id="api-简介"><a href="#api-简介" class="headerlink" title="api 简介"></a>api 简介</h3><p>目前主要有三种类型</p>
<ol>
<li>构造函数（Constructor）</li>
</ol>
<p>创建一个 promise 实例：</p>
<pre><code>var promise = new Promise(function (resolve, reject) &#123;
    // 异步处理
    // 处理结束后、调用resolve 或 reject
&#125;)
</code></pre>
<ol start="2">
<li><p>实例方法（Instance Method）</p>
<p>promise.then(onFulfilled, onRejected)</p>
<p>promise.catch(onRejected)</p>
</li>
<li><p>静态方法（Static Method）</p>
</li>
</ol>
<p>Promise.all()、 Promise.race()、Promise.resolve()、Promise.reject()</p>
<h3 id="创建-promise-对象"><a href="#创建-promise-对象" class="headerlink" title="创建 promise 对象"></a>创建 promise 对象</h3><p>给 Promise 构造函数传递一个函数 fn 作为参数实例化即可。这个函数 fn 有两个参数（resolve 和 reject），在 fn 中指定异步等处理：</p>
<ul>
<li>处理结果正常的话，调用 resolve(处理结果值)</li>
<li>处理结果错误的话，调用 reject(Error 对象)。</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 创建promise对象基本形式
var promise &#x3D; new Promise(function (resolve, reject) &#123;
  	&#x2F;&#x2F; ... some code

  	if (&#x2F;* 异步操作成功 *&#x2F;) &#123;
    	resolve(value)
  	&#125; else &#123;
    	reject(error)
  	&#125;
&#125;)

&#x2F;&#x2F; 将图片加载转为promise形式
var preloadImage &#x3D; function (path) &#123;
  	return new Promise(function (resolve, reject) &#123;
    	var image &#x3D; new Image()
    	image.onload  &#x3D; resolve
    	image.onerror &#x3D; reject
    	image.src &#x3D; path
  	&#125;)
&#125;

&#x2F;&#x2F; 创建XHR的promise对象
function getURL (URL) &#123;
    return new Promise(function (resolve, reject) &#123;
        var req &#x3D; new XMLHttpRequest()
        req.open(&#39;GET&#39;, URL, true)
        req.onload &#x3D; function () &#123;
            if (req.status &#x3D;&#x3D;&#x3D; 200) &#123;
                resolve(req.responseText)
            &#125; else &#123;
                reject(new Error(req.statusText))
            &#125;
        &#125;
        req.onerror &#x3D; function () &#123;
            reject(new Error(req.statusText))
        &#125;
        req.send()
    &#125;)
&#125;

&#x2F;&#x2F; 运行示例
var URL &#x3D; &#39;http:&#x2F;&#x2F;httpbin.org&#x2F;get&#39;
getURL(URL)
	.then(function onFulfilled (value)&#123;
	    console.log(value)
	&#125;)
	.catch(function onRejected (error)&#123;
	    console.error(error)
	&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>getURL 只有在通过 XHR 取得结果状态为 200 时才会调用 resolve。也就是只有数据取得成功时，而其他情况（取得失败）时则会调用 reject 方法。</p>
<p>resolve(req.responseText)在 response 的内容中加入了参数。resolve 方法的参数并没有特别的规则，基本上把要传给回调函数参数放进去就可以了。(then 方法可以接收到这个参数值)</p>
<h3 id="为-promise-对象添加处理方法"><a href="#为-promise-对象添加处理方法" class="headerlink" title="为 promise 对象添加处理方法"></a>为 promise 对象添加处理方法</h3><p>为 promise 对象添加处理方法主要有以下两种：</p>
<ul>
<li>promise 对象被 resolve 时的处理(onResolved)</li>
<li>promise 对象被 reject 时的处理(onRejected)</li>
</ul>
<p>被 resolve 后的处理，可以在.then 方法中传入想要调用的函数：</p>
<pre><code>var URL = &#39;http://httpbin.org/get&#39;
getURL(URL).then(function onResolved(value)&#123;
    console.log(value)
&#125;)
</code></pre>
<p>被 reject 后的处理，可以在.then 的第二个参数或者是在.catch 方法中设置想要调用的函数。</p>
<pre><code>var URL = &#39;http://httpbin.org/status/500&#39;
getURL(URL)
    .then(function onResolved(value)&#123;
        console.log(value)
    &#125;)
    .catch(function onRejected(error)&#123;
        console.error(error)
    &#125;)
</code></pre>
<p>.catch 只是 promise.then(undefined, onRejected)的别名而已，如下代码也可以完成同样的功能。</p>
<pre><code>getURL(URL).then(onResolved, onRejected)
</code></pre>
<h3 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve"></a>Promise.resolve</h3><p>1）new Promise 的快捷方式</p>
<p>静态方法 Promise.resolve(value)可以认为是 new Promise()方法的快捷方式。Promise.resolve(value)返回一个状态由给定 value 决定的 Promise 对象。如果该值是一个 Promise 对象，则直接返回该对象；如果该值是 thenable 对象（见下面部分 2），返回的 Promise 对象的最终状态由 then 方法执行决定；否则的话（该 value 为空，基本类型或者不带 then 方法的对象），返回的 Promise 对象状态为 resolved，并且将该 value 传递给对应的 then 方法。</p>
<p>所以和 new Promise()方法并不完全一致。Promise.resolve 接收一个 promise 对象会直接返回这个对象。而 new Promise()总是新生成一个 promise 对象。</p>
<pre><code>var p1 = Promise.resolve(1)

var p2 = Promise.resolve(p1)

var p3 = new Promise(function (resolve, reject) &#123;
    resolve(p1)
&#125;)

console.log(p1 === p2) // true
console.log(p1 === p3) // false
</code></pre>
<p>常用 Promise.resolve()快速初始化一个 promise 对象。</p>
<pre><code>Promise.resolve(42).then(function (value) &#123;
    console.log(value)
&#125;)
</code></pre>
<p>2）Promise.resolve 方法另一个作用就是将 thenable 对象转换为 promise 对象。</p>
<p>什么是 thenable 对象？Thenable 对象可以认为是类 Promise 对象，拥有名为.then 方法的对象。和类数组的概念相似。</p>
<p>有哪些 thenable 对象？主要是 ES6 之前有许多库实现了 Promise，其中有很多与 ES6 Promise 规范并不一致，我们称这些与 ES6 中的 promise 对象类似而又有差异的对象为 thenable 对象。如 jQuery 中的 ajax()方法返回的对象。</p>
<pre><code>// 将thenable对象转换promise对象
var promise = Promise.resolve($.ajax(&#39;/json/comment.json&#39;)) // =&gt; promise对象
promise.then(function (value) &#123;
   console.log(value)
&#125;)
</code></pre>
<h3 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject()"></a>Promise.reject()</h3><p>Promise.reject(error)是和 Promise.resolve(value)类似的静态方法，是 new Promise()方法的快捷方式。</p>
<p>比如 Promise.reject(new Error(‘出错了’))就是下面代码的语法糖形式：</p>
<pre><code>new Promise(function (resolve, reject) &#123;
    reject(new Error(&#39;出错了&#39;))
&#125;)
</code></pre>
<h3 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a>Promise.all</h3><p>Promise.all 方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。</p>
<pre><code>var p = Promise.all([p1, p2, p3])
</code></pre>
<p>上面代码中，Promise.all 方法接受一个数组作为参数，p1、p2、p3 都是 Promise 实例，如果不是，就会先调用 Promise.resolve 方法，将参数转为 Promise 实例，再进一步处理。</p>
<p>p 的状态由 p1、p2、p3 决定，分成两种情况。</p>
<p>（1）只有 p1、p2、p3 的状态都变成 resolved，p 的状态才会变成 resolved，此时 p1、p2、p3 的返回值组成一个数组，传递给 p 的回调函数。</p>
<p>（2）只要 p1、p2、p3 之中有一个被 rejected，p 的状态就变成 rejected，此时第一个被 reject 的实例的返回值，会传递给 p 的回调函数。</p>
<p>传递给 Promise.all 的 promise 并不是一个个的顺序执行的，而是同时开始、并行执行的。</p>
<pre><code>// `delay`毫秒后执行resolve
function timerPromisefy (delay) &#123;
    return new Promise(function (resolve) &#123;
        setTimeout(function () &#123;
            resolve(delay)
        &#125;, delay)
    &#125;)
&#125;

var startDate = Date.now()

// 所有promise变为resolve后程序退出
Promise.all([
    timerPromisefy(1),
    timerPromisefy(32),
    timerPromisefy(64),
    timerPromisefy(128)
]).then(function (values) &#123;
    console.log(Date.now() - startDate + &#39;ms&#39;)
    // 约128ms
    console.log(values)   // [1, 32, 64, 128]
&#125;)
</code></pre>
<p>从上述结果可以看出，传递给 Promise.all 的 promise 并不是一个个的顺序执行的，而是同时开始、并行执行的。</p>
<p>如果这些 promise 全部串行处理的话，那么需要等待 1ms → 等待 32ms → 等待 64ms → 等待 128ms ，全部执行完毕需要约 225ms 的时间。</p>
<h3 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race"></a>Promise.race</h3><pre><code>var p = Promise.race([p1, p2, p3])
</code></pre>
<p>与 Promise.all 类似，但是只要 p1、p2、p3 之中有一个实例率先改变状态，p 的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给 p 的回调函数。</p>
<pre><code>// `delay`毫秒后执行resolve
function timerPromisefy(delay) &#123;
    return new Promise(function (resolve) &#123;
        setTimeout(function () &#123;
            resolve(delay)
        &#125;, delay)
    &#125;)
&#125;

// 任何一个promise变为resolve或reject的话程序就停止运行
Promise.race([
    timerPromisefy(1),
    timerPromisefy(32),
    timerPromisefy(64),
    timerPromisefy(128)
]).then(function (value) &#123;
    console.log(value) // =&gt; 1
&#125;)
</code></pre>
<p>下面我们再来看看在第一个 promise 对象变为确定（resolved）状态后，它之后的 promise 对象是否还在继续运行：</p>
<pre><code>var winnerPromise = new Promise(function (resolve) &#123;
    setTimeout(function () &#123;
        console.log(&#39;this is winner&#39;)
        resolve(&#39;this is winner&#39;)
    &#125;, 4)
&#125;)

var loserPromise = new Promise(function (resolve) &#123;
    setTimeout(function () &#123;
        console.log(&#39;this is loser&#39;)
        resolve(&#39;this is loser&#39;)
    &#125;, 1000)
&#125;)

// 第一个promise变为resolve后程序停止
Promise.race([winnerPromise, loserPromise]).then(function (value) &#123;
    console.log(value) // =&gt; &#39;this is winner&#39;
&#125;)
</code></pre>
<p>执行上面代码的话，我们会看到 winnter 和 loser promise 对象的 setTimeout 方法都会执行完毕，console.log 也会分别输出它们的信息。</p>
<p>也就是说，Promise.race 在第一个 promise 对象变为 Fulfilled 之后，并不会取消其他 promise 对象的执行。</p>
<p>在 ES6 Promises 规范中，也没有取消（中断）promise 对象执行的概念，我们必须要确保 promise 最终进入 resolve or reject 状态之一。也就是说 Promise 并不适用于状态可能会固定不变的处理。也有一些类库提供了对 promise 进行取消的操作。</p>
<h2 id="Promise-的实现类库（Library）"><a href="#Promise-的实现类库（Library）" class="headerlink" title="Promise 的实现类库（Library）"></a>Promise 的实现类库（Library）</h2><p>由于很多浏览器不支持 ES6 Promises，我们需要一些第三方实现的和 Promise 兼容的类库。</p>
<p>选择 Promise 类库首先要考虑的是否具有 Promises/A+兼容性。</p>
<p>Promises/A+是 ES6 Promises 的前身，Promise 的 then 也是由社区的规范而来。</p>
<p>这些类库主要有两种：Polyfill 和扩展类库</p>
<p>1）Polyfill</p>
<ul>
<li><a href="https://github.com/stefanpenner/es6-promise">jakearchibald/es6-promise</a>：应用最广泛的一个库，推荐使用这个库。</li>
<li><a href="https://github.com/yahoo/ypromise">yahoo/ypromise</a>：这是一个独立版本的 YUI 的 Promise Polyfill。</li>
<li><a href="https://github.com/getify/native-promise-only/">getify/native-promise-only</a>：严格按照 ES6 Promises 的规范设计，没有添加在规范中没有定义的功能。</li>
</ul>
<p>2）Promise 扩展类库</p>
<ul>
<li><a href="https://github.com/kriskowal/q">kriskowal/q</a>: Q.promise，这个大家应该都比较熟悉了。Angularjs 中的$q 也是受此启发。</li>
<li><a href="https://github.com/petkaantonov/bluebird">petkaantonov/bluebird</a>：这个类库除了兼容 Promise 规范之外，还扩展了取消 promise 对象的运行，取得 promise 的运行进度，以及错误处理的扩展检测等非常丰富的功能，此外它在实现上还在性能问题下了很大的功夫。</li>
</ul>
<p>Q 等文档里详细介绍了 Q 的 Deferred 和 jQuery 里的 Deferred 有哪些异同，以及要怎么进行迁移等都进行了详细的说明。</p>
<h2 id="两个有用的附加方法"><a href="#两个有用的附加方法" class="headerlink" title="两个有用的附加方法"></a>两个有用的附加方法</h2><p>1）done()</p>
<p>Promise 对象的回调链，不管以 then 方法或 catch 方法结尾，要是最后一个方法抛出错误，都有可能无法捕捉到（因为 Promise 内部的错误不会冒泡到全局）。因此，我们可以提供一个 done 方法，总是处于回调链的尾端，保证抛出任何可能出现的错误。</p>
<pre><code>&#39;use strict&#39;
if (typeof Promise.prototype.done === &#39;undefined&#39;) &#123;
    Promise.prototype.done = function (onFulfilled, onRejected) &#123;
        this.then(onFulfilled, onRejected)
            .catch(function (error) &#123;
                setTimeout(function () &#123;
                    throw error
                &#125;, 0)
            &#125;)
    &#125;
&#125;

// 调用
asyncFunc()
      .then(f1)
      .catch(r1)
      .then(f2)
      .done()
</code></pre>
<p>从上面代码可以看到 done 有以下两个特点。</p>
<ul>
<li>done 中出现的错误会被作为异常抛出</li>
<li>终结 Promise chain</li>
</ul>
<p>那么它是如何将异常抛到 Promise 的外面的呢？其实这里我们利用的是在 setTimeout 中使用 throw 方法，直接将异常抛给了外部。</p>
<pre><code>// setTimeout的回调函数中抛出异常
try &#123;
    setTimeout(function callback () &#123;
        throw new Error(&#39;error&#39;)
    &#125;, 0)
&#125; catch (error) &#123;
    console.error(error)
&#125;
</code></pre>
<p>因为异步的 callback 中抛出的异常不会被捕获，上面例子中的例外不会被捕获。</p>
<p>ES6 Promises 和 Promises/A+等在设计上并没有对 Promise.prototype.done 做出任何规定，但是为什么很多类库都提供了该方法的实现呢？</p>
<p>主要是防止编码时忘记使用 catch 方法处理异常导致错误排查非常困难的问题。由于 Promise 的 try-catch 机制，异常可能会被内部消化掉。这种错误被内部消化的问题也被称为 unhandled rejection，从字面上看就是在 Rejected 时没有找到相应处理的意思。</p>
<pre><code>function JSONPromise (value) &#123;
    return new Promise(function (resolve) &#123;
        resolve(JSON.parse(value))
    &#125;)
&#125;

// 运行示例
var string = &#39;&#123;&#125;&#39;
JSONPromise(string).then(function (object) &#123;
    conosle.log(object)
&#125;)
</code></pre>
<p>在这个例子里，我们错把 console 拼成了 conosle，因此会发生如下错误：</p>
<pre><code>ReferenceError: conosle is not defined
</code></pre>
<p>不过在 chrome 中实测查找这种错误已经相当精准了。所以以前用 jQuery 的时候用过 done，后来在实际项目中并没有使用过 done 方法。</p>
<p>2）finally()</p>
<p>finally 方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。它与 done 方法的最大区别，它接受一个普通的回调函数作为参数，该函数不管怎样都必须执行。</p>
<pre><code>Promise.prototype.finally = function (callback) &#123;
  let P = this.constructor
  return this.then(
    value  =&gt; P.resolve(callback()).then(() =&gt; value),
    reason =&gt; P.resolve(callback()).then(() =&gt; &#123; throw reason &#125;)
  )
&#125;
</code></pre>
<p>这个还是很有用的，我们经常在 ajax 无论成功还是失败后都要关闭 loading。我一般使用这个库<a target="_blank" rel="noopener" href="https://www.npmjs.com/package/promise.prototype.finally">promise.prototype.finally</a>。</p>
<h2 id="Promise-只能进行异步操作？"><a href="#Promise-只能进行异步操作？" class="headerlink" title="Promise 只能进行异步操作？"></a>Promise 只能进行异步操作？</h2><pre><code>var promise = new Promise(function (resolve) &#123;
    console.log(1) // 1
    resolve(3)
&#125;)

promise.then(function(value)&#123;
    console.log(value) // 3
&#125;)

console.log(2) // 2
</code></pre>
<p>执行上面的代码，会依次输出 1，2，3。首先 new Promise 中的函数会立即执行，然后是外面的 console.log(2)，最后是 then 回调中的函数。</p>
<p>由于 promise.then 执行的时候 promise 对象已经是确定状态，从程序上说对回调函数进行同步调用也是行得通的。</p>
<p>但是即使在调用 promise.then 注册回调函数的时候 promise 对象已经是确定的状态，Promise 也会以异步的方式调用该回调函数，这是在 Promise 设计上的规定方针。为什么要这样呢？</p>
<p>这涉及到同步调用和异步调用同时存在导致的混乱。</p>
<pre><code>function onReady (fn) &#123;
    var readyState = document.readyState
    if (readyState === &#39;interactive&#39; || readyState === &#39;complete&#39;) &#123;
        fn()
    &#125; else &#123;
        window.addEventListener(&#39;DOMContentLoaded&#39;, fn)
    &#125;
&#125;

onReady(function () &#123;
    console.log(&#39;DOM fully loaded and parsed&#39;)
&#125;)

console.log(&#39;==Starting==&#39;)
</code></pre>
<p>上面的代码如果在调用 onReady 之前 DOM 已经载入的话：对回调函数进行同步调用。</p>
<p>如果在调用 onReady 之前 DOM 还没有载入的话：通过注册 DOMContentLoaded 事件监听器来对回调函数进行异步调用。</p>
<p>因此，如果这段代码在源文件中出现的位置不同，在控制台上打印的 log 消息顺序也会不同。</p>
<p>为了解决这个问题，我们可以选择统一使用异步调用的方式：</p>
<pre><code>function onReady (fn) &#123;
    var readyState = document.readyState
    if (readyState === &#39;interactive&#39; || readyState === &#39;complete&#39;) &#123;
        setTimeout(fn, 0)
    &#125; else &#123;
        window.addEventListener(&#39;DOMContentLoaded&#39;, fn)
    &#125;
&#125;

onReady(function () &#123;
    console.log(&#39;DOM fully loaded and parsed&#39;)
&#125;)

console.log(&#39;==Starting==&#39;)
</code></pre>
<p>关于这个问题，在<a target="_blank" rel="noopener" href="http://effectivejs.com/">Effective JavaScript</a>的第 67 项不要对异步回调函数进行同步调用中也有详细介绍：</p>
<ul>
<li>绝对不能对异步回调函数（即使在数据已经就绪）进行同步调用。</li>
<li>如果对异步回调函数进行同步调用的话，处理顺序可能会与预期不符，可能带来意料之外的后果。</li>
<li>对异步回调函数进行同步调用，还可能导致栈溢出或异常处理错乱等问题。</li>
<li>如果想在将来某时刻调用异步回调函数的话，可以使用 setTimeout 等异步 API。</li>
</ul>
<p>为了避免上述中同时使用同步、异步调用可能引起的混乱问题，Promise 在规范上规定 Promise 只能使用异步调用方式。</p>
<p>由于 Promise 保证了每次调用都是以异步方式进行的，所以我们在实际编码中不需要调用 setTimeout 来自己实现异步调用：</p>
<pre><code>function onReadyPromise () &#123;
    return new Promise(function (resolve, reject) &#123;
        var readyState = document.readyState
        if (readyState === &#39;interactive&#39; || readyState === &#39;complete&#39;) &#123;
            resolve()
        &#125; else &#123;
            window.addEventListener(&#39;DOMContentLoaded&#39;, resolve)
        &#125;
    &#125;)
&#125;

onReadyPromise().then(function () &#123;
    console.log(&#39;DOM fully loaded and parsed&#39;)
&#125;)

console.log(&#39;==Starting==&#39;)
</code></pre>
<h2 id="异步操作顺序问题"><a href="#异步操作顺序问题" class="headerlink" title="异步操作顺序问题"></a>异步操作顺序问题</h2><p>前面 Promise.resolve()章节的三个 promise，我们看看其执行顺序是怎样的？</p>
<pre><code>var p1 = Promise.resolve(1)

var p2 = Promise.resolve(p1)

var p3 = new Promise(function (resolve, reject) &#123;
    resolve(p1)
&#125;)

var p4 = new Promise(function (resolve, reject) &#123;
    reject(p1)
&#125;)

p3.then(function (value) &#123;
      console.log(&#39;p3 : &#39; + value)
&#125;)

p2.then(function (value) &#123;
      console.log(&#39;p2 : &#39; + value)
&#125;)

p4.then(function (value) &#123;
      console.log(&#39;p4-1 : &#39; + value)
&#125;, function (value) &#123;
    console.log(&#39;p4-1 : &#39; + value)
&#125;)

p4.then(function (value) &#123;
      console.log(&#39;p4-2 : &#39; + value)
&#125;).catch(function (value) &#123;
    console.log(&#39;p4-2 : &#39; + value)
&#125;)

p1.then(function (value) &#123;
      console.log(&#39;p1 : &#39; + value)
&#125;)
</code></pre>
<p>我们在比较新的浏览器控制台输出会发现顺序为 2，4-1，1，4-2，3（测试发现 chrome55、56 中则是最先打印出 3）。这个不知道怎么解释了，为什么 p3 会最后执行？暂时没找到什么可靠的资料，有大神知道的话，请评论指出。</p>
<h2 id="Promise-chain（Promise-方法链）"><a href="#Promise-chain（Promise-方法链）" class="headerlink" title="Promise chain（Promise 方法链）"></a>Promise chain（Promise 方法链）</h2><h3 id="Promise-chain-流程"><a href="#Promise-chain-流程" class="headerlink" title="Promise chain 流程"></a>Promise chain 流程</h3><pre><code>function taskA () &#123;
    console.log(&#39;Task A&#39;)
&#125;

function taskB () &#123;
    console.log(&#39;Task B&#39;)
&#125;

function onRejected (error) &#123;
    console.log(&#39;Catch Error: A or B&#39;, error)
&#125;

function finalTask () &#123;
    console.log(&#39;Final Task&#39;)
&#125;

var promise = Promise.resolve()
promise
    .then(taskA)
    .then(taskB)
    .catch(onRejected)
    .then(finalTask)
</code></pre>
<p>在上述代码中，我们没有为 then 方法指定第二个参数(onRejected)，可以像下面这样来理解：</p>
<p>then：注册 onResolved 时的回调函数</p>
<p>catch：注册 onRejected 时的回调函数</p>
<p>1）taskA、taskB 都没有发生异常，会按照 taskA → taskB → finalTask 这个流程来进行处理</p>
<p>2）taskA 没有发生异常，taskB 发生异常，会按照 taskA → taskB → onRejected → finalTask 这个流程来进行处理</p>
<p>3）taskA 发生异常，会按照 taskA → onRejected → finalTask 这个流程来进行处理，TaskB 是不会被调用的</p>
<pre><code>function taskA () &#123;
    console.log(&#39;Task A&#39;)
    throw new Error(&#39;throw Error @ Task A&#39;)
&#125;

function taskB () &#123;
    console.log(&#39;Task B&#39;) // 不会被调用
&#125;

function onRejected (error) &#123;
    console.log(error) // =&gt; &#39;throw Error @ Task A&#39;
&#125;

function finalTask () &#123;
    console.log(&#39;Final Task&#39;)
&#125;

var promise = Promise.resolve()
promise
    .then(taskA)
    .then(taskB)
    .catch(onRejected)
    .then(finalTask)
</code></pre>
<p>在本例中我们在 taskA 中使用了 throw 方法故意制造了一个异常。但在实际中想主动进行 onRejected 调用的时候，应该返回一个 Rejected 状态的 promise 对象。</p>
<h3 id="promise-chain-中如何传递参数？"><a href="#promise-chain-中如何传递参数？" class="headerlink" title="promise chain 中如何传递参数？"></a>promise chain 中如何传递参数？</h3><p>如果 Task A 想给 Task B 传递一个参数该怎么办呢？其实非常简单，只要在 taskA 中 return 一个值，这个值会作为参数传递给 taskB。</p>
<pre><code>function doubleUp (value) &#123;
    return value * 2
&#125;

function increment (value) &#123;
    return value + 1
&#125;

function output (value) &#123;
    console.log(value) // =&gt; (1 + 1) * 2
&#125;

var promise = Promise.resolve(1)
promise
    .then(increment)
    .then(doubleUp)
    .then(output)
    .catch(function (error) &#123;
        // promise chain中出现异常的时候会被调用
        console.error(error)
    &#125;)
</code></pre>
<p>每个方法中 return 的值不仅只局限于字符串或者数值类型，也可以是对象或者 promise 对象等复杂类型。</p>
<p>return 的值会由 Promise.resolve(return 的返回值)进行相应的包装处理，因此不管回调函数中会返回一个什么样的值，最终 then 的结果都是返回一个新创建的 promise 对象。</p>
<p>也就是说，Promise 的 then 方法不仅仅是注册一个回调函数那么简单，它还会将回调函数的返回值进行变换，创建并返回一个 promise 对象。</p>
<h3 id="如何停止-promise-chain"><a href="#如何停止-promise-chain" class="headerlink" title="如何停止 promise chain"></a>如何停止 promise chain</h3><p>在使用 Promise 处理一些复杂逻辑的过程中，我们有时候会想要在发生某种错误后就停止执行 Promise 链后面所有的代码。</p>
<p>然而 Promise 本身并没有提供这样的功能，一个操作，要么成功，要么失败，要么跳转到 then 里，要么跳转到 catch 里。</p>
<p>具体怎么做，请查看这篇文章<a href="https://github.com/xieranmaya/blog/issues/5">从如何停掉 Promise 链说起</a>。</p>
<h2 id="每次调用-then-都会返回一个新创建的-promise-对象"><a href="#每次调用-then-都会返回一个新创建的-promise-对象" class="headerlink" title="每次调用 then 都会返回一个新创建的 promise 对象"></a>每次调用 then 都会返回一个新创建的 promise 对象</h2><p>从代码上乍一看，aPromise.then(…).catch(…)像是针对最初的 aPromise 对象进行了一连串的方法链调用。</p>
<p>然而实际上不管是 then 还是 catch 方法调用，都返回了一个新的 promise 对象。</p>
<pre><code>var aPromise = new Promise(function (resolve) &#123;
    resolve(100)
&#125;)

var thenPromise = aPromise.then(function (value) &#123;
    console.log(value)
&#125;)

var catchPromise = thenPromise.catch(function (error) &#123;
    console.error(error)
&#125;)

console.log(aPromise !== thenPromise) // =&gt; true
console.log(thenPromise !== catchPromise) // =&gt; true
</code></pre>
<p>执行上面代码，证明了 then 和 catch 都返回了和调用者不同的 promise 对象。知道了这点，我们就很容易明白下面两种调用方法的区别：</p>
<pre><code>// 1: 对同一个promise对象同时调用 `then` 方法
var aPromise = new Promise(function (resolve) &#123;
    resolve(100)
&#125;)

aPromise.then(function (value) &#123;
    return value * 2
&#125;)

aPromise.then(function (value) &#123;
    return value * 2
&#125;)

aPromise.then(function (value) &#123;
    console.log(&#39;1: &#39; + value) // =&gt; 100
&#125;)

// vs

// 2: 对 `then` 进行 promise chain 方式进行调用
var bPromise = new Promise(function (resolve) &#123;
    resolve(100)
&#125;)

bPromise.then(function (value) &#123;
    return value * 2
&#125;).then(function (value) &#123;
    return value * 2
&#125;).then(function (value) &#123;
    console.log(&#39;2: &#39;&#39; + value) // =&gt; 100 * 2 * 2
&#125;)
</code></pre>
<p>下面是一个由方法 1 中的 then 用法导致的比较容易出现的很有代表性的反模式的例子：</p>
<pre><code>// then的错误使用方法
function badAsyncCall() &#123;
    var promise = Promise.resolve()
    promise.then(function() &#123;
        // 任意处理
        return newVar
    &#125;)
    return promise
&#125;
</code></pre>
<p>这种写法有很多问题，首先在 promise.then 中产生的异常不会被外部捕获，此外，也不能得到 then 的返回值，即使其有返回值。</p>
<p>不仅 then 和 catch 都返回了和调用者不同的 promise 对象，Promise.all 和 Promise.race，他们都会接收一组 promise 对象为参数，并返回一个和接收参数不同的、新的 promise 对象。</p>
<h2 id="使用-then-的第二个参数还是-catch-处理异常？"><a href="#使用-then-的第二个参数还是-catch-处理异常？" class="headerlink" title="使用 then 的第二个参数还是 catch 处理异常？"></a>使用 then 的第二个参数还是 catch 处理异常？</h2><p>之前我们说过 .catch 也可以理解为 promise.then(undefined, onRejected)。那么使用这两种方法进行错误处理有什么区别呢？</p>
<pre><code>function throwError (value) &#123;
    // 抛出异常
    throw new Error(value)
&#125;

// &lt;1&gt; onRejected不会被调用
function badMain (onRejected) &#123;
    return Promise.resolve(42).then(throwError, onRejected)
&#125;

// &lt;2&gt; 有异常发生时onRejected会被调用
function goodMain (onRejected) &#123;
    return Promise.resolve(42).then(throwError).catch(onRejected)
&#125;

// 运行示例
badMain(function () &#123;
    console.log(&quot;BAD&quot;)
&#125;)

goodMain(function () &#123;
    console.log(&quot;GOOD&quot;)
&#125;)
</code></pre>
<p>在上面的代码中，badMain 是一个不太好的实现方式（但也不是说它有多坏），goodMain 则是一个能非常好的进行错误处理的版本。</p>
<p>为什么说 badMain 不好呢？，因为虽然我们在.then 的第二个参数中指定了用来错误处理的函数，但实际上它却不能捕获第一个参数 onResolved 指定的函数（本例为 throwError）里面出现的错误。</p>
<p>也就是说，这时候即使 throwError 抛出了异常，onRejected 指定的函数也不会被调用（即不会输出”BAD”字样）。</p>
<p>与此相对的是，goodMain 的代码则遵循了 throwError → onRejected 的调用流程。这时候 throwError 中出现异常的话，在会被方法链中的下一个方法，即.catch 所捕获，进行相应的错误处理。</p>
<p>.then 方法中的 onRejected 参数所指定的回调函数，实际上针对的是其 promise 对象或者之前的 promise 对象，而不是针对.then 方法里面指定的第一个参数，即 onResolved 所指向的对象，这也是 then 和 catch 表现不同的原因。</p>
<p>1）使用 promise.then(onResolved, onRejected)的话</p>
<p>在 onResolved 中发生异常的话，在 onRejected 中是捕获不到这个异常的。</p>
<p>2）在 promise.then(onResolved).catch(onRejected)的情况下</p>
<p>then 中产生的异常能在.catch 中捕获</p>
<p>3）.then 和.catch 在本质上是没有区别的</p>
<p>需要分场合使用。</p>
<p>我们需要注意如果代码类似 badMain 那样的话，就可能出现程序不会按预期运行的情况，从而不能正确的进行错误处理。</p>
<h2 id="IE8-及-IE8-以下-catch-兼容问题"><a href="#IE8-及-IE8-以下-catch-兼容问题" class="headerlink" title="IE8 及 IE8 以下 catch 兼容问题"></a>IE8 及 IE8 以下 catch 兼容问题</h2><p>IE8 及 IE8 以下即使已经引入了 Promise 的 polyfill，使用 catch 方法仍然会出现 identifier not found 的语法错误。</p>
<p>这是怎么回事呢？实际上这和 catch 是 ECMAScript 的保留字(Reserved Word)有关。</p>
<p>在 ECMAScript 3 中保留字是不能作为对象的属性名使用的。而 IE8 及以下版本都是基于 ECMAScript 3 实现的，因此不能将 catch 作为属性来使用，也就不能编写类似 promise.catch()的代码，因此就出现了 identifier not found 这种语法错误了。</p>
<p>而现代浏览器都支持 ECMAScript 5，而在 ECMAScript 5 中保留字都属于 IdentifierName，也可以作为属性名使用了。</p>
<p>点标记法（dot notation）要求对象的属性必须是有效的标识符（在 ECMAScript 3 中则不能使用保留字）。</p>
<p>但是使用中括号标记法（bracket notation）的话，则可以将非合法标识符作为对象的属性名使用。</p>
<pre><code>var promise = Promise.reject(new Error(&#39;message&#39;))
promise[&#39;catch&#39;](function (error) &#123;
    console.error(error)
&#125;)
</code></pre>
<p>由于 catch 标识符可能会导致问题出现，因此一些类库（Library）也采用了 caught 作为函数名，而函数要完成的工作是一样的。</p>
<p>而且很多压缩工具自带了将 promise.catch 转换为 promise[‘catch’]的功能，所以可能不经意之间也能帮我们解决这个问题。</p>
<h2 id="使用-reject-而不是-throw"><a href="#使用-reject-而不是-throw" class="headerlink" title="使用 reject 而不是 throw"></a>使用 reject 而不是 throw</h2><pre><code>var promise = new Promise(function (resolve, reject) &#123;
    throw new Error(&quot;message&quot;)
&#125;)

promise.catch(function (error) &#123;
    console.error(error) // =&gt; &quot;message&quot;
&#125;)
</code></pre>
<p>上面代码其实并没有什么问题，但是有两个不好的地方：</p>
<p>首先是因为我们很难区分 throw 是我们主动抛出来的，还是因为真正的其它异常导致的。</p>
<p>其次本来这是和调试没有关系的地方，throw 时就会触发调试器的 break 行为，会干扰浏览器的调试器中 break 的功能的正常使用。</p>
<p>所以使用 reject 会比使用 throw 安全。</p>
<h2 id="再议-Promise-resolve-和-Thenable"><a href="#再议-Promise-resolve-和-Thenable" class="headerlink" title="再议 Promise.resolve 和 Thenable"></a>再议 Promise.resolve 和 Thenable</h2><p>之前我们已经讲过 Promise.resolve 能将 thenable 对象转化为 promise 对象。接下来我们再看看将 thenable 对象转换为 promise 对象这个功能都能具体做些什么事情。</p>
<p>以 Web Notification 为例，普通使用回调函数方式如下：</p>
<pre><code>function notifyMessage (message, options, callback) &#123;
    if (Notification &amp;&amp; Notification.permission === &#39;granted&#39;) &#123;
        var notification = new Notification(message, options)
        callback(null, notification)
    &#125; else if (Notification.requestPermission) &#123;
        Notification.requestPermission(function (status) &#123;
            if (Notification.permission !== status) &#123;
                Notification.permission = status
            &#125;
            if (status === &#39;granted&#39;) &#123;
                var notification = new Notification(message, options)
                callback(null, notification)
            &#125; else &#123;
                callback(new Error(&#39;user denied&#39;))
            &#125;
        &#125;)
    &#125; else &#123;
        callback(new Error(&#39;doesn\&#39;t support Notification API&#39;))
    &#125;
&#125;

// 运行实例
// 第二个参数是传给 `Notification` 的option对象
notifyMessage(&#39;Hi!&#39;, &#123;&#125;, function (error, notification) &#123;
    if (error) &#123;
        return console.error(error)
    &#125;
    console.log(notification) // 通知对象
&#125;)
</code></pre>
<p>使用 Promise 改写回调：</p>
<pre><code>function notifyMessage (message, options, callback) &#123;
    if (Notification &amp;&amp; Notification.permission === &#39;granted&#39;) &#123;
        var notification = new Notification(message, options)
        callback(null, notification)
    &#125; else if (Notification.requestPermission) &#123;
        Notification.requestPermission(function (status) &#123;
            if (Notification.permission !== status) &#123;
                Notification.permission = status
            &#125;
            if (status === &#39;granted&#39;) &#123;
                var notification = new Notification(message, options)
                callback(null, notification)
            &#125; else &#123;
                callback(new Error(&#39;user denied&#39;))
            &#125;
        &#125;)
    &#125; else &#123;
        callback(new Error(&#39;doesn\&#39;t support Notification API&#39;))
    &#125;
&#125;

function notifyMessageAsPromise (message, options) &#123;
    return new Promise(function (resolve, reject) &#123;
        notifyMessage(message, options, function (error, notification) &#123;
            if (error) &#123;
                reject(error)
            &#125; else &#123;
                resolve(notification)
            &#125;
        &#125;)
    &#125;)
&#125;

// 运行示例
notifyMessageAsPromise(&#39;Hi!&#39;).then(function (notification) &#123;
    console.log(notification) // 通知对象
&#125;).catch(function(error)&#123;
    console.error(error)
&#125;)
</code></pre>
<p>使用 thenable 对象形式：</p>
<pre><code>function notifyMessage (message, options, callback) &#123;
    if (Notification &amp;&amp; Notification.permission === &#39;granted&#39;) &#123;
        var notification = new Notification(message, options)
        callback(null, notification)
    &#125; else if (Notification.requestPermission) &#123;
        Notification.requestPermission(function (status) &#123;
            if (Notification.permission !== status) &#123;
                Notification.permission = status
            &#125;
            if (status === &#39;granted&#39;) &#123;
                var notification = new Notification(message, options)
                callback(null, notification)
            &#125; else &#123;
                callback(new Error(&#39;user denied&#39;))
            &#125;
        &#125;)
    &#125; else &#123;
        callback(new Error(&#39;doesn\&#39;t support Notification API&#39;))
    &#125;
&#125;

// 返回 `thenable`
function notifyMessageAsThenable (message, options) &#123;
    return &#123;
        &#39;then&#39;: function (resolve, reject) &#123;
            notifyMessage(message, options, function (error, notification) &#123;
                if (error) &#123;
                    reject(error)
                &#125; else &#123;
                    resolve(notification)
                &#125;
            &#125;)
        &#125;
    &#125;
&#125;

// 运行示例
Promise.resolve(notifyMessageAsThenable(&#39;message&#39;)).then(function (notification) &#123;
    console.log(notification) // 通知对象
&#125;).catch(function (error) &#123;
    console.error(error)
&#125;)
</code></pre>
<p>Thenable 风格表现为位于回调和 Promise 风格中间的一种状态，不用考虑 Promise 的兼容问题。一般不作为类库的公开 API，更多情况下是在内部使用 Thenable。Thenable 对象更多的是用来在 Promise 类库之间进行相互转换。</p>
<p>使用 thenable 将 promise 对象转换为 Q promise 对象：</p>
<pre><code>var Q = require(&#39;Q&#39;)

// 这是一个ES6的promise对象
var promise = new Promise(function (resolve) &#123;
    resolve(1)
&#125;)

// 变换为Q promise对象
Q(promise).then(function (value) &#123;
    console.log(value)
&#125;).finally(function () &#123; // Q promise对象可以使用finally方法
    console.log(&#39;finally&#39;)
&#125;)
</code></pre>
<h2 id="Deferred-和-Promise"><a href="#Deferred-和-Promise" class="headerlink" title="Deferred 和 Promise"></a>Deferred 和 Promise</h2><p>Deferred 和 Promise 不同，它没有共通的规范，每个 Library 都是根据自己的喜好来实现的。</p>
<p>在这里，我们打算以 jQuery.Deferred 类似的实现为中心进行介绍。</p>
<p>简单来说，Deferred 和 Promise 具有如下的关系。</p>
<ul>
<li>Deferred 拥有 Promis(当然也有的 Deferred 实现并没有内涵 Promise)</li>
<li>Deferred 具备对 Promise 的状态进行操作的特权方法</li>
</ul>
<p>用 Deferred 实现的 getURL（Deferred 基于 promise 实现）：</p>
<pre><code>function Deferred () &#123;
    this.promise = new Promise(function (resolve, reject) &#123;
        this._resolve = resolve
        this._reject = reject
    &#125;.bind(this))
&#125;

Deferred.prototype.resolve = function (value) &#123;
    this._resolve.call(this.promise, value)
&#125;

Deferred.prototype.reject = function (reason) &#123;
    this._reject.call(this.promise, reason)
&#125;

function getURL (URL) &#123;
    var deferred = new Deferred()
    var req = new XMLHttpRequest()
    req.open(&#39;GET&#39;, URL, true)
    req.onload = function () &#123;
        if (req.status === 200) &#123;
            deferred.resolve(req.responseText)
        &#125; else &#123;
            deferred.reject(new Error(req.statusText))
        &#125;
    &#125;
    req.onerror = function () &#123;
        deferred.reject(new Error(req.statusText))
    &#125;
    req.send()
    return deferred.promise
&#125;

// 运行示例
var URL = &#39;http://httpbin.org/get&#39;
getURL(URL).then(function onFulfilled (value)&#123;
    console.log(value)
&#125;).catch(console.error.bind(console))
</code></pre>
<p>Promise 实现的 getURL：</p>
<pre><code>function getURL (URL) &#123;
    return new Promise(function (resolve, reject) &#123;
        var req = new XMLHttpRequest()
        req.open(&#39;GET&#39;, URL, true)
        req.onload = function () &#123;
            if (req.status === 200) &#123;
                resolve(req.responseText)
            &#125; else &#123;
                reject(new Error(req.statusText))
            &#125;
        &#125;
        req.onerror = function () &#123;
            reject(new Error(req.statusText))
        &#125;
        req.send()
    &#125;)
&#125;

// 运行示例
var URL = &#39;http://httpbin.org/get&#39;
getURL(URL).then(function onFulfilled (value)&#123;
    console.log(value)
&#125;).catch(console.error.bind(console))
</code></pre>
<p>对比上述两个版本的 getURL ，我们发现它们有如下不同。</p>
<ul>
<li>Deferred 的话不需要将代码用 Promise 括起来，由于没有被嵌套在函数中，可以减少一层缩进。</li>
<li>反过来没有 Promise 里的错误处理逻辑。</li>
</ul>
<p>在以下方面，它们则完成了同样的工作。</p>
<ul>
<li>整体处理流程，调用 resolve、reject 的时机。</li>
<li>函数都返回了 promise 对象。</li>
</ul>
<p>由于 Deferred 包含了 Promise，所以大体的流程还是差不多的，不过 Deferred 有对 Promise 进行操作的特权方法，以及可以对流程控制进行自由定制。</p>
<p>上面我们只是简单的实现了一个 Deferred ，我想你已经看到了它和 Promise 之间的差异了吧。</p>
<p>如果说 Promise 是用来对值进行抽象的话，Deferred 则是对处理还没有结束的状态或操作进行抽象化的对象，我们也可以从这一层的区别来理解一下这两者之间的差异。</p>
<p>换句话说，Promise 代表了一个对象，这个对象的状态现在还不确定，但是未来一个时间点它的状态要么变为正常值（FulFilled），要么变为异常值（Rejected）；而 Deferred 对象表示了一个处理还没有结束的这种事实，在它的处理结束的时候，可以通过 Promise 来取得处理结果。</p>
<h2 id="使用-Promise-race-和-delay-取消-XHR-请求"><a href="#使用-Promise-race-和-delay-取消-XHR-请求" class="headerlink" title="使用 Promise.race 和 delay 取消 XHR 请求"></a>使用 Promise.race 和 delay 取消 XHR 请求</h2><p>XHR 有一个 timeout 属性，使用该属性也可以简单实现超时功能，但是为了能支持多个 XHR 同时超时或者其他功能，我们采用了容易理解的异步方式在 XHR 中通过超时来实现取消正在进行中的操作。</p>
<p>1）让 Promise 等待指定时间</p>
<pre><code>function delayPromise (ms) &#123;
    return new Promise(function (resolve) &#123;
        setTimeout(resolve, ms)
    &#125;)
&#125;

delayPromise(100).then(function () &#123;
    alert(&#39;已经过了100ms！&#39;)
&#125;)
</code></pre>
<ol start="2">
<li><p>使用 promise.race()来实现超时 promise：</p>
<p>function timeoutPromise (promise, ms) {<br>var timeout = delayPromise(ms).then(function () {<br>throw new Error(‘Operation timed out after ‘ + ms + ‘ ms’)<br>})<br>return Promise.race([promise, timeout])<br>}</p>
</li>
</ol>
<p>上面代码 promise 的状态改变的时间超过了 ms 就会 throw Error。</p>
<pre><code>// 运行示例
var taskPromise = new Promise(function(resolve)&#123;
    // 随便一些什么处理
    var delay = Math.random() * 2000
    setTimeout(function() &#123;
        resolve(delay + &#39;ms&#39;)
    &#125;, delay)
&#125;)

timeoutPromise(taskPromise, 1000).then(function (value) &#123;
    console.log(&#39;taskPromise在规定时间内结束 : &#39; + value)
&#125;).catch(function (error) &#123;
    console.log(&#39;发生超时&#39;, error)
&#125;)
</code></pre>
<p>3）定制 Error 对象</p>
<p>为了能区分这个 Error 对象的类型，我们再来定义一个 Error 对象的子类 TimeoutError。</p>
<pre><code>function copyOwnFrom (target, source) &#123;
    Object.getOwnPropertyNames(source).forEach(function (propName) &#123;
        Object.defineProperty(target, propName, Object.getOwnPropertyDescriptor(source, propName))
    &#125;)
    return target
&#125;

function TimeoutError () &#123;
    var superInstance = Error.apply(null, arguments)
    copyOwnFrom(this, superInstance)
&#125;

TimeoutError.prototype = Object.create(Error.prototype)
TimeoutError.prototype.constructor = TimeoutError
</code></pre>
<p>它的使用方法和普通的 Error 对象一样，使用 throw 语句即可</p>
<pre><code>var promise = new Promise(function () &#123;
    throw new TimeoutError(&#39;timeout&#39;)
&#125;)

promise.catch(function (error) &#123;
    console.log(error instanceof TimeoutError) // true
&#125;)
</code></pre>
<p>有了这个 TimeoutError 对象，我们就能很容易区分捕获的到底是因为超时而导致的错误，还是其他原因导致的 Error 对象了。</p>
<p>4）通过超时取消 XHR 操作</p>
<p>取消 XHR 操作本身的话并不难，只需要调用 XMLHttpRequest 对象的 abort()方法就可以了。</p>
<p>为了能在外部调用 abort()方法，我们先对之前本节出现的 getURL 进行简单的扩展，cancelableXHR 方法除了返回一个包装了 XHR 的 promise 对象之外，还返回了一个用于取消该 XHR 请求的 abort 方法。</p>
<pre><code>function copyOwnFrom (target, source) &#123;
    Object.getOwnPropertyNames(source).forEach(function (propName) &#123;
        Object.defineProperty(target, propName, Object.getOwnPropertyDescriptor(source, propName))
    &#125;)
    return target
&#125;

function TimeoutError () &#123;
    var superInstance = Error.apply(null, arguments)
    copyOwnFrom(this, superInstance)
&#125;

TimeoutError.prototype = Object.create(Error.prototype)
TimeoutError.prototype.constructor = TimeoutError

function delayPromise (ms) &#123;
    return new Promise(function (resolve) &#123;
        setTimeout(resolve, ms)
    &#125;)
&#125;

function timeoutPromise(promise, ms) &#123;
    var timeout = delayPromise(ms).then(function () &#123;
            return Promise.reject(new TimeoutError(&#39;Operation timed out after &#39; + ms + &#39; ms&#39;))
        &#125;)
    return Promise.race([promise, timeout])
&#125;

function cancelableXHR(URL) &#123;
    var req = new XMLHttpRequest()
    var promise = new Promise(function (resolve, reject) &#123;
        req.open(&#39;GET&#39;, URL, true)
        req.onload = function () &#123;
            if (req.status === 200) &#123;
                resolve(req.responseText)
            &#125; else &#123;
                reject(new Error(req.statusText))
            &#125;
        &#125;
        req.onerror = function () &#123;
            reject(new Error(req.statusText))
        &#125;
        req.onabort = function () &#123;
            reject(new Error(&#39;abort this request&#39;))
        &#125;
        req.send()
    &#125;)
    var abort = function () &#123;
        // 如果request还没有结束的话就执行abort
        // https://developer.mozilla.org/en/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest
        if (req.readyState !== XMLHttpRequest.UNSENT) &#123;
            req.abort()
        &#125;
    &#125;
    return &#123;
        promise: promise,
        abort: abort
    &#125;
&#125;

var object = cancelableXHR(&#39;http://httpbin.org/get&#39;)

// main
timeoutPromise(object.promise, 1000).then(function (contents) &#123;
    console.log(&#39;Contents&#39;, contents)
&#125;).catch(function (error) &#123;
    if (error instanceof TimeoutError) &#123;
        object.abort()
        return console.log(error)
    &#125;
    console.log(&#39;XHR Error :&#39;, error)
&#125;)
</code></pre>
<p>5）代码分割优化处理</p>
<p>在前面的 cancelableXHR 中，promise 对象及其操作方法都是在一个对象中返回的，看起来稍微有些不太好理解。</p>
<p>从代码组织的角度来说一个函数只返回一个值（promise 对象）是一个非常好的习惯，但是由于在外面不能访问 cancelableXHR 方法中创建的 req 变量，所以我们需要编写一个专门的函数（上面的例子中的 abort）来对这些内部对象进行处理。</p>
<p>当然也可以考虑到对返回的 promise 对象进行扩展，使其支持 abort 方法，但是由于 promise 对象是对值进行抽象化的对象，如果不加限制的增加操作用的方法的话，会使整体变得非常复杂。</p>
<p>大家都知道一个函数做太多的工作都不认为是一个好的习惯，因此我们不会让一个函数完成所有功能，也许像下面这样对函数进行分割是一个不错的选择。</p>
<ul>
<li>返回包含 XHR 的 promise 对象</li>
<li>接收 promise 对象作为参数并取消该对象中的 XHR 请求</li>
</ul>
<p>将这些处理整理为一个模块的话，以后扩展起来也方便，一个函数所做的工作也会比较精炼，代码也会更容易阅读和维护。</p>
<p>使用 common.js 规范来写 cancelableXHR.js：</p>
<pre><code>&#39;use strict&#39;
var requestMap = &#123;&#125;

function createXHRPromise (URL) &#123;
    var req = new XMLHttpRequest()
    var promise = new Promise(function (resolve, reject) &#123;
        req.open(&#39;GET&#39;, URL, true)
        req.onreadystatechange = function () &#123;
            if (req.readyState === XMLHttpRequest.DONE) &#123;
                delete requestMap[URL]
            &#125;
        &#125;
        req.onload = function () &#123;
            if (req.status === 200) &#123;
                resolve(req.responseText)
            &#125; else &#123;
                reject(new Error(req.statusText))
            &#125;
        &#125;
        req.onerror = function () &#123;
            reject(new Error(req.statusText))
        &#125;
        req.onabort = function () &#123;
            reject(new Error(&#39;abort this req&#39;))
        &#125;
        req.send()
    &#125;)
    requestMap[URL] = &#123;
        promise: promise,
        request: req
    &#125;
    return promise
&#125;

function abortPromise (promise) &#123;
    if (typeof promise === &#39;undefined&#39;) &#123;
        return
    &#125;
    var request
    Object.keys(requestMap).some(function (URL) &#123;
        if (requestMap[URL].promise === promise) &#123;
            request = requestMap[URL].request
            return true
        &#125;
    &#125;)
    if (request != null &amp;&amp; request.readyState !== XMLHttpRequest.UNSENT) &#123;
        request.abort()
    &#125;
&#125;

module.exports.createXHRPromise = createXHRPromise
module.exports.abortPromise = abortPromise
</code></pre>
<p>调用：</p>
<pre><code>var cancelableXHR = require(&#39;./cancelableXHR&#39;)

var xhrPromise = cancelableXHR.createXHRPromise(&#39;http://httpbin.org/get&#39;) // 创建包装了XHR的promise对象

xhrPromise.catch(function (error) &#123;
    // 调用 abort 抛出的错误
&#125;)

cancelableXHR.abortPromise(xhrPromise) //     取消在创建的promise对象的请求操作
</code></pre>
<h2 id="promise-串行处理"><a href="#promise-串行处理" class="headerlink" title="promise 串行处理"></a>promise 串行处理</h2><p>Promise.all()可以进行 promise 对象的并行处理，那么怎么实现串行处理呢？</p>
<p>我们将处理内容统一放到数组里，再配合 for 循环进行处理：</p>
<pre><code>var request = &#123;
    comment: function getComment () &#123;
        return getURL(&#39;http://azu.github.io/promises-book/json/comment.json&#39;).then(JSON.parse)
    &#125;,
    people: function getPeople () &#123;
        return getURL(&#39;http://azu.github.io/promises-book/json/people.json&#39;).then(JSON.parse)
    &#125;
&#125;

function main() &#123;
    function recordValue(results, value) &#123;
        results.push(value)
        return results
    &#125;

    // [] 用来保存初始化值
    var pushValue = recordValue.bind(null, [])

    // 返回promise对象的函数的数组
    var tasks = [request.comment, request.people]

    var promise = Promise.resolve()

    // 开始的地方
    for (var i = 0; i &lt; tasks.length; i++) &#123;
        var task = tasks[i]
        promise = promise.then(task).then(pushValue)
    &#125;

    return promise
&#125;

// 运行示例
main().then(function (value) &#123;
    console.log(value)
&#125;).catch(function (error) &#123;
    console.error(error)
&#125;)
</code></pre>
<p>上面代码中的 promise = promise.then(task).then(pushValue)通过不断对 promise 进行处理，不断的覆盖 promise 变量的值，以达到对 promise 对象的累积处理效果。</p>
<p>但是这种方法需要 promise 这个临时变量，从代码质量上来说显得不那么简洁。我们可以使用 Array.prototype.reduce 来优化 main 函数：</p>
<pre><code>function main() &#123;

    function recordValue (results, value) &#123;
        results.push(value)
        return results
    &#125;

    var pushValue = recordValue.bind(null, [])
    var tasks = [request.comment, request.people]

    return tasks.reduce(function (promise, task) &#123;
        return promise.then(task).then(pushValue)
    &#125;, Promise.resolve())
&#125;
</code></pre>
<p>实际上我们可以提炼出进行顺序处理的函数：</p>
<pre><code>function sequenceTasks(tasks) &#123;
    function recordValue(results, value) &#123;
        results.push(value)
        return results
    &#125;
    var pushValue = recordValue.bind(null, [])
    return tasks.reduce(function (promise, task) &#123;
        return promise.then(task).then(pushValue)
    &#125;, Promise.resolve())
&#125;
</code></pre>
<p>这样我们只要如下调用，代码也更加清晰易懂了：</p>
<pre><code>var request = &#123;
    comment: function getComment() &#123;
        return getURL(&#39;http://azu.github.io/promises-book/json/comment.json&#39;).then(JSON.parse)
    &#125;,
    people: function getPeople() &#123;
        return getURL(&#39;http://azu.github.io/promises-book/json/people.json&#39;).then(JSON.parse)
    &#125;
&#125;

function main() &#123;
    return sequenceTasks([request.comment, request.people])
&#125;

// 运行示例
main().then(function (value) &#123;
    console.log(value)
&#125;).catch(function (error) &#123;
    console.error(error)
&#125;)
</code></pre>
<h2 id="同时请求按序处理"><a href="#同时请求按序处理" class="headerlink" title="同时请求按序处理"></a>同时请求按序处理</h2><p>下面的内容来自 google 开发社区的一篇关于 promise 的文章<a target="_blank" rel="noopener" href="https://developers.google.com/web/fundamentals/getting-started/primers/promises#_9">JavaScript Promise：简介</a></p>
<p>假设我们要根据 story.json 通过 ajax 获取章节内容，每一次 ajax 只能获取一节内容。那么怎么做到又快又能按序展示章节内容呢？即如果第一章下载完后，我们可将其添加到页面。这可让用户在其他章节下载完毕前先开始阅读。如果第三章比第二章先下载完后，我们不将其添加到页面，因为还缺少第二章。第二章下载完后，我们可添加第二章和第三章，后面章节也是如此添加。</p>
<p>前一节的串行方法只能一个 ajax 请求 task 处理完后再去执行下一个 task，而 Promise.all()能同时请求，但是只有全部请求结束后才能得到有序的数组。</p>
<p>具体实现请看下面实例。</p>
<p>我们可以使用 JSON 来同时获取所有章节，然后创建一个向文档中添加章节的顺序。</p>
<p>story.json 如下：</p>
<pre><code>&#123;
    &quot;heading&quot;: &quot;&lt;h1&gt;A story about something&lt;/h1&gt;&quot;,
    &quot;chapterUrls&quot;: [
        &quot;chapter-1.json&quot;,
        &quot;chapter-2.json&quot;,
        &quot;chapter-3.json&quot;,
        &quot;chapter-4.json&quot;,
        &quot;chapter-5.json&quot;
    ]
&#125;
</code></pre>
<p>具体处理代码：</p>
<pre><code>function getJson(url) &#123;
  return get(url).then(JSON.parse)
&#125;

getJSON(&#39;story.json&#39;)
    .then(function (story) &#123;
        addHtmlToPage(story.heading) // 文章头部添加到页面

        // 将拿到的chapterUrls数组map为json promises数组，这样可以保证并行下载
          return story.chapterUrls
              .map(getJSON)
            .reduce(function(sequence, chapterPromise) &#123;
                // 用reduce方法链式调用promises，并将每个章节的内容到添加页面
                  return sequence.then(function () &#123;
                    // 等待获取当前准备插入页面的顺序的资源，然后等待这个顺序对应章节的成功请求
                    // Wait for everything in the sequence so far, then wait for this chapter to arrive.
                    return chapterPromise
                  &#125;).then(function(chapter) &#123;
                    addHtmlToPage(chapter.html) // 将章节内容到添加页面
                  &#125;)
            &#125;, Promise.resolve())
    &#125;)
    .then(function() &#123;
          addTextToPage(&#39;All done&#39;) // 页面添加All done文字
    &#125;)
    .catch(function(err) &#123;
          // catch错误信息
          addTextToPage(&#39;Argh, broken: &#39;&#39; + err.message)
    &#125;)
    .then(function() &#123;
          document.querySelector(&#39;.spinner&#39;).style.display = &#39;none&#39; // 关闭加载提示
    &#125;)
</code></pre>
<h2 id="Promise-和链式调用"><a href="#Promise-和链式调用" class="headerlink" title="Promise 和链式调用"></a>Promise 和链式调用</h2><p>在 Promise 中你可以将 then 和 catch 等方法连在一起写。这非常像 DOM 或者 jQuery 中的链式调用。</p>
<p>一般的方法链都通过返回 this 将多个方法串联起来。</p>
<p>那么怎么在不改变已有采用了方法链编写的代码的外部接口的前提下，如何在内部使用 Promise 进行重写呢？</p>
<p>1）fs 中的方法链</p>
<p>以 Node.js 中的 fs 为例。</p>
<p>此外，这里的例子我们更重视代码的易理解性，因此从实际上来说这个例子可能并不算太实用。</p>
<p>有 fs-method-chain.js：</p>
<pre><code>&#39;use strict&#39;
var fs = require(&#39;fs&#39;)

function File() &#123;
    this.lastValue = null
&#125;

// Static method for File.prototype.read
File.read = function FileRead(filePath) &#123;
    var file = new File()
    return file.read(filePath)
&#125;

File.prototype.read = function (filePath) &#123;
    this.lastValue = fs.readFileSync(filePath, &#39;utf-8&#39;)
    return this
&#125;

File.prototype.transform = function (fn) &#123;
    this.lastValue = fn.call(this, this.lastValue)
    return this
&#125;

File.prototype.write = function (filePath) &#123;
    this.lastValue = fs.writeFileSync(filePath, this.lastValue)
    return this
&#125;

module.exports = File
</code></pre>
<p>调用：</p>
<pre><code>var File = require(&#39;./fs-method-chain&#39;)
var inputFilePath = &#39;input.txt&#39;,
    outputFilePath = &#39;output.txt&#39;
File.read(inputFilePath)
    .transform(function (content) &#123;
        return &#39;&gt;&gt;&#39; + content
    &#125;)
    .write(outputFilePath)
</code></pre>
<p>2）基于 Promise 的 fs 方法链</p>
<p>下面我们就在不改变刚才的方法链对外接口的前提下，采用 Promise 对内部实现进行重写。</p>
<pre><code>&#39;use strict&#39;
var fs = require(&#39;fs&#39;)

function File() &#123;
    this.promise = Promise.resolve()
&#125;

// Static method for File.prototype.read
File.read = function (filePath) &#123;
    var file = new File()
    return file.read(filePath)
&#125;

File.prototype.then = function (onFulfilled, onRejected) &#123;
    this.promise = this.promise.then(onFulfilled, onRejected)
    return this
&#125;

File.prototype[&#39;catch&#39;] = function (onRejected) &#123;
    this.promise = this.promise.catch(onRejected)
    return this
&#125;

File.prototype.read = function (filePath) &#123;
    return this.then(function () &#123;
        return fs.readFileSync(filePath, &#39;utf-8&#39;)
    &#125;)
&#125;

File.prototype.transform = function (fn) &#123;
    return this.then(fn)
&#125;

File.prototype.write = function (filePath) &#123;
    return this.then(function (data) &#123;
        return fs.writeFileSync(filePath, data)
    &#125;)
&#125;

module.exports = File
</code></pre>
<p>3）两者的区别</p>
<p>要说 fs-method-chain.js 和 Promise 版两者之间的差别，最大的不同那就要算是同步和异步了。</p>
<p>如果在类似 fs-method-chain.js 的方法链中加入队列等处理的话，就可以实现几乎和异步方法链同样的功能，但是实现将会变得非常复杂，所以我们选择了简单的同步方法链。</p>
<p>Promise 版的话如同之前章节所说只会进行异步操作，因此使用了 promise 的方法链也是异步的。</p>
<p>另外两者的错误处理方式也是不一致的。</p>
<p>虽然 fs-method-chain.js 里面并不包含错误处理的逻辑，但是由于是同步操作，因此可以将整段代码用 try-catch 包起来。</p>
<p>在 Promise 版提供了指向内部 promise 对象的 then 和 catch 别名，所以我们可以像其它 promise 对象一样使用 catch 来进行错误处理。</p>
<p>如果你想在 fs-method-chain.js 中自己实现异步处理的话，错误处理可能会成为比较大的问题；可以说在进行异步处理的时候，还是使用 Promise 实现起来比较简单。</p>
<p>4）Promise 之外的异步处理</p>
<p>如果你很熟悉 Node.js 的話，那么看到方法链的话，你是不是会想起来 Stream 呢。</p>
<p>如果使用 Stream 的话，就可以免去了保存 this.lastValue 的麻烦，还能改善处理大文件时候的性能。 另外，使用 Stream 的话可能会比使用 Promise 在处理速度上会快些。</p>
<p>因此，在异步处理的时候并不是说 Promise 永远都是最好的选择，要根据自己的目的和实际情况选择合适的实现方式。</p>
<p>5）Promise wrapper</p>
<p>再回到 fs-method-chain.js 和 Promise 版，这两种方法相比较内部实现也非常相近，让人觉得是不是同步版本的代码可以直接就当做异步方式来使用呢？</p>
<p>由于 JavaScript 可以向对象动态添加方法，所以从理论上来说应该可以从非 Promise 版自动生成 Promise 版的代码。（当然静态定义的实现方式容易处理）</p>
<p>尽管 ES6 Promises 并没有提供此功能，但是著名的第三方 Promise 实现类库 bluebird 等提供了被称为 Promisification 的功能。</p>
<p>如果使用类似这样的类库，那么就可以动态给对象增加 promise 版的方法。</p>
<pre><code>var fs = Promise.promisifyAll(require(&#39;fs&#39;))

fs.readFileAsync(&#39;myfile.js&#39;, &#39;utf8&#39;).then(function (contents) &#123;
    console.log(contents)
&#125;).catch(function (e) &#123;
    console.error(e.stack)
&#125;)
</code></pre>
<p>前面的 Promisification 具体都干了些什么光凭想象恐怕不太容易理解，我们可以通过给原生 Array 增加 Promise 版的方法为例来进行说明。</p>
<p>在 JavaScript 中原生 DOM 或 String 等也提供了很多创建方法链的功能。Array 中就有诸如 map 和 filter 等方法，这些方法会返回一个数组类型，可以用这些方法方便的组建方法链。</p>
<pre><code>&#39;use strict&#39;

function ArrayAsPromise (array) &#123;
    this.array = array
    this.promise = Promise.resolve()
&#125;

ArrayAsPromise.prototype.then = function (onFulfilled, onRejected) &#123;
    this.promise = this.promise.then(onFulfilled, onRejected)
    return this
&#125;

ArrayAsPromise.prototype[&#39;catch&#39;] = function (onRejected) &#123;
    this.promise = this.promise.catch(onRejected)
    return this
&#125;

Object.getOwnPropertyNames(Array.prototype).forEach(function (methodName) &#123;
    // Don&#39;t overwrite
    if (typeof ArrayAsPromise[methodName] !== &#39;undefined&#39;) &#123;
        return
    &#125;
    var arrayMethod = Array.prototype[methodName]
    if (typeof  arrayMethod !== &#39;function&#39;) &#123;
        return
    &#125;
    ArrayAsPromise.prototype[methodName] = function () &#123;
        var that = this
        var args = arguments
        this.promise = this.promise.then(function () &#123;
            that.array = Array.prototype[methodName].apply(that.array, args)
            return that.array
        &#125;)
        return this
    &#125;
&#125;)

module.exports = ArrayAsPromise
module.exports.array = function newArrayAsPromise (array) &#123;
    return new ArrayAsPromise(array)
&#125;
</code></pre>
<p>原生的 Array 和 ArrayAsPromise 在使用时有什么差异呢？我们可以通过对上面的代码进行测试来了解它们之间的不同点。</p>
<pre><code>&#39;use strict&#39;
var assert = require(&#39;power-assert&#39;)
var ArrayAsPromise = require(&#39;../src/promise-chain/array-promise-chain&#39;)

describe(&#39;array-promise-chain&#39;, function () &#123;
    function isEven(value) &#123;
        return value % 2 === 0
    &#125;

    function double(value) &#123;
        return value * 2
    &#125;

    beforeEach(function () &#123;
        this.array = [1, 2, 3, 4, 5]
    &#125;)

    describe(&#39;Native array&#39;, function () &#123;
        it(&#39;can method chain&#39;, function () &#123;
            var result = this.array.filter(isEven).map(double)
            assert.deepEqual(result, [4, 8])
        &#125;)
    &#125;)

    describe(&#39;ArrayAsPromise&#39;, function () &#123;
        it(&#39;can promise chain&#39;, function (done) &#123;
            var array = new ArrayAsPromise(this.array)
            array.filter(isEven).map(double).then(function (value) &#123;
                assert.deepEqual(value, [4, 8])
            &#125;).then(done, done)
        &#125;)
    &#125;)
&#125;)
</code></pre>
<p>我们看到，在 ArrayAsPromise 中也能使用 Array 的方法。原生的 Array 是同步处理，而 ArrayAsPromise 则是异步处理。</p>
<p>仔细看一下 ArrayAsPromise 的实现，也许你已经注意到了，Array.prototype 的所有方法都被实现了。但是，Array.prototype 中也存在着类似 array.indexOf 等并不会返回数组类型数据的方法，这些方法如果也要支持链式调用的话就有些不自然了。</p>
<p>在这里非常重要的一点是，我们可以通过这种方式，为具有接收相同类型数据接口的 API 动态的创建 Promise 版的 API。如果我们能意识到这种 API 的规则性的话，那么就可能发现一些新的使用方法。</p>
<h2 id="自己实现一个-Promise-类"><a href="#自己实现一个-Promise-类" class="headerlink" title="自己实现一个 Promise 类"></a>自己实现一个 Promise 类</h2><p><a href="https://github.com/xieranmaya/blog/issues/3">剖析 Promise 内部结构，一步一步实现一个完整的、能通过所有 Test case 的 Promise 类</a></p>
<h2 id="Promise-反面模式（anti-pattern）"><a href="#Promise-反面模式（anti-pattern）" class="headerlink" title="Promise 反面模式（anti-pattern）"></a>Promise 反面模式（anti-pattern）</h2><p>关于<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%8F%8D%E9%9D%A2%E6%A8%A1%E5%BC%8F">反面模式</a>，维基百科是这样定义的：在软件工程中，一个反面模式（anti-pattern 或 antipattern）指的是在实践中明显出现但又低效或是有待优化的设计模式，是用来解决问题的带有共同性的不良方法。</p>
<p>Promise 中常见的反面模式有嵌套的 promise、没有正确 error handle 等。</p>
<p><a target="_blank" rel="noopener" href="http://taoofcode.net/promise-anti-patterns/">Promise 反面模式原文</a></p>
<p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000007395254">Promise 反面模式中文翻译</a></p>
<h2 id="Promise-常见错误"><a href="#Promise-常见错误" class="headerlink" title="Promise 常见错误"></a>Promise 常见错误</h2><p><a target="_blank" rel="noopener" href="https://pouchdb.com/2015/05/18/we-have-a-problem-with-promises.html">We have a problem with promises 原文</a></p>
<p><a target="_blank" rel="noopener" href="https://div.io/topic/1095">We have a problem with promises 中文翻译</a></p>
<h2 id="其他强大的异步处理方式"><a href="#其他强大的异步处理方式" class="headerlink" title="其他强大的异步处理方式"></a>其他强大的异步处理方式</h2><p>1）使用 async/await</p>
<p>async/await 更加强大，能写出更像同步的代码。但是基础仍然是要掌握 Promise。</p>
<p>2）使用 Rxjs（Angular2 后框架自带）。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="http://liubin.org/promises-book/#introduction">JavaScript Promise 迷你书（中文版）</a></p>
<p><a target="_blank" rel="noopener" href="http://es6.ruanyifeng.com/#docs/promise">阮一峰 ECMAScript6 入门 Promise 对象</a></p>
<p><a target="_blank" rel="noopener" href="https://developers.google.com/web/fundamentals/getting-started/primers/promises#_9">JavaScript Promise：简介</a></p>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">Angus</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://github.com/SilenceZeng/posts/19117.html">https://github.com/SilenceZeng/posts/19117.html</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">Angus</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/javascript/">
                                    <span class="chip bg-color">javascript</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
        </div>
    </div>

    

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/posts/50730.html">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/22.jpg" class="responsive-img" alt="vue 开发2017年变化回顾及2018年展望">
                        
                        <span class="card-title">vue 开发2017年变化回顾及2018年展望</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2021-10-10
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E5%89%8D%E7%AB%AF/" class="post-category">
                                    前端
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/vue/">
                        <span class="chip bg-color">vue</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/posts/3115.html">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/14.jpg" class="responsive-img" alt="git入门大全">
                        
                        <span class="card-title">git入门大全</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2021-10-10
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/" class="post-category">
                                    编程基础
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/git/">
                        <span class="chip bg-color">git</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="503838841"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>

    

    <div class="container row center-align"
         style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2015-2021</span>
            
            <span id="year">2015</span>
            <a href="/about" target="_blank">Angus</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            
            
            
            
            <br>

            <!-- 运行天数提醒. -->
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link ">
    <a href="https://github.com/SilenceZeng" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:tsang1205@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>













    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    

    

    

    <!--腾讯兔小巢-->
    
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
