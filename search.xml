<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>ES6核心内容精讲--快速实践ES6（三）</title>
      <link href="/posts/64450.html"/>
      <url>/posts/64450.html</url>
      
        <content type="html"><![CDATA[<h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><p>Promise是异步编程的一种解决方案。Promise对象表示了异步操作的最终状态（完成或失败）和返回的结果。</p><p>其实我们在jQuery的ajax中已经见识了部分Promise的实现，通过Promise，我们能够将回调转换为链式调用，也起到解耦的作用。</p><h3 id="怎么用"><a href="#怎么用" class="headerlink" title="怎么用"></a>怎么用</h3><p>Promise接口的基本思想是让异步操作返回一个Promise对象</p><h4 id="三种状态和两种变化途径"><a href="#三种状态和两种变化途径" class="headerlink" title="三种状态和两种变化途径"></a>三种状态和两种变化途径</h4><p>Promise对象只有三种状态。</p><ul><li>异步操作“未完成”（pending）</li><li>异步操作“已完成”（resolved，又称fulfilled）</li><li>异步操作“失败”（rejected）</li></ul><p>这三种的状态的变化途径只有两种。</p><ul><li>异步操作从“未完成”到“已完成”</li><li>异步操作从“未完成”到“失败”。</li></ul><p>这种变化只能发生一次，一旦当前状态变为“已完成”或“失败”，就意味着不会再有新的状态变化了。因此，Promise对象的最终结果只有两种。</p><p>异步操作成功，Promise对象传回一个值，状态变为resolved。</p><p>异步操作失败，Promise对象抛出一个错误，状态变为rejected。</p><h4 id="生成Promise对象"><a href="#生成Promise对象" class="headerlink" title="生成Promise对象"></a>生成Promise对象</h4><p>通过new Promise来生成Promise对象：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> promise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">// 异步操作的代码</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token comment">/* 异步操作成功 */</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">resolve</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span><span class="token function">reject</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由JavaScript引擎提供，不用自己部署。</p><p>resolve会将Promise对象的状态从pending变为resolved，reject则是将Promise对象的状态从pending变为rejected。</p><p>Promise构造函数接受一个函数后会立即执行这个函数</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> promise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Hello World'</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token comment">// Hello World</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="then和catch回调"><a href="#then和catch回调" class="headerlink" title="then和catch回调"></a>then和catch回调</h4><p>Promise对象生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数。then方法可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为resolved时调用，第二个回调函数是Promise对象的状态变为rejected时调用。第二个函数是可选的。分别称之为成功回调和失败回调。成功回调接收异步操作成功的结果为参数，失败回调接收异步操作失败报出的错误作为参数。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> promise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'成功'</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>promise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token comment">// 3s后打印'成功'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>catch方法是then(null, rejection)的别名，用于指定发生错误时的回调函数。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> promise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">reject</span><span class="token punctuation">(</span><span class="token string">'失败'</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>promise<span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token comment">// 3s后打印'失败'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h4><p>Promise.all方法用于将多个Promise实例，包装成一个新的Promise实例。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> p <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">(</span><span class="token punctuation">[</span>p1<span class="token punctuation">,</span> p2<span class="token punctuation">,</span> p3<span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上面代码中，Promise.all方法接受一个数组作为参数，p1、p2、p3都是Promise对象的实例，如果不是，就会先调用下面讲到的Promise.resolve方法，将参数转为Promise实例，再进一步处理。（Promise.all方法的参数可以不是数组，但必须具有Iterator接口，且返回的每个成员都是Promise实例。）</p><p>p的状态由p1、p2、p3决定，分成两种情况。</p><p>（1）只有p1、p2、p3的状态都变成resolved，p的状态才会变成resolved，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。</p><p>（2）只要p1、p2、p3之中有一个被Rejected，p的状态就变成Rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。</p><h4 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a>Promise.race()</h4><p>与Promise.all()类似，不过是只要有一个Promise实例先改变了状态，p的状态就是它的状态，传递给回调函数的结果也是它的结果。所以很形象地叫做赛跑。</p><h4 id="Promise-resolve-和Promise-reject"><a href="#Promise-resolve-和Promise-reject" class="headerlink" title="Promise.resolve()和Promise.reject()"></a>Promise.resolve()和Promise.reject()</h4><p>有时需要将现有对象转为Promise对象，可以使用这两个方法。</p><h2 id="Generator（生成器）"><a href="#Generator（生成器）" class="headerlink" title="Generator（生成器）"></a>Generator（生成器）</h2><h3 id="是什么-1"><a href="#是什么-1" class="headerlink" title="是什么"></a>是什么</h3><p>生成器本质上是一种特殊的迭代器（参见本文章系列二之Iterator）。ES6里的迭代器并不是一种新的语法或者是新的内置对象(构造函数)，而是一种协议 (protocol)。所有遵循了这个协议的对象都可以称之为迭代器对象。生成器对象由生成器函数返回并且遵守了迭代器协议。具体参见MDN。</p><h3 id="怎么用-1"><a href="#怎么用-1" class="headerlink" title="怎么用"></a>怎么用</h3><h4 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h4><p>生成器函数的语法为function*，在其函数体内部可以使用yield和yield*关键字。</p><pre><code>function* gen(x)&#123;  console.log(1)  var y = yield x + 2  console.log(2)  return y&#125;var g = gen(1)</code></pre><p>当我们像上面那样调用生成器函数时，会发现并没有输出。这就是生成器函数与普通函数的不同，它可以交出函数的执行权（即暂停执行）。yield表达式就是暂停标志。</p><p>之前提到了生成器对象遵循迭代器协议，所以其实可以通过next方法执行。执行结果也是一个包含value和done属性的对象。</p><p>遍历器对象的next方法的运行逻辑如下。</p><p>（1）遇到yield表达式，就暂停执行后面的操作，并将紧跟在yield后面的那个表达式的值，作为返回的对象的value属性值。</p><p>（2）下一次调用next方法时，再继续往下执行，直到遇到下一个yield表达式。</p><p>（3）如果没有再遇到新的yield表达式，就一直运行到函数结束，直到return语句为止，并将return语句后面的表达式的值，作为返回的对象的value属性值。</p><p>（4）如果该函数没有return语句，则返回的对象的value属性值为undefined。</p><p>需要注意的是，yield表达式后面的表达式，只有当调用next方法、内部指针指向该语句时才会执行。</p><pre><code>g.next() // 1// &#123; value: 3, done: false &#125;g.next() // 2// &#123; value: undefined, done: true &#125;</code></pre><h4 id="for…of遍历"><a href="#for…of遍历" class="headerlink" title="for…of遍历"></a>for…of遍历</h4><p>生成器部署了迭代器接口，因此可以用for…of来遍历，不用调用next方法</p><pre><code>function *foo() &#123;  yield 1  yield 2  yield 3  return 4&#125;for (let v of foo()) &#123;  console.log(v)&#125;// 1// 2// 3</code></pre><h4 id="yield-表达式"><a href="#yield-表达式" class="headerlink" title="yield*表达式"></a>yield*表达式</h4><p>从语法角度看，如果yield表达式后面跟的是一个遍历器对象，需要在yield表达式后面加上星号，表明它返回的是一个遍历器对象。这被称为yield<em>表达式。yield</em>后面只能跟迭代器，yield*的功能是将迭代控制权交给后面的迭代器，达到递归迭代的目的</p><pre><code>function* foo() &#123;  yield &#39;a&#39;  yield &#39;b&#39;&#125;function* bar() &#123;  yield &#39;x&#39;  yield* foo()  yield &#39;y&#39;&#125;for (let v of bar()) &#123;  console.log(v)&#125;// x// a// b// y</code></pre><h4 id="自动执行"><a href="#自动执行" class="headerlink" title="自动执行"></a>自动执行</h4><p>下面是使用Generator函数执行一个真实的异步任务的例子：</p><pre><code>var fetch = require(&#39;node-fetch&#39;)function* gen () &#123;  var url = &#39;https://api.github.com/users/github&#39;  var result = yield fetch(url)  console.log(result.bio)&#125;</code></pre><p>上面代码中，Generator函数封装了一个异步操作，该操作先读取一个远程接口，然后从JSON格式的数据解析信息。这段代码非常像同步操作，除了加上了yield命令。</p><p>执行这段代码的方法如下</p><pre><code>var g = gen()var result = g.next()result  .value  .then(function (data) &#123;    return data.json()  &#125;)  .then(function (data) &#123;    g.next(data)  &#125;)</code></pre><p>上面代码中，首先执行Generator函数，获取遍历器对象，然后使用next方法（第二行），执行异步任务的第一阶段。由于Fetch模块返回的是一个Promise对象，因此要用then方法调用下一个next方法。</p><p>可以看到，虽然Generator函数将异步操作表示得很简洁，但是流程管理却不方便（即何时执行第一阶段、何时执行第二阶段）。</p><p>那么如何自动化异步任务的流程管理呢？</p><p>Generator函数就是一个异步操作的容器。它的自动执行需要一种机制，当异步操作有了结果，能够自动交回执行权。</p><p>两种方法可以做到这一点。</p><ol><li><p>回调函数。将异步操作包装成Thunk函数，在回调函数里面交回执行权。</p></li><li><p>Promise对象。将异步操作包装成Promise对象，用then方法交回执行权。</p></li></ol><h4 id="Thunk函数"><a href="#Thunk函数" class="headerlink" title="Thunk函数"></a>Thunk函数</h4><p>本节很简略，可能会看不太明白，请参考<a href="http://www.ruanyifeng.com/blog/2015/05/thunk.html">Thunk 函数的含义和用法</a></p><p>Thunk函数的含义：编译器的”传名调用”实现，往往是将参数放到一个临时函数之中，再将这个临时函数传入函数体。这个临时函数就叫做Thunk函数。</p><p>JavaScript语言是传值调用，它的Thunk函数含义有所不同。在JavaScript语言中，Thunk函数替换的不是表达式，而是多参数函数，将其替换成单参数的版本，且只接受回调函数作为参数。</p><p>任何函数，只要参数有回调函数，就能写成Thunk函数的形式，可以通过一个Thunk函数转换器来转换。</p><p>Thunk函数真正的威力，在于可以自动执行Generator函数。我们可以实现一个基于Thunk函数的Generator执行器，然后直接把Generator函数传入这个执行器即可。</p><pre><code>function run(fn) &#123;  var gen = fn()  function next(err, data) &#123;    var result = gen.next(data)    if (result.done) return    result.value(next)  &#125;  next()&#125;function* g() &#123;  // ...&#125;run(g)</code></pre><p>Thunk函数并不是Generator函数自动执行的唯一方案。因为自动执行的关键是，必须有一种机制，自动控制Generator函数的流程，接收和交还程序的执行权。回调函数可以做到这一点，Promise对象也可以做到这一点。</p><h4 id="基于Promise对象的自动执行"><a href="#基于Promise对象的自动执行" class="headerlink" title="基于Promise对象的自动执行"></a>基于Promise对象的自动执行</h4><p>首先，将方法包装成一个Promise对象（fs是nodejs的一个内置模块）。</p><pre><code>var fs = require(&#39;fs&#39;)var readFile = function (fileName) &#123;  return new Promise(function (resolve, reject) &#123;    fs.readFile(fileName, function (error, data) &#123;      if (error) reject(error)      resolve(data)    &#125;)  &#125;)&#125;var gen = function* () &#123;  var f1 = yield readFile(&#39;/etc/fstab&#39;)  var f2 = yield readFile(&#39;/etc/shells&#39;)  console.log(f1.toString())  console.log(f2.toString())&#125;</code></pre><p>然后，手动执行上面的Generator函数。</p><pre><code>var g = gen()g.next().value.then(function (data) &#123;  g.next(data).value.then(function (data) &#123;    g.next(data)  &#125;)&#125;)</code></pre><p>观察上面的执行过程，其实是在递归调用，我们可以用一个函数来实现：</p><pre><code>function run(gen)&#123;  var g = gen()  function next(data)&#123;    var result = g.next(data)    if (result.done) return result.value    result.value.then(function(data)&#123;      next(data)    &#125;)  &#125;  next()&#125;run(gen)</code></pre><p>上面代码中，只要Generator函数还没执行到最后一步，next函数就调用自身，以此实现自动执行。</p><h4 id="co模块"><a href="#co模块" class="headerlink" title="co模块"></a>co模块</h4><p><a href="https://github.com/tj/co">co模块</a>是nodejs社区著名的TJ大神写的一个小工具，用于Generator函数的自动执行。</p><p>下面是一个Generator函数,用于依次读取两个文件</p><pre><code>var gen = function* () &#123;  var f1 = yield readFile(&#39;/etc/fstab&#39;)  var f2 = yield readFile(&#39;/etc/shells&#39;)  console.log(f1.toString())  console.log(f2.toString())&#125;var co = require(&#39;co&#39;)co(gen)</code></pre><p>co模块可以让你不用编写Generator函数的执行器。Generator函数只要传入co函数，就会自动执行。co函数返回一个Promise对象，因此可以用then方法添加回调函数。</p><pre><code>co(gen).then(function () &#123;  console.log(&#39;Generator 函数执行完成&#39;)&#125;)</code></pre><p>co模块的原理：其实就是将两种自动执行器（Thunk函数和Promise对象），包装成一个模块。使用co的前提条件是，Generator函数的yield命令后面，只能是Thunk函数或Promise对象。如果数组或对象的成员，全部都是Promise对象，也可以使用co（co v4.0版以后，yield命令后面只能是Promise对象，不再支持Thunk函数）。</p><h2 id="async（异步）函数"><a href="#async（异步）函数" class="headerlink" title="async（异步）函数"></a>async（异步）函数</h2><h3 id="是什么-2"><a href="#是什么-2" class="headerlink" title="是什么"></a>是什么</h3><p>async函数属于ES7。目前，它仍处于提案阶段，但是转码器Babel和regenerator都已经支持。async函数可以说是目前异步操作最好的解决方案，是对Generator函数的升级和改进。</p><h3 id="怎么用-2"><a href="#怎么用-2" class="headerlink" title="怎么用"></a>怎么用</h3><p>1）语法</p><p>async函数声明定义了异步函数，它会返回一个AsyncFunction对象。和普通函数一样，你也可以定义一个异步函数表达式。</p><p>调用异步函数时会返回一个promise对象。当这个异步函数成功返回一个值时，将会使用promise的resolve方法来处理这个返回值，当异步函数抛出的是异常或者非法值时，将会使用promise的reject方法来处理这个异常值。</p><p>异步函数可能会包括await表达式，这将会使异步函数暂停执行并等待promise解析传值后，继续执行异步函数并返回解析值。</p><p><strong>注意：await只能用在async函数中。</strong></p><p>前面依次读取两个文件的代码写成async函数如下：</p><pre><code>var asyncReadFile = async function ()&#123;  var f1 = await readFile(&#39;/etc/fstab&#39;)  var f2 = await readFile(&#39;/etc/shells&#39;)  console.log(f1.toString())  console.log(f2.toString())&#125;</code></pre><p>async函数将Generator函数的星号（*）替换成了async，将yield改为了await。</p><p>2）async函数的改进</p><p>async函数对Generator函数的改进，体现在以下三点。</p><p>（1）内置执行器。Generator函数的执行必须靠执行器，所以才有了co函数库，而async函数自带执行器。也就是说，async函数的执行，与普通函数一模一样，只要一行。</p><pre><code>var result = asyncReadFile()</code></pre><p>（2）更好的语义。async和await，比起星号和yield，语义更清楚了。async表示函数里有异步操作，await表示紧跟在后面的表达式需要等待结果。</p><p>（3）更广的适用性。co函数库约定，yield命令后面只能是Thunk函数或Promise对象，而async函数的await命令后面，可以跟Promise对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）。</p><p>3）基本用法</p><p>同Generator函数一样，async函数返回一个Promise对象，可以使用then方法添加回调函数。当函数执行的时候，一旦遇到await就会先返回，等到触发的异步操作完成，再接着执行函数体内后面的语句。</p><pre><code>function resolveAfter2Seconds (x) &#123;  return new Promise(resolve =&gt; &#123;    setTimeout(() =&gt; &#123;      resolve(x)    &#125;, 2000)  &#125;)&#125;async function add1 (x) &#123;  var a = resolveAfter2Seconds(20)  var b = resolveAfter2Seconds(30)  return x + await a + await b&#125;add1(10).then(v =&gt; &#123;  console.log(v)  &#125;)// 2s后打印60async function add2 (x) &#123;  var a = await resolveAfter2Seconds(20)  var b = await resolveAfter2Seconds(30)  return x + a + b&#125;add2(10).then(v =&gt; &#123;  console.log(v)&#125;)// 4s后打印60</code></pre><p>4）捕获错误</p><p>可以使用.catch回调捕获错误，也可以使用传统的try…catch。</p><pre><code>async function myFunction () &#123;  try &#123;    await somethingThatReturnsAPromise()  &#125; catch (err) &#123;    console.log(err)  &#125;&#125;// 另一种写法async function myFunction () &#123;  await somethingThatReturnsAPromise()  .catch(function (err) &#123;    console.log(err)  &#125;&#125;</code></pre><p>5）并发的异步操作</p><pre><code>let foo = await getFoo()let bar = await getBar()</code></pre><p>多个await命令后面的异步操作会按顺序完成。如果不存在继发关系，最好让它们同时触发。上面的代码只有getFoo完成，才会去执行getBar，这样会比较耗时。如果这两个是独立的异步操作，完全可以让它们同时触发。</p><pre><code>// 写法一let [foo, bar] = await Promise.all([getFoo(), getBar()])// 写法二let fooPromise = getFoo()let barPromise = getBar()let foo = await fooPromiselet bar = await barPromise</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> javascript </tag>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES6核心内容精讲--快速实践ES6（一）</title>
      <link href="/posts/26561.html"/>
      <url>/posts/26561.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文大量参考了阮一峰老师的开源教程<a href="http://es6.ruanyifeng.com/">ECMAScript6入门</a>和MDN，适合新手入门或者对ES6常用知识点进行全面回顾，目标是以较少的篇幅涵盖ES6及部分ES7在实践中的绝大多数使用场景。更全面、更深入的请进入上面的教程。如果您觉得有遗漏的常见知识点或者错误的地方，请评论指出！</p><h2 id="新的变量声明方式let和const"><a href="#新的变量声明方式let和const" class="headerlink" title="新的变量声明方式let和const"></a>新的变量声明方式let和const</h2><h3 id="是什么："><a href="#是什么：" class="headerlink" title="是什么："></a>是什么：</h3><p>新的变量声明方式，提供变量的块级作用域，同时通过一些限制来更防止我们犯错误。也就是说是更好的声明变量的方式</p><h3 id="怎么用"><a href="#怎么用" class="headerlink" title="怎么用"></a>怎么用</h3><p>1）let/const与var的区别是提供了块级作用域以及变量创建时不会立即初始化</p><p>2）在同一个作用域内let/const禁止重复声明相同的变量</p><pre><code>var a = 1let a = 2 // SyntaxError</code></pre><p>3）let声明的变量可重新赋值，const声明的变量不能重新赋值，即常量。</p><p>4）暂时性死区：在当前作用域，使用的变量已经存在，但是在代码执行到变量声明前禁止访问。</p><pre><code>var tmp = 123if (true) &#123;  tmp = &#39;abc&#39; // ReferenceError  let tmp&#125;</code></pre><h3 id="常见使用场景"><a href="#常见使用场景" class="headerlink" title="常见使用场景"></a>常见使用场景</h3><p>1）因为能创建块级作用域，所以常见于if和for中</p><pre><code>for (let i = 0; i &lt; arr.length; i++) &#123;    console.log(arr[i])&#125;</code></pre><p>2）const在实践中常用来声明一个对象，之后可以再对这个对象的属性进行修改</p><pre><code>const foo = &#123;    name: &#39;bar&#39;&#125;foo.name = &#39;baz&#39;console.log(foo)</code></pre><h2 id="解构"><a href="#解构" class="headerlink" title="解构"></a>解构</h2><h3 id="是什么：-1"><a href="#是什么：-1" class="headerlink" title="是什么："></a>是什么：</h3><p>按照阮一峰大神的说法：ES6允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。也就是说通过模式匹配来进行变量赋值。</p><h3 id="怎么用："><a href="#怎么用：" class="headerlink" title="怎么用："></a>怎么用：</h3><p>1）数组基本用法</p><pre><code>let [a, b, c] = [1, 2, 3]a //1b //2c //3</code></pre><p>2）对象基本用法</p><pre><code>let &#123; foo, bar &#125; = &#123; foo: &quot;aaa&quot;, bar: &quot;bbb&quot; &#125;foo // &quot;aaa&quot;bar // &quot;bbb&quot;</code></pre><p>3）函数参数的解构赋值</p><p>如在 vuex 中 action 不使用解构如下：</p><pre><code>actions: &#123;    increment (context) &#123;      context.commit(&#39;increment&#39;)    &#125;&#125;</code></pre><p>使用解构</p><pre><code>actions: &#123;    increment (&#123; commit &#125;) &#123;      commit(&#39;increment&#39;)    &#125;&#125;</code></pre><p>4）支持不完全解构</p><pre><code>let [foo, bar] = [1, 2, 3]</code></pre><p>5）如果解构不成功，变量的值就等于undefined,同时解构赋值允许指定默认值,默认值生效的条件是对象的属性值严格等于undefined。</p><h3 id="常见使用场景-1"><a href="#常见使用场景-1" class="headerlink" title="常见使用场景"></a>常见使用场景</h3><p>1）交换变量的值</p><pre><code>[x, y] = [y, x]</code></pre><p>2）提取JSON数据</p><pre><code>let jsonData = &#123;  id: 42,  status: &quot;OK&quot;,  data: [867, 5309]&#125;let &#123; id, status, data: number &#125; = jsonDataconsole.log(id, status, number) // 42, &quot;OK&quot;, [867, 5309]</code></pre><p>3）函数参数的默认值</p><pre><code>jQuery.ajax = function (url, &#123;  async = true,  beforeSend = function () &#123;&#125;,  cache = true,  complete = function () &#123;&#125;,  crossDomain = false,  global = true,  // ... more config&#125;) &#123;  // ... do stuff&#125;</code></pre><p>4）指定加载模块的什么功能</p><pre><code>import &#123; mapActions &#125; from &#39;vuex&#39;</code></pre><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><h3 id="干嘛的："><a href="#干嘛的：" class="headerlink" title="干嘛的："></a>干嘛的：</h3><p>箭头函数可以用来替换函数表达式，不用写function，更加简化。也就是说是函数表达式的简化方式</p><h3 id="怎么用：-1"><a href="#怎么用：-1" class="headerlink" title="怎么用："></a>怎么用：</h3><p>1）注意箭头函数中的this指向外层的this</p><p>2）无法用call/apply/bind来改变this指向。</p><p>3）在ES6中，会默认采用严格模式，因此默认情况下this不是指向window对象，而是undefined。</p><pre><code>&lt;script type=&quot;text/javascript&quot;&gt;    setTimeout(() =&gt; console.log(this), 1000) // undefined，不是window&lt;/script&gt;</code></pre><p>4）不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用rest参数代替。</p><h3 id="使用场景："><a href="#使用场景：" class="headerlink" title="使用场景："></a>使用场景：</h3><p>关键是你需要this指向什么</p><h2 id="默认参数和rest参数"><a href="#默认参数和rest参数" class="headerlink" title="默认参数和rest参数"></a>默认参数和rest参数</h2><h3 id="是什么：-2"><a href="#是什么：-2" class="headerlink" title="是什么："></a>是什么：</h3><p>默认参数就是设置参数默认值，rest参数（翻译为不具名参数，也叫做剩余参数）是将传入的未具名的参数作为一个数组集合</p><h3 id="怎么用：-2"><a href="#怎么用：-2" class="headerlink" title="怎么用："></a>怎么用：</h3><p>如下，默认参数给参数赋一个默认值，rest参数使用三个点（…）加数组集合名</p><pre><code>function foo(arg1 = 1, ...restArg)&#123;    console.log(arg1, restArg)&#125;foo(undefined, 2, 3, 4) // 1, [2, 3, 4]foo(2, 3, 4) // 2, [3, 4]</code></pre><h2 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h2><h3 id="是什么：-3"><a href="#是什么：-3" class="headerlink" title="是什么："></a>是什么：</h3><p>同rest参数一样，也是三个点。它好比rest参数的逆运算，将一个数组转为用逗号分隔的参数序列。因此常用于函数调用。</p><h3 id="常见使用场景："><a href="#常见使用场景：" class="headerlink" title="常见使用场景："></a>常见使用场景：</h3><p>1）合并数组</p><pre><code>let newArr = [...arr1, ...arr2, ...arr3]</code></pre><p>2）与解构赋值结合</p><pre><code>// ES5a = list[0], rest = list.slice(1)// ES6[a, ...rest] = list</code></pre><p>3）将字符串转为数组</p><pre><code>[...&#39;test&#39;] // [ &quot;t&quot;, &quot;e&quot;, &quot;s&quot;, &quot;t&quot;]</code></pre><h2 id="对象扩展"><a href="#对象扩展" class="headerlink" title="对象扩展"></a>对象扩展</h2><h3 id="语法变化"><a href="#语法变化" class="headerlink" title="语法变化"></a>语法变化</h3><p>1）属性简写，当对象的一个属性名称与本地变量名相同的时候，可以省略冒号和值</p><pre><code>var foo = &#39;bar&#39;var baz = &#123;foo&#125;baz // &#123;foo: &quot;bar&quot;&#125;</code></pre><p>2）属性名表达式，可以在以对象字面量方式定义对象是使用表达式作为属性名</p><pre><code>// ES5只能这样obj[&#39;a&#39; + &#39;bc&#39;] = 123 // ES6还能这样let obj = &#123;  [&#39;a&#39; + &#39;bc&#39;]: 123&#125;</code></pre><p>3）方法简写，省去:和function</p><pre><code>const foo = &#123;  bar () &#123;    console.log(&#39;1&#39;)  &#125;&#125;</code></pre><h3 id="Object-is"><a href="#Object-is" class="headerlink" title="Object.is()"></a>Object.is()</h3><p>更好的判断方法，与===的不同有两点：一是+0不等于-0，二是NaN等于自身。</p><pre><code>NaN === NaN // falseObject.is(NaN, NaN) // true</code></pre><h3 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h3><p>1）Object.assign方法用于对象的合并，用法与jQuery和underscore的extend方法类似，而且同样会改变target。</p><pre><code>Object.assign(target, source1, source2)</code></pre><p>2）只拷贝源对象的自身属性（不拷贝继承属性），也不拷贝不可枚举的属性（enumerable: false）。</p><p>3）Object.assign方法实行的是浅拷贝，而不是深拷贝。</p><h3 id="Object-setPrototypeOf"><a href="#Object-setPrototypeOf" class="headerlink" title="Object.setPrototypeOf"></a>Object.setPrototypeOf</h3><p>用来设置一个对象的prototype对象，返回参数对象本身</p><pre><code>Object.setPrototypeOf(object, prototype)</code></pre><h3 id="Object-getPrototypeOf"><a href="#Object-getPrototypeOf" class="headerlink" title="Object.getPrototypeOf()"></a>Object.getPrototypeOf()</h3><p>Object.getPrototypeOf方法可以用来从子类上获取父类。因此，可以使用这个方法判断，一个类是否继承了另一个类。参见下面类与继承章节</p><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><p>对象的每个属性都有一个描述对象（Descriptor），Object.getOwnPropertyDescriptor方法可以获取该属性的描述对象。这个描述对象有value、writable、enumerable、configurable四大属性。</p><p>ES5下面三个操作会忽略enumerable为false的属性。</p><ul><li>for…in循环：只遍历对象自身的和继承的可枚举的属性</li><li>Object.keys()：返回对象自身的所有可枚举的属性的键名</li><li>JSON.stringify()：只串行化对象自身的可枚举的属性</li></ul><p>ES6新增的操作Object.assign()，也会忽略enumerable为false的属性，只拷贝对象自身的可枚举的属性。</p><p>ES6一共有5种方法可以遍历对象的属性。</p><p>（1）for…in</p><p>for…in循环遍历对象自身的和继承的可枚举属性（不含Symbol属性）。</p><p>（2）Object.keys(obj)</p><p>Object.keys返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含Symbol属性）。</p><p>（3）Object.getOwnPropertyNames(obj)</p><p>Object.getOwnPropertyNames返回一个数组，包含对象自身的所有属性（不含Symbol属性，但是包括不可枚举属性）。</p><p>（4）Object.getOwnPropertySymbols(obj)</p><p>Object.getOwnPropertySymbols返回一个数组，包含对象自身的所有Symbol属性。</p><p>（5）Reflect.ownKeys(obj)</p><p>Reflect.ownKeys返回一个数组，包含对象自身的所有属性，不管属性名是Symbol或字符串，也不管是否可枚举。</p><p>以上的5种方法遍历对象的属性，都遵守同样的属性遍历的次序规则。</p><ul><li>首先遍历所有属性名为数值的属性，按照数字排序。</li><li>其次遍历所有属性名为字符串的属性，按照生成时间排序。</li><li>最后遍历所有属性名为Symbol值的属性，按照生成时间排序。</li></ul><p>大多数时候，我们只关心对象自身的可枚举属性。所以，尽量不要用for…in循环，而用Object.keys()代替。</p><h2 id="字符串扩展"><a href="#字符串扩展" class="headerlink" title="字符串扩展"></a>字符串扩展</h2><p>以前判断一个字符串是否包含某个字符串只能通过indexOf的值是否大于-1来判断，现在新增了三种方法：</p><p>includes()：表示是否包含该字符串。</p><p>startsWith()：表示该字符串是否在头部。</p><p>endsWith()：表示该字符串是否在尾部。</p><pre><code>&#39;hello world&#39;.includes(&#39;hello&#39;) // true</code></pre><h3 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h3><h4 id="干嘛的：-1"><a href="#干嘛的：-1" class="headerlink" title="干嘛的："></a>干嘛的：</h4><p>和handlebars那些模板引擎功能类似，有模板字符串可以不用拼接字符串了</p><h4 id="怎么用：-3"><a href="#怎么用：-3" class="headerlink" title="怎么用："></a>怎么用：</h4><p>用反引号``将整个字符串包裹起来，${}表示一个变量或者一个表达式，可以嵌套</p><pre><code>const tmpl = addrs =&gt; `  &lt;table&gt;  $&#123;addrs.map(addr =&gt; `    &lt;tr&gt;&lt;td&gt;$&#123;addr.first&#125;&lt;/td&gt;&lt;/tr&gt;    &lt;tr&gt;&lt;td&gt;$&#123;addr.last&#125;&lt;/td&gt;&lt;/tr&gt;  `).join(&#39;&#39;)&#125;  &lt;/table&gt;`const data = [  &#123; first: &#39;Jane&#39;, last: &#39;Bond&#39; &#125;,  &#123; first: &#39;Lars&#39;, last: &#39;Croft&#39; &#125;,]console.log(tmpl(data))</code></pre><h3 id="标签模板"><a href="#标签模板" class="headerlink" title="标签模板"></a>标签模板</h3><p>函数名后面紧接一个模板字符串。该函数将被调用来处理这个模板字符串。这被称为“标签模板”功能（tagged template）。当字符串模板有变量时，函数的第一个参数为被变量分开的字符串组成的数组，后面的参数依次为变量，这些变量的参数序列可以使用rest参数。</p><pre><code>var a = 5var b = 10tag`Hello $&#123; a + b &#125; world $&#123; a * b &#125;`// 等同于tag([&#39;Hello &#39;, &#39; world &#39;, &#39;&#39;], 15, 50)</code></pre><h2 id="数组扩展"><a href="#数组扩展" class="headerlink" title="数组扩展"></a>数组扩展</h2><h3 id="Array-of"><a href="#Array-of" class="headerlink" title="Array.of()"></a>Array.of()</h3><p>Array.of方法用于将一组值，转换为数组。可以替代Array，且其行为非常统一，不像Array只有一个正整数参数n时，会生成n个空位构成的数组</p><pre><code>Array.of(1) // [1]Array.of(1, 2, 3) // [1, 2, 3]Array(1) // [undefined * 1]，其实不是undefined，是空位，如下可证明两者并不一样0 in [undefined, undefined, undefined] // true0 in [, , ,] // falseArray(1, 2, 3) // [1, 2, 3]</code></pre><h3 id="Array-from"><a href="#Array-from" class="headerlink" title="Array.from()"></a>Array.from()</h3><p>Array.from方法用于将两类对象转为真正的数组：类数组对象（array-like object）和可遍历（iterable）对象（包括ES6新增的数据结构Set和Map）。Array.from还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组。</p><pre><code>Array.from(&#123;&#39;0&#39;: &#39;a&#39;, length: 1&#125;) // [&#39;a&#39;]Array.from(&#39;hello&#39;) // [&#39;h&#39;, &#39;e&#39;, &#39;l&#39;, &#39;l&#39;, &#39;o&#39;]，因为字符串有Iterator接口，可遍历Array.from([1, 2, 3], (x) =&gt; x * x) // [1, 4, 9]</code></pre><p>常见使用场景：</p><p>1）转换NodeList集合。常见的类似数组的对象是DOM操作返回的NodeList集合，以及函数内部的arguments对象。但是后者使用rest参数更简便</p><pre><code>// NodeList对象let elementDivList = document.querySelectorAll(&#39;div&#39;)Array.from(elementDivList).forEach(function (div) &#123;  console.log(div)&#125;)</code></pre><p>2）数组去重。与下面要讲到的Set配合即可很简单地实现数值去重。</p><pre><code>var arr = [1, 3, 5, 5, 8, 3, 2]var uniqueArr = Array.from(new Set(arr))console.log(uniqueArr) // [1, 3, 5, 8, 2]</code></pre><h3 id="数组实例的copyWithin方法"><a href="#数组实例的copyWithin方法" class="headerlink" title="数组实例的copyWithin方法"></a>数组实例的copyWithin方法</h3><pre><code>Array.prototype.copyWithin(target, start = 0, end = this.length)</code></pre><p>它接受三个参数。</p><ul><li>target（必需）：从该位置开始替换数据。</li><li>start（可选）：从该位置开始读取数据，默认为0。如果为负值，表示倒数。</li><li>end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数。</li></ul><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">copyWithin</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token comment">// [3, 4, 5, 4, 5]</span><span class="token comment">/* 从索引2开始读取数据，到数组尾部停止，即读到（3, 4, 5），然后从索引0开始替换数据 */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="数组实例的find和findIndex方法"><a href="#数组实例的find和findIndex方法" class="headerlink" title="数组实例的find和findIndex方法"></a>数组实例的find和findIndex方法</h3><p>找到第一个符合条件的item（项）或index（索引），前者相当于underscore中的first方法，后者则和underscore中的同名方法一致。另外，这两个方法都可以借助Object.is发现NaN，弥补了数组的IndexOf方法的不足。</p><pre><code>[1, 2, 3, 4].find(x =&gt; x &gt; 2) // 3[1, 2, 3, 4].findIndex(x =&gt; x &gt; 2) // 2[NaN].findIndex(x =&gt; Object.is(NaN, x)) // 0</code></pre><h3 id="数组实例的fill方法"><a href="#数组实例的fill方法" class="headerlink" title="数组实例的fill方法"></a>数组实例的fill方法</h3><pre><code>Array.prototype.fill(fillItem, start = 0, end = this.length)[1, 3, 6, 11, 4].fill(10,2) // [1, 3, 10, 10, 10]</code></pre><h3 id="数组实例的includes方法"><a href="#数组实例的includes方法" class="headerlink" title="数组实例的includes方法"></a>数组实例的includes方法</h3><p>与字符串的includes方法类似。该方法属于ES7，但Babel转码器已经支持。</p><pre><code>[1, 2, 3].includes(3, 3) // false[1, 2, 3].includes(3, -1) // true[NaN].includes(NaN) // true</code></pre><h2 id="Set和Map"><a href="#Set和Map" class="headerlink" title="Set和Map"></a>Set和Map</h2><p>ES6中增加了两个新的数据结构：Set和Map。Set是不包含重复值的列表,而Map则是键与相对应的值的集合。</p><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><h4 id="是什么：-4"><a href="#是什么：-4" class="headerlink" title="是什么："></a>是什么：</h4><p>Set是不包含重复值的有序列表。</p><h4 id="怎么用：-4"><a href="#怎么用：-4" class="headerlink" title="怎么用："></a>怎么用：</h4><p>1）Set构造函数可以接受一个数组（或类似数组的对象）作为参数，用来初始化。</p><pre><code>const set = new Set([1, 2, 3, 4, 4])console.log(set)</code></pre><p>2）四个操作方法（add()、delete()、has()、clear()）和一个属性（size）,使用方法根据名字和下面例子就知道了</p><pre><code>const s = new Set()s.add(1).add(2).add(2) // 注意2被add了两次s.size // 2s.has(1) // trues.has(2) // trues.has(3) // falses.delete(2)s.has(2) // falses.add(3)s.size // 2s.clear()s.size // 0</code></pre><p>3）三个遍历器生成函数（keys()、values()、entries()）和一个遍历方法（forEach()）</p><p>keys方法、values方法、entries方法返回的都是遍历器对象（详见Iterator）。都这可以使用遍历器对象的方法for…of进行遍历。由于 Set 结构没有键名，只有键值（或者说键名和键值是同一个值），所以keys方法和values方法的行为完全一致。forEach方法与ES5数组的forEach类似。</p><pre><code>let set = new Set([&#39;red&#39;, &#39;green&#39;, &#39;blue&#39;])for (let item of set.keys()) &#123;  console.log(item)&#125;// red// green// bluefor (let item of set.values()) &#123;  console.log(item)&#125;// red// green// bluefor (let item of set.entries()) &#123;  console.log(item)&#125;// [&quot;red&quot;, &quot;red&quot;]// [&quot;green&quot;, &quot;green&quot;]// [&quot;blue&quot;, &quot;blue&quot;]set.forEach((value, key) =&gt; console.log(value, key))</code></pre><p>4）Set转化为数组，有两种方法：…扩展运算符和Array.from()</p><p>这两者可互换，因此前面提到的使用Array.from()来数组去重也可以这样做：[…new Set(arr)]</p><pre><code>// 方法一let set = new Set([1, 2, 3])set = new Set([...set].map(val =&gt; val * 2))// set的值是2, 4, 6// 方法二let set = new Set([1, 2, 3])set = new Set(Array.from(set, val =&gt; val * 2))// set的值是2, 4, 6</code></pre><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><h4 id="是什么：-5"><a href="#是什么：-5" class="headerlink" title="是什么："></a>是什么：</h4><p>一种由键值对集合构成的数据结构，类似于对象，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。</p><pre><code>const m = new Map();const o = &#123;p: &#39;Hello World&#39;&#125;;m.set(o, &#39;content&#39;)m.get(o) // &quot;content&quot;</code></pre><h4 id="怎么用：-5"><a href="#怎么用：-5" class="headerlink" title="怎么用："></a>怎么用：</h4><p>1）Set构造函数可以接收任何一个具有Iterator接口的数据结构作为参数</p><pre><code>const set = new Set([  [&#39;foo&#39;, 1],  [&#39;bar&#39;, 2]])const m1 = new Map(set)m1.get(&#39;foo&#39;) // 1</code></pre><p>2）5个操作方法（set(key, value)、get(key)、has(key)、delete(key)、clear()）和一个属性（size）</p><p>3）遍历生成函数和遍历方法和Set类似，Map结构的默认遍历器接口（Symbol.iterator属性），就是entries方法。</p><pre><code>map[Symbol.iterator] === map.entries // true</code></pre><p>4）Map转为数组，使用…扩展运算符</p><h3 id="WeakSet和WeakMap"><a href="#WeakSet和WeakMap" class="headerlink" title="WeakSet和WeakMap"></a>WeakSet和WeakMap</h3><p>WeakSet、WeakMap分别和Set、Map类似，不过存储的是对象的弱引用方式，这样在内存管理上更加容易优化。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> javascript </tag>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES6核心内容精讲--快速实践ES6（二）</title>
      <link href="/posts/63419.html"/>
      <url>/posts/63419.html</url>
      
        <content type="html"><![CDATA[<h2 id="Iterator和for…of"><a href="#Iterator和for…of" class="headerlink" title="Iterator和for…of"></a>Iterator和for…of</h2><h3 id="是什么："><a href="#是什么：" class="headerlink" title="是什么："></a>是什么：</h3><p>Iterator(迭代器)是专门用来控制如何遍历的对象，具有特殊的接口。</p><p>Iterator接口是一种数据遍历的协议，只要调用迭代器对象对象的next方法，就会得到一个对象，表示当前遍历指针所在的那个位置的信息，这个包含done和value两个属性。</p><p>迭代器对象创建后，可以反复调用 next()使用。</p><h3 id="怎么用："><a href="#怎么用：" class="headerlink" title="怎么用："></a>怎么用：</h3><p>Iterator对象带有next方法，每一次调用next方法，都会返回数据结构的当前成员的信息。具体来说，就是返回一个包含value和done两个属性的对象。其中，value属性是当前成员的值，done属性是一个布尔值，表示遍历是否结束。</p><p>ES6规定，默认的Iterator接口部署在数据结构的Symbol.iterator属性，或者说，一个数据结构只要具有Symbol.iterator属性，就可以认为是“可遍历的”（iterable）。Symbol.iterator属性本身是一个函数，就是当前数据结构默认的遍历器生成函数。执行这个函数，就会返回一个遍历器。</p><pre><code>let obj = &#123;  data: [ &#39;hello&#39;, &#39;world&#39; ],  [Symbol.iterator]() &#123;    const self = this    let index = 0    return &#123;      next() &#123;        if (index &lt; self.data.length) &#123;          return &#123;            value: self.data[index++],            done: false          &#125;        &#125; else &#123;          return &#123; value: undefined, done: true &#125;        &#125;      &#125;    &#125;  &#125;&#125;for(let item of obj)&#123;    console.log(item)&#125;// hello// world</code></pre><p>如上，for-of循环首先调用obj对象的Symbol.iterator方法，紧接着返回一个新的迭代器对象。迭代器对象可以是任意具有.next()方法的对象,for-of循环将重复调用这个方法，每次循环调用一次。return的对象中value表示当前的值，done表示是否完成迭代。</p><p>Iterator的作用有三个：</p><ol><li><p>为各种数据结构，提供一个统一的、简便的访问接口；</p></li><li><p>使得数据结构的成员能够按某种次序排列；</p></li><li><p>ES6创造了一种新的遍历命令for…of循环，Iterator接口主要供for…of消费。</p></li></ol><p>一个数据结构只要部署了Symbol.iterator属性，就被视为具有iterator接口，就可以用for…of循环遍历它的成员。也就是说，for…of循环内部调用的是数据结构的Symbol.iterator方法。</p><p>for…of循环可以使用的范围包括数组、Set和Map结构、某些类似数组的对象（比如arguments对象、DOM NodeList对象）、后文的Generator对象，以及字符串。</p><h2 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h2><h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><p>ES6引入了一种第六种基本类型的数据：Symbol。Symbol是一种特殊的、不可变的数据类型，可以作为对象属性的标识符使用。</p><h3 id="怎么用"><a href="#怎么用" class="headerlink" title="怎么用"></a>怎么用</h3><p>调用Symbol()创建一个新的symbol，它的值与其它任何值皆不相等。</p><pre><code>var sym = new Symbol() // TypeError，阻止创建一个显式的Symbol包装器对象而不是一个Symbol值var s1 = Symbol(&#39;foo&#39;)var s2 = Symbol(&#39;foo&#39;)s1 === s2 // false</code></pre><h3 id="常用使用场景："><a href="#常用使用场景：" class="headerlink" title="常用使用场景："></a>常用使用场景：</h3><p>由于每一个Symbol值都是不相等的，因此常作为对象的属性名来防止某一个键被不小心改写或覆盖，这个以symbol为键的属性可以保证不与任何其它属性产生冲突。</p><p>作为对象属性名时的遍历：参见对象的遍历那节</p><h3 id="内置的Symbol值："><a href="#内置的Symbol值：" class="headerlink" title="内置的Symbol值："></a>内置的Symbol值：</h3><p>除了定义自己使用的Symbol值以外，ES6还提供了11个内置的Symbol值，指向语言内部使用的方法。其中一个很重要的就是Iterator中提到的Symbol.iterator</p><h2 id="Reflect（反射）"><a href="#Reflect（反射）" class="headerlink" title="Reflect（反射）"></a>Reflect（反射）</h2><h3 id="是什么-1"><a href="#是什么-1" class="headerlink" title="是什么"></a>是什么</h3><p>Reflect是一个内置的对象，它提供可拦截JavaScript操作的方法。</p><h3 id="为什么要增加Reflect对象"><a href="#为什么要增加Reflect对象" class="headerlink" title="为什么要增加Reflect对象"></a>为什么要增加Reflect对象</h3><p><a href="https://github.com/tvcutsem/harmony-reflect/wiki#reflect">参考链接</a></p><p>1）更有用的返回值</p><p>比如，Object.defineProperty(obj, name, desc)在无法定义属性时，会抛出一个错误，而Reflect.defineProperty(obj, name, desc)则会返回false。</p><pre><code>// 老写法try &#123;  Object.defineProperty(target, property, attributes);  // success&#125; catch (e) &#123;  // failure&#125;// 新写法if (Reflect.defineProperty(target, property, attributes)) &#123;  // success&#125; else &#123;  // failure&#125;</code></pre><p>2）函数操作。某些Object操作是命令式，比如name in obj和delete obj[name]，而Reflect.has(obj, name)和Reflect.deleteProperty(obj, name)让它们变成了函数行为</p><p>3）更加可靠的函数调用方式</p><p>在ES5中，当我们想传一个参数数组args来调用函数f，并且将this绑定为this，可以这样写：</p><pre><code>f.apply(obj, args)</code></pre><p>但是，f可能是一个故意或者不小心定义了它自己的apply方法的对象。当你想确保你调用的是内置的apply方法时，一种典型的方法是这样写的：</p><pre><code>Function.prototype.apply.call(f, obj, args)</code></pre><p>但是这种方法不仅冗长而且难以理解。通过使用Reflect，你可以以一种更简单、容易的方式来可靠地进行函数调用</p><pre><code>Reflect.apply(f, obj, args)</code></pre><p>4）可变参数的构造函数</p><p>假设你想调用一个参数是可变的构造函数。在ES6中，由于新的扩展运算符，你可能可以这样写：</p><pre><code>var obj = new F(...args)</code></pre><p>在ES5中，这更加难写，因为只有通过F.apply或者F.call传递可变参数来调用函数，但是没有F.contruct来传递可变参数实例化一个构造函数。通过Reflect，在ES5中可以这样写（内容翻译自参考链接，链接的项目是ES6 Reflect和Proxy的一个ES5 shim，所以会这么说）：</p><pre><code>var obj = Reflect.construct(F, args)</code></pre><p>5）为Proxy(代理，见下一章)的traps提供默认行为</p><p>当使用Proxy对象去包裹存在的对象时，拦截一个操作是很常见的。执行一些行为，然后去“做默认的事情”，这是对包裹的对象进行拦截操作的典型形式。例如，我只是想在获取对象obj的属性时log出所有的属性：</p><pre><code>var loggedObj = new Proxy(obj, &#123;  get: function(target, name) &#123;    console.log(&quot;get&quot;, target, name);    // now do the default thing  &#125;&#125;);</code></pre><p>Reflect和Proxy的API被设计为互相联系、协同的，因此每个Proxy trap都有一个对应的Reflect去“做默认的事情”。因此当你发现你想在Proxy的handler中“做默认的事情”是，正确的事情永远都是去调用Reflect对象对应的方法：</p><pre><code>var loggedObj = new Proxy(obj, &#123;  get: function(target, name) &#123;    console.log(&quot;get&quot;, target, name);    return Reflect.get(target, name);  &#125;&#125;);</code></pre><p>Reflect方法的返回类型已经被确保了能和Proxy traps的返回类型兼容。</p><p>6）控制访问或者读取时的this</p><pre><code>var name = ... // get property name as a stringReflect.get(obj, name, wrapper) // if obj[name] is an accessor, it gets run with `this === wrapper`Reflect.set(obj, name, value, wrapper)</code></pre><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>Reflect对象一共有14个静态方法（其中Reflect.enumerate被废弃）</p><p>与大多数全局对象不同，Reflect没有构造函数。不能将其与一个new运算符一起使用，或者将Reflect对象作为一个函数来调用。</p><p>Reflect对象提供以下静态函数，它们与代理处理程序方法（Proxy的handler）有相同的名称。这些方法中的一些与Object上的对应方法基本相同，有些遍历操作稍有不同，见对象扩展遍历那节。</p><h4 id="Reflect-apply"><a href="#Reflect-apply" class="headerlink" title="Reflect.apply()"></a>Reflect.apply()</h4><p>对一个函数进行调用操作，同时可以传入一个数组作为调用参数。和Function.prototype.apply()功能类似。</p><h4 id="Reflect-construct"><a href="#Reflect-construct" class="headerlink" title="Reflect.construct()"></a>Reflect.construct()</h4><p>对构造函数进行new操作，相当于执行new target(…args)。</p><h4 id="Reflect-defineProperty"><a href="#Reflect-defineProperty" class="headerlink" title="Reflect.defineProperty()"></a>Reflect.defineProperty()</h4><p>和Object.defineProperty()类似。</p><h4 id="Reflect-deleteProperty"><a href="#Reflect-deleteProperty" class="headerlink" title="Reflect.deleteProperty()"></a>Reflect.deleteProperty()</h4><p>删除对象的某个属性，相当于执行delete target[name]。</p><h4 id="Reflect-enumerate"><a href="#Reflect-enumerate" class="headerlink" title="Reflect.enumerate()"></a>Reflect.enumerate()</h4><p>该方法会返回一个包含有目标对象身上所有可枚举的自身字符串属性以及继承字符串属性的迭代器，for…in 操作遍历到的正是这些属性。</p><h4 id="Reflect-get"><a href="#Reflect-get" class="headerlink" title="Reflect.get()"></a>Reflect.get()</h4><p>获取对象身上某个属性的值，类似于target[name]。</p><h4 id="Reflect-getOwnPropertyDescriptor"><a href="#Reflect-getOwnPropertyDescriptor" class="headerlink" title="Reflect.getOwnPropertyDescriptor()"></a>Reflect.getOwnPropertyDescriptor()</h4><p>类似于Object.getOwnPropertyDescriptor()。</p><h4 id="Reflect-getPrototypeOf"><a href="#Reflect-getPrototypeOf" class="headerlink" title="Reflect.getPrototypeOf()"></a>Reflect.getPrototypeOf()</h4><p>类似于Object.getPrototypeOf()。</p><h4 id="Reflect-has"><a href="#Reflect-has" class="headerlink" title="Reflect.has()"></a>Reflect.has()</h4><p>判断一个对象是否存在某个属性，和in运算符的功能完全相同。</p><h4 id="Reflect-isExtensible"><a href="#Reflect-isExtensible" class="headerlink" title="Reflect.isExtensible()"></a>Reflect.isExtensible()</h4><p>类似于Object.isExtensible().</p><h4 id="Reflect-ownKeys"><a href="#Reflect-ownKeys" class="headerlink" title="Reflect.ownKeys()"></a>Reflect.ownKeys()</h4><p>返回一个包含所有自身属性（不包含继承属性）的数组。</p><h4 id="Reflect-preventExtensions"><a href="#Reflect-preventExtensions" class="headerlink" title="Reflect.preventExtensions()"></a>Reflect.preventExtensions()</h4><p>类似于Object.preventExtensions()。</p><h4 id="Reflect-set"><a href="#Reflect-set" class="headerlink" title="Reflect.set()"></a>Reflect.set()</h4><p>设置对象身上某个属性的值，类似于target[name] = val。</p><h4 id="Reflect-setPrototypeOf"><a href="#Reflect-setPrototypeOf" class="headerlink" title="Reflect.setPrototypeOf()"></a>Reflect.setPrototypeOf()</h4><p>类似于Object.setPrototypeOf()。</p><h2 id="Proxy（代理）"><a href="#Proxy（代理）" class="headerlink" title="Proxy（代理）"></a>Proxy（代理）</h2><h3 id="是什么-2"><a href="#是什么-2" class="headerlink" title="是什么"></a>是什么</h3><p>Proxy对象用于定义基本操作的自定义行为 (例如属性查找，赋值，枚举，函数调用等)。</p><p>一些术语：</p><ul><li>handler：包含traps的对象。</li><li>traps：提供访问属性的方法，与操作系统中的traps定义相似。</li><li>target：被代理虚拟化的对象，这个对象常常用作代理的存储后端。</li></ul><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>ES6原生提供Proxy构造函数，用来生成Proxy实例。</p><pre><code>var proxy = new Proxy(target, handler);</code></pre><p>Proxy对象的所有用法，都是上面这种形式，不同的只是handler参数的写法。其中，new Proxy()表示生成一个Proxy实例，target参数表示所要代理的目标对象，handler参数也是一个对象，用来定制代理行为。</p><p>下面代码对一个空对象进行了代理，重定义了属性的读取（get）和设置（set）行为。</p><pre><code>var obj = new Proxy(&#123;&#125;, &#123;  get: function (target, key, receiver) &#123;    console.log(`getting $&#123;key&#125;!`);    return Reflect.get(target, key, receiver);  &#125;,  set: function (target, key, value, receiver) &#123;    console.log(`setting $&#123;key&#125;!`);    return Reflect.set(target, key, value, receiver);  &#125;&#125;);obj.count = 1//  setting count!++obj.count//  getting count!//  setting count!//  2</code></pre><h4 id="handler对象的方法"><a href="#handler对象的方法" class="headerlink" title="handler对象的方法"></a>handler对象的方法</h4><p>handler是一个包含了Proxy的traps的占位符对象。</p><p>所有的trap都是可选的，如果某个trap没有定义，将会对target进行默认操作。这些trap和Reflect的静态方法是对应的，可以使用Reflect对应的静态方法提供默认行为。上面的例子中，handler定义了get和set两个trap，每个trap都是一个方法，接收一些参数。返回了对应的Reflect方法来执行默认方法。</p><p>handler的每个方法可以理解为对相应的某个方法进行代理拦截。</p><p>handler.getPrototypeOf(target)：Object.getPrototypeOf的一个trap</p><p>handler.setPrototypeOf(target, proto)：Object.setPrototypeOf的一个trap</p><p>handler.isExtensible(target)：Object.isExtensible的一个trap</p><p>handler.preventExtensions(target)：Object.preventExtensions的一个trap</p><p>handler.getOwnPropertyDescriptor(target, propKey)：Object.getOwnPropertyDescriptor的一个trap</p><p>handler.defineProperty(target, propKey, propDesc)：Object.defineProperty的一个trap</p><p>handler.has(target, propKey)：in操作的一个trap</p><p>handler.get(target, propKey, receiver)：获取属性值的一个trap</p><p>handler.set(target, propKey, value, receiver)：设置属性值的一个trap</p><p>handler.deleteProperty(target, propKey)：delete操作的一个trap</p><p>handler.ownKeys(target)：Object.getOwnPropertyNames和Object.getOwnPropertySymbols的一个trap</p><p>handler.apply(target, object, args)：函数调用的一个trap</p><p>handler.construct(target, args)：new操作的一个trap</p><h4 id="Proxy-revocable"><a href="#Proxy-revocable" class="headerlink" title="Proxy.revocable()"></a>Proxy.revocable()</h4><p>Proxy.revocable方法返回一个可取消的Proxy实例。</p><pre><code>let target = &#123;&#125;;let handler = &#123;&#125;;let &#123;proxy, revoke&#125; = Proxy.revocable(target, handler);proxy.foo = 123;proxy.foo // 123revoke();proxy.foo // TypeError: Revoked</code></pre><p>Proxy.revocable方法返回一个对象，该对象的proxy属性是Proxy实例，revoke属性是一个函数，可以取消Proxy实例。上面代码中，当执行revoke函数之后，再访问Proxy实例，就会抛出一个错误。</p><p>Proxy.revocable的一个使用场景是，目标对象不允许直接访问，必须通过代理访问，一旦访问结束，就收回代理权，不允许再次访问。</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>上面说的那些可能都比较虚，去看一下w3cplus上翻译的<a href="https://www.w3cplus.com/javascript/use-cases-for-es6-proxies.html">实例解析ES6 Proxy使用场景</a>，可能就会更清楚地明白该怎么用。</p><p>如实例解析ES6 Proxy使用场景中所说，Proxy其功能非常类似于设计模式中的代理模式，该模式常用于三个方面：</p><ul><li>拦截和监视外部对对象的访问</li><li>降低函数或类的复杂度</li><li>在复杂操作前对操作进行校验或对所需资源进行管理</li></ul><p>有以下5个常见使用场景：</p><ol><li><p>抽离校验模块</p></li><li><p>私有属性</p></li><li><p>访问日志</p></li><li><p>预警和拦截</p></li><li><p>过滤操作</p></li></ol><h2 id="类与继承"><a href="#类与继承" class="headerlink" title="类与继承"></a>类与继承</h2><h3 id="类："><a href="#类：" class="headerlink" title="类："></a>类：</h3><p>将原先JavaScript中传统的通过构造函数生成新对象的方式变为类的方式，contructor内是构造函数执行的代码，外面的方法为原型上的方法</p><pre><code>// ES5function Point(x, y) &#123;  this.x = x  this.y = y&#125;Point.prototype.toString = function () &#123;  return &#39;(&#39; + this.x + &#39;, &#39; + this.y + &#39;)&#39;&#125;var p = new Point(1, 2)//定义类class Point &#123;  constructor(x, y) &#123;    this.x = x    this.y = y  &#125;  // 静态方法，static关键字，就表示该方法不会被实例继承(但是会被子类继承)，而是直接通过类来调用  static classMethod() &#123;    return &#39;hello&#39;  &#125;  toString() &#123;    return &#39;(&#39; + this.x + &#39;, &#39; + this.y + &#39;)&#39;  &#125;&#125;</code></pre><h3 id="继承："><a href="#继承：" class="headerlink" title="继承："></a>继承：</h3><p>通过extends关键字来实现。super关键字则是用来调用父类</p><p>ES5的继承，实质是先创造子类的实例对象this，然后再将父类的方法添加到this上面（Parent.apply(this)）。ES6的继承机制完全不同，实质是先创造父类的实例对象this（所以必须先调用super方法），然后再用子类的构造函数修改this。理解了这句话，下面1,2两点也就顺其自然了：</p><p>1）子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。如果不调用super方法，子类就得不到this对象。</p><p>2）在子类的构造函数中，只有调用super之后，才可以使用this关键字，否则会报错。</p><pre><code>class ColorPoint extends Point &#123;  constructor(x, y, color) &#123;    super(x, y); // 调用父类的constructor(x, y)                this.color = color;  &#125;  toString() &#123;    return this.color + &#39; &#39; + super.toString() // 调用父类的toString()  &#125;&#125;Object.getPrototypeOf(ColorPoint) === Point // true</code></pre><p>3）mixin: 继承多个类</p><pre><code>function mix(...mixins) &#123;  class Mix &#123;&#125;  for (let mixin of mixins) &#123;    copyProperties(Mix, mixin);    copyProperties(Mix.prototype, mixin.prototype);  &#125;  return Mix&#125;function copyProperties(target, source) &#123;  for (let key of Reflect.ownKeys(source)) &#123;    if ( key !== &quot;constructor&quot;      &amp;&amp; key !== &quot;prototype&quot;      &amp;&amp; key !== &quot;name&quot;    ) &#123;      let desc = Object.getOwnPropertyDescriptor(source, key);      Object.defineProperty(target, key, desc)    &#125;  &#125;&#125;class DistributedEdit extends mix(Loggable, Serializable) &#123;  // ...&#125;</code></pre><p>4）new.target属性：通过检查new.target对象是否是undefined，可以判断函数是否通过new进行调用。</p><pre><code>function Person(name) &#123;  if (new.target !== undefined) &#123;    this.name = name  &#125; else &#123;    throw new Error(&#39;必须使用new生成实例&#39;)  &#125;&#125;// 另一种写法function Person(name) &#123;  if (new.target === Person) &#123;    this.name = name  &#125; else &#123;    throw new Error(&#39;必须使用new生成实例&#39;)  &#125;&#125;var person = new Person(&#39;张三&#39;) // 正确var notAPerson = Person.call(person, &#39;张三&#39;)  // 报错</code></pre><h2 id="Decorator-装饰器"><a href="#Decorator-装饰器" class="headerlink" title="Decorator(装饰器)"></a>Decorator(装饰器)</h2><h3 id="是什么-3"><a href="#是什么-3" class="headerlink" title="是什么"></a>是什么</h3><p>Decorator是用来修改类（包括类和类的属性）的一个函数。</p><p>这是ES的一个提案，其实是ES7的特性，目前Babel转码器已经支持。</p><h3 id="怎么用-1"><a href="#怎么用-1" class="headerlink" title="怎么用"></a>怎么用</h3><p>1）修饰类：在类之前使用@加函数名，装饰器函数的第一个参数，就是所要修饰的目标类</p><pre><code>function testable(target) &#123;  target.prototype.isTestable = true;&#125;@testableclass MyTestableClass &#123;&#125;let obj = new MyTestableClass();obj.isTestable // true</code></pre><p>装饰器函数也可以是一个工厂方法</p><pre><code>function testable(isTestable) &#123;  return function(target) &#123;    target.isTestable = isTestable;  &#125;&#125;@testable(true)class MyTestableClass &#123;&#125;MyTestableClass.isTestable // true@testable(false)class MyClass &#123;&#125;MyClass.isTestable // false</code></pre><p>2）修饰类的属性：修饰器函数一共可以接受三个参数，第一个参数是所要修饰的目标对象，第二个参数是所要修饰的属性名，第三个参数是该属性的描述对象。装饰器在作用于属性的时候，实际上是通过Object.defineProperty来进行扩展和封装的。</p><p>下面是一个例子，修改属性描述对象的enumerable属性，使得该属性不可遍历。</p><pre><code>class Person &#123;  @nonenumerable  get kidCount() &#123; return this.children.length; &#125;&#125;function nonenumerable(target, name, descriptor) &#123;  descriptor.enumerable = false;  return descriptor;&#125;</code></pre><h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><p><a href="https://github.com/jayphelps/core-decorators.js">core-decorators.js</a>这个第三方模块提供了几个常见的修饰器。</p><p>在修饰器的基础上，可以实现Mixin模式等。</p><h2 id="Module-模块"><a href="#Module-模块" class="headerlink" title="Module(模块)"></a>Module(模块)</h2><p>在ES6之前，前端和nodejs实践中已经有一些模块加载方案，如CommonJS、AMD、CMD等。ES6在语言标准的层面上，实现了模块功能。</p><p>模块功能主要由两个命令构成：export和import。export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能。</p><h3 id="export"><a href="#export" class="headerlink" title="export"></a>export</h3><p>一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。必须使用export关键字输出该变量。有以下两种不同的导出方式：</p><h4 id="命名导出"><a href="#命名导出" class="headerlink" title="命名导出"></a>命名导出</h4><p>命名导出规定的是对外的接口，必须与模块内部的变量建立一一对应关系。</p><pre><code>export &#123; myFunction &#125;; // 导出一个函数声明export const foo = Math.sqrt(2); // 导出一个常量</code></pre><h4 id="默认导出-每个脚本只能有一个-，使用export-default命令："><a href="#默认导出-每个脚本只能有一个-，使用export-default命令：" class="headerlink" title="默认导出 (每个脚本只能有一个)，使用export default命令："></a>默认导出 (每个脚本只能有一个)，使用export default命令：</h4><pre><code> export default myFunctionOrClass</code></pre><p>本质上，export default就是输出一个叫做default的变量或方法，然后系统允许你为它取任意名字</p><p>对于只导出一部分值来说，命名导出的方式很有用。在导入时候，可以使用相同的名称来引用对应导出的值。</p><p>关于默认导出方式，每个模块只有一个默认导出。一个默认导出可以是一个函数，一个类，一个对象等。当最简单导入的时候，这个值是将被认为是”入口”导出值。</p><h3 id="import"><a href="#import" class="headerlink" title="import"></a>import</h3><p>使用export命令定义了模块的对外接口以后，其他JS文件就可以通过import命令加载这个模块。</p><pre><code>import &#123; foo, bar &#125; from &#39;my_module&#39; // 指定加载某个输出值import &#39;lodash&#39;; // 仅执行import &#123; lastName as surname &#125; from &#39;./profile&#39;; // 为输入的模块重命名import * as circle from &#39;./circle&#39;; // 整体加载/*export和import复合写法*/export &#123; foo, bar &#125; from &#39;my_module&#39;;// 等同于import &#123; foo, bar &#125; from &#39;my_module&#39;;export &#123; foo, bar &#125;;</code></pre><h3 id="ES6模块与CommonJS模块的差异"><a href="#ES6模块与CommonJS模块的差异" class="headerlink" title="ES6模块与CommonJS模块的差异"></a>ES6模块与CommonJS模块的差异</h3><p>它们有两个重大差异。</p><ul><li>CommonJS模块输出的是一个值的拷贝，ES6模块输出的是值的引用。</li><li>CommonJS模块是运行时加载，ES6模块是编译时输出接口。</li></ul><p>CommonJS是运行时加载，ES6是编译时加载，使得静态分析成为可能</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li><p>ES6的模块自动采用严格模式。因此ES6模块中，顶层的this指向undefined。</p></li><li><p>export一般放在两头即开始或者结尾这样更能清晰地明白暴露了什么变量</p></li><li><p>注意，import命令具有提升效果，会提升到整个模块的头部，首先执行。因为不是运行时加载，不支持条件加载、按需加载等</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> javascript </tag>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SASS学习总结</title>
      <link href="/posts/31259.html"/>
      <url>/posts/31259.html</url>
      
        <content type="html"><![CDATA[<p><a href="http://www.ruanyifeng.com/blog/2012/06/sass.html">SASS用法指南</a><br>SASS是一种CSS预处理器（css preprocessor）。它的基本思想是，用一种专门的编程语言，进行网页样式设计，然后再编译成正常的CSS文件。</p><p>SASS提供四个编译风格的选项：</p><ul><li><p>nested：嵌套缩进的css代码，它是默认值。</p></li><li><p>expanded：没有缩进的、扩展的css代码。</p></li><li><p>compact：简洁格式的css代码。</p></li><li><p>compressed：压缩后的css代码。</p></li></ul><p>导入文件</p><p>@import命令，用来导入外部文件。</p><p>　　@import “path/filename.scss”;</p><p>如果导入的是.css文件，则等同于css的import命令。</p><p>注释</p><p>sass有两种注释方式，一种是标准的css注释方式/* */，另一种则是//双斜杆形式的单行注释，不过这种单行注释不会被转译出来。</p><p>1 变量</p><p>SASS允许使用变量，所有变量以$开头</p><p>普通变量</p><p>定义之后可以在全局范围内使用。</p><p>默认变量</p><p>sass的默认变量仅需要在值后面加上!default即可。</p><p>sass的默认变量一般是用来设置默认值，然后根据需求来覆盖的，覆盖的方式也很简单，只需要在默认变量之前重新声明下变量即可</p><p>默认变量的价值在进行组件化开发的时候会非常有用。</p><p>特殊变量</p><p>一般我们定义的变量都为属性值，可直接使用，但是如果变量作为属性或在某些特殊情况下等则必须要以#{$variables}形式使用。</p><p>多值变量</p><p>多值变量分为list类型和map类型，简单来说list类型有点像js中的数组，而map类型有点像js中的对象</p><p>全局变量</p><p>在变量值后面加上!global即为全局变量。这个目前还用不上，不过将会在sass 3.4后的版本中正式应用。目前的sass变量范围饱受诟病，所以才有了这个全局变量。</p><p>2 嵌套(Nesting)</p><p>sass的嵌套包括两种：一种是选择器的嵌套；另一种是属性的嵌套。我们一般说起或用到的都是选择器的嵌套。</p><p>在选择器嵌套中，可以使用&amp;表示父元素选择器</p><p>属性嵌套：所谓属性嵌套指的是有些属性拥有同一个开始单词，如border-width，border-color都是以border开头。</p><pre><code>.fakeshadow &#123;  border: &#123;    style: solid;    left: &#123;      width: 4px;      color: #888;    &#125;    right: &#123;      width: 2px;      color: #ccc;    &#125;  &#125;&#125;</code></pre><p>@at-root：sass3.3.0中新增的功能，用来跳出选择器嵌套的。</p><p>3 混合(mixin)</p><p>sass中使用@mixin声明混合，可以传递参数，参数名以$符号开始，多个参数以逗号分开，也可以给参数设置默认值。声明的@mixin通过@include来调用</p><p>多个参数mixin</p><p>调用时可直接传入值，如@include传入参数的个数小于@mixin定义参数的个数，则按照顺序表示，后面不足的使用默认值，如不足的没有默认值则报错。除此之外还可以选择性的传入参数，使用参数名与值同时传入。</p><p>多组值参数mixin</p><p>如果一个参数可以有多组值，如box-shadow、transition等，那么参数则需要在变量后加三个点表示，如$variables…。</p><pre><code>@content@content在sass3.2.0中引入，可以用来解决css3的@media等带来的问题。它可以使@mixin接受一整块样式，接受的样式从@content开始。 //sass style//-------------------------------                     @mixin max-screen($res)&#123;  @media only screen and ( max-width: $res )  &#123;    @content;  &#125;&#125;@include max-screen(480px) &#123;  body &#123; color: red &#125;&#125;//css style//-------------------------------@media only screen and (max-width: 480px) &#123;  body &#123; color: red &#125;&#125; </code></pre><p><strong>@mixin通过@include调用后解析出来的样式是以拷贝形式存在的，而下面的继承则是以联合声明的方式存在的，所以从3.2.0版本以后，建议传递参数的用@mixin，而非传递参数类的使用下面的继承%。</strong></p><p>4 继承</p><p>sass中，选择器继承可以让选择器继承另一个选择器的所有样式，并联合声明。使用选择器的继承，要使用关键词@extend，后面紧跟需要继承的选择器。</p><p>占位选择器%</p><p>从sass 3.2.0以后就可以定义占位选择器%。这种选择器的优势在于：如果不调用则不会有任何多余的css文件，避免了以前在一些基础的文件中预定义了很多基础的样式，然后实际应用中不管是否使用了@extend去继承相应的样式，都会解析出来所有的样式。占位选择器以%标识定义，通过@extend调用。</p><p>占位选择器的出现，使css文件更加简练可控，没有多余。所以可以用其定义一些基础的样式文件，然后根据需要调用产生相应的css。</p><pre><code>//sass style//-------------------------------%ir&#123;  color: transparent;  text-shadow: none;  background-color: transparent;  border: 0;&#125;%clearfix&#123;  @if $lte7 &#123;    *zoom: 1;  &#125;  &amp;:before,  &amp;:after &#123;    content: &quot;&quot;;    display: table;    font: 0/0 a;  &#125;  &amp;:after &#123;    clear: both;  &#125;&#125;#header&#123;  h1&#123;    @extend %ir;    width:300px;  &#125;&#125;.ir&#123;  @extend %ir;&#125;//css style//-------------------------------#header h1,.ir&#123;  color: transparent;  text-shadow: none;  background-color: transparent;  border: 0;&#125;#header h1&#123;  width:300px;&#125;</code></pre><p>在@media中暂时不能@extend @media外的代码片段，以后将会可以。</p><p>5 函数</p><p>sass定义了很多函数可供使用，当然你也可以自己定义函数，以@fuction开始。sass的官方函数链接为：sass fuction，实际项目中我们使用最多的应该是颜色函数，而颜色函数中又以lighten减淡和darken加深为最，其调用方法为lighten($color,$amount)和darken($color,$amount)，它们的第一个参数都是颜色值，第二个参数都是百分比。</p><pre><code>// pixels to rems @function pxToRem($px) &#123;  @return $px / $baseFontSize * 1rem;&#125;</code></pre><p>6 运算</p><p>sass具有运算的特性，可以对数值型的Value(如：数字、颜色、变量等)进行加减乘除四则运算。请注意运算符前后请留一个空格，不然会出错。另外，要注意运算单位</p><p>7 条件判断及循环</p><p>@if判断</p><p>@if可一个条件单独使用，也可以和@else结合多条件使用</p><p>三目判断</p><p>if($condition, $if_true, $if_false)</p><p>for循环 </p><p>for循环有两种形式，分别为：@for $var from <start> through <end>和@for $var from <start> to <end>。$i表示变量，start表示起始值，end表示结束值，这两个的区别是关键字through表示包括end这个数，而to则不包括end这个数。</p><p>@each循环</p><p>语法为：@each $var in <list or map>。其中$var表示变量，而list和map表示list类型数据和map类型数据。sass 3.3.0新加入了多字段循环和map数据循环。</p><p>多个字段list数据循环</p><pre><code>//sass style//-------------------------------$animal-data: (puma, black, default),(sea-slug, blue, pointer),(egret, white, move);@each $animal, $color, $cursor in $animal-data &#123;  .#&#123;$animal&#125;-icon &#123;    background-image: url(&#39;/images/#&#123;$animal&#125;.png&#39;);    border: 2px solid $color;    cursor: $cursor;  &#125;&#125;//css style//-------------------------------.puma-icon &#123;  background-image: url(&#39;/images/puma.png&#39;);  border: 2px solid black;  cursor: default; &#125;.sea-slug-icon &#123;  background-image: url(&#39;/images/sea-slug.png&#39;);  border: 2px solid blue;  cursor: pointer; &#125;.egret-icon &#123;  background-image: url(&#39;/images/egret.png&#39;);  border: 2px solid white;  cursor: move; &#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机 </tag>
            
            <tag> 前端 </tag>
            
            <tag> css </tag>
            
            <tag> SASS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javaScript篇03--promise</title>
      <link href="/posts/20535.html"/>
      <url>/posts/20535.html</url>
      
        <content type="html"><![CDATA[<p>Promise是一种异步处理模式。<br>Promise这种规范，它能帮助开发者用同步的方式，编写异步的代码。<br>再说的直白点，Promise就是一种对执行结果不确定的一种预先定义，如果成功，就xxxx；如果失败，就xxxx，就像事先给出了一些承诺。</p><p>使用promise机制的优点如下：<br>1.可以对函数进行链式调用，所以你不会陷入代码缩进噩梦中；<br>2.在调用链的过程中，可以保证上一个函数调用完成之后才会调用下一个函数；<br>3.每一个then()调用都带有两个参数（两个都是函数）。第一个是成功之后的回调，第二个是出错之后的处理器；<br>4.如果调用链中出现了错误，错误将会被冒泡传递到其余的错误处理函数中。所以，最终来说，所有错误都可以在任意一个回调函数中进行处理。</p><p>Promise 背后的概念非常简单，有两部分:<br>Deferreds，定义工作单元，<br>Promises，从 Deferreds 返回的数据。<br>基本上，你会用Deferred作为通信对象，用来定义工作单元的开始，处理和结束三部分。<br>Promise是 Deferred 响应数据的输出；它有状态 (等待，执行和拒绝)，以及句柄，或叫做回调函数，反正就是那些在Promise执行，拒绝或者提示进程中会被调用的方法。<br>Promise不同于回调的很重要的一个点是，你可以在Promise状态变成执行(resolved)之后追加处理句柄。这就允许你传输数据，而忽略它是否已经被应用获取，然后缓存它，等等之类的操作，因此你可以对数据执行操作，而不管它是否已经或者即将可用。</p><p>$q服务<br>$q服务是AngularJS中自己封装实现的一种Promise实现，相对与Kris Kwal’s Q要轻量级的多。</p><p>先介绍一下$q常用的几个方法：<br>1)defer() 创建一个deferred对象，这个对象可以执行几个常用的方法，比如resolve,reject,notify等.这个对象有promise属性。<br>2)all()<br>3)when() 传入一个不确定的参数，如果符合Promise标准，就返回一个promise对象。</p><p>defer()方法：<br>defer()用于创建一个deferred对象，defer.promise用于返回一个promise对象，来定义then方法。then中有三个参数，分别是成功回调、失败回调、状态变更回调。<br>在$q中，可以使用resolve方法，变成完成状态；使用reject方法，变成拒绝状态。</p><p>all()方法：<br>$q.all()，允许你等待并行的promise处理，当所有的promise都被处理结束之后，调用共同的回调。在Angular中，这个方法有两种调用方式:以Array方式或Object方式。Array方式接收多个promise，然后在调用.then()的时候使用一个数据结果对象，在结果对象里面包含了所有的promise结果，按照输入数组的顺序排列。</p><pre><code>var funcA = function()&#123;        console.log(&quot;funcA&quot;);        return &quot;hello,funA&quot;;    &#125;var funcB = function()&#123;    console.log(&quot;funcB&quot;);    return &quot;hello,funB&quot;;&#125;$q.all([funcA(),funcB()])    .then(function(results)&#123;        console.log(results[0]);        console.log(results[1]);    &#125;);</code></pre><p>第二种方式是接收一个promise集合对象，允许你给每个promise一个别名，在回调函数中可以使用它们(有更好的可读性)。</p><pre><code>$q.all(&#123;first:funcA(),second:funcB()&#125;)    .then(function(results)&#123;        console.log(results.first);        console.log(results.second);    &#125;);</code></pre><p>建议使用数组表示法，如果你只是希望可以批处理结果，就是说，如果你把所有的结果都平等处理。而以对象方式来处理，则更适合需要自注释代码的时候。</p><p>when()方法：<br>如果你想通过一个普通变量创建一个promise，或者你不清楚你要处理的对象是不是promise时非常有用。<br>$q.when()在诸如服务中的缓存这种情况也很好用:</p><pre><code>angular.module(&#39;myApp&#39;).service(&#39;MyService&#39;, function($q, MyResource) &#123;    var cachedSomething;    this.getSomething = function() &#123;        if (cachedSomething) &#123;            return $q.when(cachedSomething);        &#125;        // on first call, return the result of MyResource.get()        // note that &#39;then()&#39; is chainable / returns a promise,        // so we can return that instead of a separate promise object        return MyResource.get().$promise            .then(function(something) &#123;                cachedSomething = something            &#125;);    &#125;;&#125;);</code></pre><p>与这个类似？</p><pre><code>angular.module(&quot;MyService&quot;, []).factory(&#39;githubService&#39;, [&quot;$q&quot;, &quot;$http&quot;, function ($q, $http) &#123;    var getPullRequests = function () &#123;        var deferred = $q.defer();        var promise = deferred.promise;        var progress;        $http.get(&quot;https://api.github.com/repos/angular/angular.js/pulls&quot;)            .success(function (data) &#123;                var result = [];                for (var i = 0; i &lt; data.length; i++) &#123;                    result.push(data[i].user);                    progress = (i + 1) / data.length * 100;                    deferred.notify(progress);                &#125;                deferred.resolve(result);            &#125;)            .error(function (error) &#123;                deferred.reject(error);            &#125;);        return promise;    &#125;;    return &#123;        getPullRequests: getPullRequests    &#125;;&#125;]);</code></pre><p>然后可以这样调用它:</p><pre><code>MyService.getSomething()    .then(function(something) &#123;        console.log(something);    &#125;);</code></pre><p>在Promise中，定义了三种状态：等待状态，完成状态，拒绝状态。<br>关于状态有几个规定：<br>1)状态的变更是不可逆的<br>2)等待状态可以变成完成或者拒绝</p><p>promise对象有另外三个方法:.then()，是唯一Promise规范要求的方法，用三个回调方法作为参数；一个成功回调，一个失败回调，还有一个状态变化回调。</p><p>$q在Promise规范之上还添加了两个方法: catch()，可以用于定义一个通用方法，它会在promise链中有某个promise处理失败时被调用。还有finally()，不管promise执行是成功或者失败都会执行。注意，这些不应该和Javascript的异常处理混淆或者并用: 在promise内部抛出的异常，不会catch()俘获</p><p>链式Promise<br>Promise链会把上一个then的返回结果传递给调用链的下一个then(如果没有就是undefined)<br>如果then回调返回一个promise对象，下一个then只会在这个promise被处理结束的时候调用。<br>在链最后的catch为整个链式处理提供一个异常处理点<br>在链最后的finally总是会被执行，不管promise被处理或者被拒绝，起清理作用</p><p>拦截响应</p><p>Promise机制还可以做一些非常酷的事情：拦截响应。</p><p>我们已经学过的内容有：向服务端发送请求、处理响应、把响应很好地包装成抽象的东西及处理异步调用。但是在真实的应用中，对于每一次服务端调用，最终还必须做一些通用的操作，例如错误处理、鉴权以及其他安全方面的处理（例如剪裁数据）。</p><p>在深入理解了$q接口之后，我们就可以使用拦截响应的方式来处理以上所有任务了。响应拦截的机制允许我们在响应到达应用之前对其进行拦截，并在上面进行一些操作，例如转换数据形式、处理错误等所有你能想到的操作。</p><p>下面来看一个例子，它会拦截响应，然后做一些很小的数据转换操作。</p><pre><code>//把拦截器注册为一个服务myModule.factory(&#39;myInterceptor&#39;, function($q, notifyService, errorLog) &#123; return function(promise) &#123; return promise.then(function(response) &#123;//什么都不做 return response; &#125;, function(response) &#123;//notify服务将会使用错误信息来刷新UInotifyService(response);//同时把错误信息打印到控制台，以便调试errorLog(response); return $q.reject(response);&#125;);&#125;&#125;);//确保我们所创建的拦截器是拦截器链的一部分$httpProvider.responseInterceptors.push(&#39;myInterceptor&#39;);</code></pre><p>参考：<br><a href="http://www.cnblogs.com/xing901022/p/4928147.html">AngularJS 中的Promise — $q服务详解</a><br><a href="http://www.cnblogs.com/whitewolf/p/promise-best-practice.html">Promise的前世今生和妙用技巧</a><br><a href="http://my.oschina.net/ilivebox/blog/293771">AngularJS中的Promise和设计模式</a><br><a href="https://github.com/xieranmaya/blog/issues/3">剖析Promise内部结构</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机 </tag>
            
            <tag> 前端 </tag>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack入门</title>
      <link href="/posts/23985.html"/>
      <url>/posts/23985.html</url>
      
        <content type="html"><![CDATA[<h2 id="webpack简述"><a href="#webpack简述" class="headerlink" title="webpack简述"></a>webpack简述</h2><p>按照<a href="http://webpack.github.io/docs/what-is-webpack.html">webapck官网</a>所说，webpack是一个模块打包工具(webpack is a module bundler)。它接收依赖的模块，将其转化为静态资源。</p><p>webpack与众不同的三大核心概念</p><ol><li><p>Code Spliting</p></li><li><p>Loaders</p></li><li><p>Plugin System</p></li></ol><h2 id="配置-configuration"><a href="#配置-configuration" class="headerlink" title="配置(configuration)"></a><a href="https://webpack.github.io/docs/configuration.html">配置(configuration)</a></h2><h3 id="CLI"><a href="#CLI" class="headerlink" title="CLI"></a>CLI</h3><p>如果使用CLI，webpack将会读取webpack.config.js文件（或者通过–config选项传递的文件），这个文件需要暴露这样的配置对象：</p><pre><code>module.exports = &#123;    // configuration&#125;;</code></pre><p>常见CLI option</p><p>1)开发环境简写 -d</p><p>等价于：–debug –devtool source-map –output-pathinfo</p><p>2)生产环境简写 -p</p><p>等价于：–optimize-minimize –optimize-occurrence-order</p><p>3)监视模式 –watch</p><p>4)配置文件 –config example.config.js</p><p>指定新的配置文件，而不是默认的webpack.config.js</p><p>5)常见的显示选项</p><ul><li><p>–progress</p></li><li><p>–display-chunks</p></li><li><p>–display-reasons</p></li><li><p>–display-error-details</p></li><li><p>–display-modules</p></li><li><p>–display-exclude</p></li></ul><p>可以通过script来定义脚本，然后npm run 命令名。</p><p>** 一个简单的配置对象，注意不是json，只是简单的object **</p><pre><code>&#123;    context: __dirname + &quot;/app&quot;,    entry: &quot;./entry&quot;,    output: &#123;        path: __dirname + &quot;/dist&quot;,        filename: &quot;bundle.js&quot;    &#125;&#125;</code></pre><h3 id="context"><a href="#context" class="headerlink" title="context"></a>context</h3><p>context：根目录（绝对路径!）。可以认为是文件查找的上下文。默认process.cwd()</p><h3 id="entry"><a href="#entry" class="headerlink" title="entry"></a>entry</h3><p>entry：包的入口点，有三种形式</p><ol><li><p>一个string</p></li><li><p>一个由多个string构成的array</p></li><li><p>一个object（多页面场景下），key是chunk的name，value可以是string或者array</p></li></ol><h3 id="output"><a href="#output" class="headerlink" title="output"></a>output</h3><h4 id="output-filename"><a href="#output-filename" class="headerlink" title="output.filename"></a>output.filename</h4><p>不要在这里指定绝对路径</p><p>多入口情况下使用占位符</p><ul><li><p>[name] 模块名称</p></li><li><p>[hash] 模块编译后的（整体）Hash值</p></li><li><p>[chunkhash] 分片的Hash值,可以认为是文件的版本号，也可以认为是文件的MD5值，在静态资源的版本管理中非常有用</p></li></ul><h4 id="output-path"><a href="#output-path" class="headerlink" title="output.path"></a>output.path</h4><h4 id="output-publicPath"><a href="#output-publicPath" class="headerlink" title="output.publicPath"></a>output.publicPath</h4><p>指定 public URL地址，当我们要将output的文件放在不同的域名或者CDN上时十分有用</p><h3 id="module"><a href="#module" class="headerlink" title="module"></a>module</h3><p>module.loaders 一个自动应用的loaders的数组，每项（item）可以有这些属性：</p><ul><li><p>test: A condition that must be met</p></li><li><p>exclude: A condition that must not be met</p></li><li><p>include: An array of paths or files where the imported files will be transformed by the loader</p></li><li><p>loader: A string of “!” separated loaders</p></li><li><p>loaders: An array of loaders as string</p></li></ul><h3 id="resolve"><a href="#resolve" class="headerlink" title="resolve"></a>resolve</h3><h4 id="resolve-alias"><a href="#resolve-alias" class="headerlink" title="resolve.alias"></a>resolve.alias</h4><p>模块别名定义，方便后续直接引用别名</p><pre><code>resolve: &#123;    alias: &#123; AppStore : &#39;js/stores/AppStores.js&#39;,//之后直接 require(&#39;AppStore&#39;)    &#125; &#125;</code></pre><h4 id="resolve-root"><a href="#resolve-root" class="headerlink" title="resolve.root"></a>resolve.root</h4><p>包含你模块的目录（绝对路径），也可以是一个目录数组，这个设置应该被用于添加个人目录到webpack查找路径里</p><p>必须是个绝对路径，不要这样写./app/modules</p><h4 id="resolve-modulesDirectories"><a href="#resolve-modulesDirectories" class="headerlink" title="resolve.modulesDirectories"></a>resolve.modulesDirectories</h4><p>这是一个目录数组，用来解析到当前目录以及祖先目录和查找模块。这个函数的工作原理和node如何查找node_modules目录很像。比如如果值为[“mydir”]，webpack会查找“./mydir”, “../mydir”, “../../mydir”等等</p><p>默认: [“web_modules”, “node_modules”]</p><h4 id="resolve-extensions"><a href="#resolve-extensions" class="headerlink" title="resolve.extensions"></a>resolve.extensions</h4><p>一个用来解析模块的拓展名数组。比如，为了发现一个CoffeeScript文件，你的数组里应该包含字符串”.coffee”</p><p>默认: [“”, “.webpack.js”, “.web.js”, “.js”]</p><p><strong>注意：设置这个选项将会重写默认值</strong></p><h3 id="externals"><a href="#externals" class="headerlink" title="externals"></a>externals</h3><p>指定不该被webpack打包的模块，但是在打包后的包中仍然保留了请求。</p><p>我们可以通过它来暴露全局变量，而在需要的文件中直接require或import就可以了</p><pre><code>externals: &#123;  jquery: &#39;jQuery&#39;&#125;</code></pre><h3 id="plugins"><a href="#plugins" class="headerlink" title="plugins"></a>plugins</h3><p>给编译器添加额外的插件</p><h2 id="各种loaders"><a href="#各种loaders" class="headerlink" title="各种loaders"></a>各种loaders</h2><p>webpack 可以使用 loader 来预处理文件。这允许你打包除 JavaScript 之外的任何静态资源。你可以使用 Node.js 来很简单地编写自己的 loader。</p><p>loader的使用有三种方法，分别是：</p><ul><li><p>在require中显式指定，即上面看到的用法</p></li><li><p>在配置项（webpack.config.js）中指定</p></li><li><p>在命令行中指定</p></li></ul><p>1)<a href="https://www.npmjs.com/package/babel-loader">babel-loader</a></p><p>转换ES6语法或React语法</p><p>通过presets选择ES6特性，也可以在package.json中指定</p><p>解决babel-loader处理React的preset问题：npm i –save-dev babel-preset-react</p><p>2)css相关</p><ul><li><p>style-loader 将模块的导出作为样式添加到DOM中</p></li><li><p>css-loader 解析CSS文件后，使用import加载，并且返回CSS代码,可以在loader后面?modules以支持<a href="https://github.com/css-modules/css-modules">CSS Module</a></p></li><li><p>less-loader 加载和转译LESS文件</p></li><li><p>sass-loader 加载和转译SASS/SCSS文件，须先安装node-sass，windows可能安装出错，使用cnpm i node-sass –save-dev或者如下：</p><p>  npm install –save-dev node-sass –registry=<a href="https://registry.npm.taobao.org/">https://registry.npm.taobao.org</a> –disturl=<a href="https://npm.taobao.org/dist">https://npm.taobao.org/dist</a> –sass-binary-site=<a href="http://npm.taobao.org/mirrors/node-sass">http://npm.taobao.org/mirrors/node-sass</a></p></li><li><p>postcss-loader 使用PostCSS加载和转译CSS/SSS文件，可以进行autoprefixer</p></li></ul><p>CSS中@import另一个CSS怎么处理？（非SASS、LESS）</p><p>给css-loader添加参数</p><pre><code>loader: &#39;style-loader!css-loader?importLoaders=1!postcss-loader&#39;</code></pre><p>3)模板相关</p><ul><li><p>html-loader 导出HTML为字符串，需要引用静态资源</p></li><li><p>jade-loader 加载Jade模板并返回一个函数</p></li><li><p>markdown-loader 将Markdown转译为HTML</p></li><li><p>handlebars-loader 将Handlebars转换为HTML</p></li><li><p>ejs-loader 将underscore模板转换为HTML</p></li></ul><p>4)图片相关</p><ul><li><p>file-loader</p></li><li><p>url-loader 与file-loader，但如果文件小于限制，可以返回 data URL</p></li><li><p>image-loader 压缩图片</p></li></ul><p>components模板引用相对路径图片不会替换？</p><p>可以使用绝对路径或者这样写src=”${require(‘../../assets/bg.png’)}”</p><p>5)bundle-loader</p><p>bundle-loader是一个用来在运行时异步加载模块的loader。可以用来做代码分割</p><p>6)exports-loader</p><p>可以从模块中导出变量。</p><p>在实际使用中，用exports-loader最多的场景是将某些不支持模块化规范的模块所声明的全局变量作为模块内容导出。<br>如下可以导出全局变量Hello，exports-loader还可以支持同时导出多个变量，例如exports?HELLO,WORLD</p><pre><code>module.exports = &#123;    module:&#123;        loaders:[            &#123; test: require.resolve(&#39;./hello&#39;), loader: &quot;exports?Hello&quot; &#125;        ]    &#125;&#125;;</code></pre><p>7)imports-loaders</p><p>用于向一个模块的作用域内注入变量（Can be used to inject variables into the scope of a module）</p><p>8)expose-loader</p><p>把一个模块导出并付给一个全局变量</p><pre><code>require(&quot;expose?libraryName!./file.js&quot;);// Exposes the exports for file.js to the global context on property &quot;libraryName&quot;.// In web browsers, window.libraryName is then available.</code></pre><h2 id="各种plugins"><a href="#各种plugins" class="headerlink" title="各种plugins"></a>各种plugins</h2><p>1)<a href="https://github.com/jantimon/html-webpack-plugin#configuration">HtmlWebpackPlugin</a></p><p>参数：</p><ul><li><p>template html模板地址，默认为webpack.config.js所在的目录</p></li><li><p>inject 插入位置</p></li><li><p>title</p></li><li><p>date等</p></li></ul><p>2)CommonsChunkPlugin    </p><p>将多个入口起点之间共享的公共模块，生成为一些 chunk，并且分离到单独的 bundle 中，例如，1vendor.bundle.js 和 app.bundle.js</p><p>3)ExtractTextWebpackPlugin    </p><p>从 bundle 中提取文本（CSS）到分离的文件（app.bundle.css）</p><p>4)ProvidePlugin</p><p>ProvidePlugin可以将模块作为一个变量，被webpack在其他每个模块中引用。只有你需要使用此变量的时候，这个模块才会被 require进来。多数之前遗留的模块，会依赖于已存在的某些特定全局变量，比如jQuery插件中的$或者jQuery。在这种场景，你可以在每次遇到全局标识符$的时候，在webpack中预先设置var $ = require(“jquery”)。</p><pre><code>module.exports = &#123;  plugins: [    new webpack.ProvidePlugin(&#123;      $: &#39;jquery&#39;,      jQuery: &#39;jquery&#39;    &#125;)  ]&#125;;</code></pre><h2 id="Environment-flags"><a href="#Environment-flags" class="headerlink" title="Environment flags"></a>Environment flags</h2><p>windows下使用cross-env的npm包兼容处理，可以在package.json设置如下：</p><pre><code>&quot;scripts&quot;: &#123;    &quot;clear&quot;: &quot;rm -rf build&amp;&amp; mkdir build&quot;,    &quot;start&quot;: &quot;npm run clear&amp;&amp; cross-env NODE_ENV=development webpack-dev-server --host 0.0.0.0 --devtool eval --progress --color --profile&quot;,    &quot;deploy&quot;: &quot;npm run clear&amp;&amp; cross-env NODE_ENV=production webpack -p --progress&quot;&#125;</code></pre><p>webpack.config.js</p><pre><code>var isProduction = process.env.NODE_ENV === &#39;production&#39;;plugins: [new webpack.DefinePlugin(&#123;    &#39;process.env&#39;: &#123;        &#39;NODE_ENV&#39;: JSON.stringify(process.env.NODE_ENV || &#39;development&#39;)    &#125;&#125;)]</code></pre><h2 id="Code-splitting（代码分割）"><a href="#Code-splitting（代码分割）" class="headerlink" title="Code splitting（代码分割）"></a>Code splitting（代码分割）</h2><p>使用require.ensure</p><pre><code>// main.jsrequire.ensure([&#39;./a&#39;], function(require) &#123;  var content = require(&#39;./a&#39;);  document.open();  document.write(&#39;&lt;h1&gt;&#39; + content + &#39;&lt;/h1&gt;&#39;);  document.close();&#125;);// a.jsmodule.exports = &#39;Hello World&#39;;</code></pre><p>require.ensure告诉Webpack，./a.js应该从bundle.js分离并且打包成一个单独的文件</p><p><strong>注意require.ensure只会加载模块而不会去解析</strong></p><p>也可以用bundle-loader进行代码分割</p><pre><code>// main.js// Now a.js is requested, it will be bundled into another filevar load = require(&#39;bundle-loader!./a.js&#39;);// To wait until a.js is available (and get the exports)//  you need to async wait for it.load(function(file) &#123;  document.open();  document.write(&#39;&lt;h1&gt;&#39; + file + &#39;&lt;/h1&gt;&#39;);  document.close();&#125;);</code></pre><h2 id="vendor-chunk"><a href="#vendor-chunk" class="headerlink" title="vendor chunk"></a>vendor chunk</h2><p>可以用CommonsChunkPlugin插件将公共库(vendor)打包成一个单独的文件</p><pre><code>var webpack = require(&#39;webpack&#39;);module.exports = &#123;  entry: &#123;    app: &#39;./main.js&#39;,    vendor: [&#39;jquery&#39;],  &#125;,  output: &#123;    filename: &#39;bundle.js&#39;  &#125;,  plugins: [    new webpack.optimize.CommonsChunkPlugin(/* chunkName= */&#39;vendor&#39;, /* filename= */&#39;vendor.js&#39;)  ]&#125;;</code></pre><h2 id="模块热替换-Hot-Module-Replacement"><a href="#模块热替换-Hot-Module-Replacement" class="headerlink" title="模块热替换(Hot Module Replacement)"></a>模块热替换(Hot Module Replacement)</h2><p>npm i webpack-dev-server –save-dev</p><p><a href="https://segmentfault.com/a/1190000003872635">配置</a></p><h2 id="主要参考资料"><a href="#主要参考资料" class="headerlink" title="主要参考资料"></a>主要参考资料</h2><p><a href="https://webpack.github.io/docs/">webpack官方文档</a></p><p><a href="https://github.com/ruanyf/webpack-demos">阮一峰webpack教程</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机 </tag>
            
            <tag> 前端 </tag>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>web组件开发入门</title>
      <link href="/posts/22329.html"/>
      <url>/posts/22329.html</url>
      
        <content type="html"><![CDATA[<p>本文是学习慕课网<a href="http://www.imooc.com/learn/99">阿当大话西游之WEB组件</a>后的一个总结。</p><h2 id="组件的分类"><a href="#组件的分类" class="headerlink" title="组件的分类"></a>组件的分类</h2><p>1 框架组件：依赖于某种框架的组件</p><p>2 定制组件：根据公司业务定制的组件</p><p>3 独立组件：不依赖框架的组件</p><h2 id="定义和加载组件"><a href="#定义和加载组件" class="headerlink" title="定义和加载组件"></a>定义和加载组件</h2><h3 id="解决css和js命名冲突"><a href="#解决css和js命名冲突" class="headerlink" title="解决css和js命名冲突"></a>解决css和js命名冲突</h3><p>css：通过加前缀来形成命名空间，不要用子孙选择器</p><p>js：通过匿名函数自执行来隐藏变量，通过给window添加属性来暴露全局变量</p><pre><code>(function()&#123;    var abc = 5;    function TabView(cfg)&#123;        this.a = cfg.a;        this.b = cfg.b;    &#125;    TabView.prototype = &#123;        c: function()&#123;            abc++;        &#125;,        d: function()&#123;            abc--;        &#125;    &#125;    window.TabView = TabView;&#125;)();</code></pre><h3 id="组件的依赖关系"><a href="#组件的依赖关系" class="headerlink" title="组件的依赖关系"></a>组件的依赖关系</h3><p>传统通过script标签引入组件的问题：</p><p>1 需手动处理组件间的依赖关系</p><p>2 加载项太多，破坏页面的整洁度</p><p>如何解决：使用require.js</p><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><h3 id="如何定制皮肤"><a href="#如何定制皮肤" class="headerlink" title="如何定制皮肤"></a>如何定制皮肤</h3><p>通过cfg设置一个skinClassName参数来给容器添加class来控制皮肤</p><h3 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h3><p>简单回调的问题</p><p>1）只能绑定一个回调</p><p>2）回调的绑定时间和组件的实例化时间耦合在一起</p><p>如果相对独立的多个功能模块都需要绑定组件的同一事件，怎么办？</p><p>自定义事件本质：观察者模式</p><p>优点：跳出原生事件的限制，提高封装的抽象层级</p><h3 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h3><p>return this</p><h2 id="Widget类"><a href="#Widget类" class="headerlink" title="Widget类"></a>Widget类</h2><p>原生function类的问题</p><p>1）所有类继承自object</p><p>2）Object提供的帮助太少了</p><p>组件分类：</p><p>Utility：与UI无关</p><p>Widget：与UI有关</p><h3 id="为Widget类添加统一的生命周期"><a href="#为Widget类添加统一的生命周期" class="headerlink" title="为Widget类添加统一的生命周期"></a>为Widget类添加统一的生命周期</h3><h2 id="更高级的内容"><a href="#更高级的内容" class="headerlink" title="更高级的内容"></a>更高级的内容</h2><p>组件的MVC</p>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机 </tag>
            
            <tag> 前端 </tag>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flexbox学习总结</title>
      <link href="/posts/7684.html"/>
      <url>/posts/7684.html</url>
      
        <content type="html"><![CDATA[<h2 id="flex语法"><a href="#flex语法" class="headerlink" title="flex语法"></a>flex语法</h2><p>采用Flex布局的元素，称为Flex容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称”项目”。</p><p>容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。</p><p>项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。</p><h3 id="容器上的属性"><a href="#容器上的属性" class="headerlink" title="容器上的属性"></a>容器上的属性</h3><p>以下6个属性设置在容器上：</p><pre><code>flex-directionflex-wrapflex-flowjustify-contentalign-itemsalign-content</code></pre><p>flex-direction：flex-direction属性决定主轴的方向（即项目的排列方向）。</p><pre><code>row(默认) | row-reverse | column | column-reverse</code></pre><p>flex-wrap：默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。</p><pre><code>nowrap(默认) | wrap | wrap-reverse</code></pre><p>flex-flow：flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap</p><p>justify-content：justify-content属性定义了项目在主轴上的对齐方式。</p><pre><code>flex-start | flex-end | center | space-between | space-around</code></pre><p>align-items属性：align-items属性定义项目在交叉轴上如何对齐。</p><pre><code>flex-start | flex-end | center | baseline | stretch</code></pre><p>align-content：align-content属性定义了多根轴线在交叉轴上的对齐方式。如果项目只有一根轴线，该属性不起作用</p><pre><code>flex-start | flex-end | center | space-between | space-around | stretch</code></pre><h3 id="项目上的属性"><a href="#项目上的属性" class="headerlink" title="项目上的属性"></a>项目上的属性</h3><p>以下6个属性设置在项目上：</p><pre><code>orderflex-growflex-shrinkflex-basisflexalign-self</code></pre><p>order：order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。</p><p>flex-grow：flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。</p><p>如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。</p><p>flex-shrink：flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。</p><p>如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。</p><p>flex-basis：flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。</p><pre><code>flex-basis: &lt;length&gt; | auto; /* default auto */</code></pre><p>它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。</p><p>flex：flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。</p><p>该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。</p><p>建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。</p><p>align-self：align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。</p><pre><code>align-self: auto | flex-start | flex-end | center | baseline | stretch</code></pre><h2 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h2><p>网格布局</p><p>1 基本网格布局</p><p>最简单的网格布局，就是平均分布。item设置flex:1即可</p><pre><code>.Grid &#123;  display: flex;&#125;.Grid-cell &#123;  flex: 1;&#125;</code></pre><p>2 百分比布局</p><p>某个网格的宽度为固定的百分比，其余网格平均分配剩余的空间。</p><p>给需要百分比的item设置width: 百分比;或flex: 0 0 百分比;，自动分配的item设置flex: 1;</p><p>3 圣杯布局</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta name=&quot;description&quot; content=&quot;flex 圣杯布局&quot;&gt;  &lt;meta charset=&quot;utf-8&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot;&gt;  &lt;title&gt;JS Bin&lt;/title&gt;&lt;/head&gt;&lt;body class=&quot;HolyGrail&quot;&gt;  &lt;header&gt;header&lt;/header&gt;  &lt;div class=&quot;HolyGrail-body&quot;&gt;    &lt;main class=&quot;HolyGrail-content&quot;&gt;content&lt;/main&gt;    &lt;nav class=&quot;HolyGrail-nav&quot;&gt;left nav&lt;/nav&gt;    &lt;aside class=&quot;HolyGrail-ads&quot;&gt;right ad&lt;/aside&gt;  &lt;/div&gt;  &lt;footer&gt;footer&lt;/footer&gt;&lt;/body&gt;&lt;/html&gt;*&#123;  margin: 0;&#125;.HolyGrail &#123;  display: flex;  min-height: 100vh;  flex-direction: column;  text-align: center;&#125;header,footer &#123;  flex: 0 0 40px;  background-color: #ccc;&#125;.HolyGrail-body &#123;  display: flex;  flex: 1;&#125;.HolyGrail-content &#123;  flex: 1;  background-color: #0f0;  &#125;.HolyGrail-nav, .HolyGrail-ads &#123;  /* 两个边栏的宽度设为12em */  flex: 0 0 12em;  background-color: #00f;&#125;.HolyGrail-nav &#123;  /* 导航放到最左边 */  order: -1;  background-color: #f00;&#125;</code></pre><p><a href="https://jsbin.com/lusunofase/1/edit?html,css,output">查看demo</a></p><p>如果是小屏幕，躯干的三栏自动变为垂直叠加。</p><pre><code>@media (max-width: 768px) &#123;  .HolyGrail-body &#123;    flex-direction: column;    flex: 1;  &#125;  .HolyGrail-nav,  .HolyGrail-ads,  .HolyGrail-content &#123;    flex: auto;  &#125;&#125;</code></pre><p>4 流式布局</p><p>每行的项目数固定，会自动分行。</p><pre><code>.parent &#123;  width: 200px;  height: 150px;  background-color: black;  display: flex;  flex-flow: row wrap;  align-content: flex-start;&#125;.child &#123;  box-sizing: border-box;  background-color: white;  flex: 0 0 25%;  height: 50px;  border: 1px solid red;&#125;</code></pre><p>兼容</p><pre><code>*在旧版的规范中，使用比例伸缩布局时，子元素的内容长短不同会导致无法“等分”，这个时候，我们需要给子元素设置一个“width:0%”来解决问题。*不要给flexbox里的子元素设置“margin:auto”的属性，在部分安卓机下，它会导致该元素的宽度撑开到100%占位</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>css tricks上的<a href="https://css-tricks.com/snippets/css/a-guide-to-flexbox/">A Complete Guide to Flexbox</a></p><p>阮一峰的<a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html">Flex 布局教程：语法篇</a></p><p>腾讯ISUX的<a href="https://isux.tencent.com/flexbox.html">移动端全兼容的flexbox速成班</a></p><p><a href="http://www.ruanyifeng.com/blog/2015/07/flex-examples.html">更多参考</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机 </tag>
            
            <tag> 前端 </tag>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webstorm入门</title>
      <link href="/posts/31473.html"/>
      <url>/posts/31473.html</url>
      
        <content type="html"><![CDATA[<h2 id="主题和配色"><a href="#主题和配色" class="headerlink" title="主题和配色"></a>主题和配色</h2><p><a href="https://github.com/OtaK/jetbrains-monokai-sublime">sublime主题</a></p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>配置分类</p><p>webstorm 的配置分为项目配置和全局配置，在打开一个项目的时候，会在项目根目录生成.idea的隐藏文件夹，这个文件夹里保存的就是项目配置，而全局配置保存在文档目录，全局配置都可以导出。</p><p>通过file &gt; settings打开配置窗口</p><h3 id="全局配置"><a href="#全局配置" class="headerlink" title="全局配置"></a>全局配置</h3><p>1 插件配置：Plugins</p><p>2 SVN、github配置：Version Control</p><p>3 文件模板配置: Editor &gt; File and Code Templates </p><h3 id="项目配置"><a href="#项目配置" class="headerlink" title="项目配置"></a>项目配置</h3><p>1 SVN、Git 配置</p><p>SVN 使用的是命令行工具，因此在 windows 下需要额外安装 svn 命令行软件，<a href="http://subversion.apache.org/packages.html#windows">地址</a>,通过这种方法暂时不能使用1.9 format，只能使用更低的如1.8 format。其实在安装了TortoiseSVN时，只要把subversion &gt; general的所有勾去掉即可。</p><p>配置 github 的最后会弹出输入保存用户名和密码的数据进行密码保护的确认，建议点击 cancel 即可。</p><p>2 项目文件夹标记配置</p><p>在开发的时候，常常资源等信息并不是指向根目录，在书写资源路径的时候提示是不正确的，这时候就需要配置文件夹功能了。打开Project &gt; Directories 里打开</p><p>绿色的为测试目录，红色的为排除目录，蓝色的为资源根目录。设置docs和node_modules排除目录</p><p>3 项目代码检查</p><p>打开Languages and Frameworks &gt; JavaScript &gt; Code Quality Tolls &gt; JSHint 启用，默认配置即可。</p><p>4 CSS预处理语言的预编译、JS 实时压缩</p><p>有了 webstorm，基本不需要 grunt、gulp 等前端开发辅助工具了，webstorm 内置的文件监听，可以完成常用的功能，如 CSS 预处理语言的预编译、JS 的实时压缩等。</p><p>打开Tools &gt; File Watchers，然后点击右边的加号开始新建即可</p><p>5 项目脚本库</p><p>打开Languages and Frameworks &gt; JavaScript &gt; Libraries </p><h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><p>ctrl+/ 单行注释</p><p>ctrl+shift+/    块注释</p><p>ctrl+shift+ +/-    展开/折叠</p><p>ctrl+alt+L 格式化代码</p><p>ctrl+shift+ up/down 上下移动句子</p><p>Alt+回车 导入包,自动修正</p><p>Ctrl+N 查找类</p><p>Ctrl+Shift+N 查找文件</p><p>Ctrl+Alt+L 格式化代码</p><p>Ctrl+Alt+O 优化导入的类和包</p><p>Alt+Insert 生成代码(如get,set方法,构造函数等)</p><p>Ctrl+E或者Alt+Shift+C 最近更改的代码</p><p>Ctrl+R 替换文本</p><p>Ctrl+F 查找文本</p><p>Ctrl+Shift+Space 自动补全代码</p><p>Ctrl+空格 代码提示</p><p>Ctrl+Alt+Space 类名或接口名提示</p><p>Ctrl+P 方法参数提示</p><p>Ctrl+Shift+Alt+N 查找类中的方法或变量</p><p>Alt+Shift+C 对比最近修改的代码</p><p>Shift+F6 重构-重命名</p><p>Ctrl+Shift+先上键</p><p>Ctrl+X 删除行</p><p>Ctrl+D 复制行</p><p>Ctrl+/ 或 Ctrl+Shift+/ 注释（// 或者/<em>…</em>/ ）</p><p>Ctrl+J 自动代码</p><p>Ctrl+E 最近打开的文件</p><p>Ctrl+H 显示类结构图</p><p>Ctrl+Q 显示注释文档</p><p>Alt+F1 查找代码所在位置</p><p>Alt+1 快速打开或隐藏工程面板</p><p>Alt+2 快速打开或隐藏favorites</p><p>Ctrl+Alt+ left/right 返回至上次浏览的位置</p><p>Alt+ left/right 切换代码视图</p><p>Alt+ Up/Down 在方法间快速移动定位</p><p>Ctrl+Shift+Up/Down 代码向上/下移动。</p><p>F2 或Shift+F2 高亮错误或警告快速定位</p><p>代码标签输入完成后，按Tab，生成代码。</p><p>选中文本，按Ctrl+Shift+F7 ，高亮显示所有该文本，按Esc高亮消失。</p><p>Ctrl+W 选中代码，连续按会有其他效果</p><p>选中文本，按Alt+F3 ，逐个往下查找相同文本，并高亮显示。</p><p>Ctrl+Up/Down 光标跳转到第一行或最后一行下</p><p>Ctrl+B 快速打开光标处的类或方法</p><p>参考：</p><p><a href="http://frontenddev.org/article/webstorm-portal-2-configuration.html">webstorm入门2-配置</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机 </tag>
            
            <tag> 前端 </tag>
            
            <tag> webstorm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jQuery插件开发入门</title>
      <link href="/posts/14775.html"/>
      <url>/posts/14775.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>jQuery插件开发包括两种：</p><ol><li><p>给jQuery添加静态方法</p></li><li><p>给jQuery的原型添加方法</p></li></ol><h2 id="给jQuery添加静态方法"><a href="#给jQuery添加静态方法" class="headerlink" title="给jQuery添加静态方法"></a>给jQuery添加静态方法</h2><ol><li><p>直接添加新的全局函数</p><p> jQuery.foo = function() {   </p><pre><code> alert(&#39;This is a test. This is only a test.&#39;);  </code></pre><p> };</p></li><li><p>使用jQuery.extend(object)</p><p> jQuery.extend({      </p><pre><code> foo: function() &#123;           alert(&#39;This is a test. This is only a test.&#39;);       &#125;,       bar: function(param) &#123;           alert(&#39;This function takes a parameter, which is &quot;&#39; + param +&#39;&quot;.&#39;);       &#125;     </code></pre><p> }); </p></li></ol><p>对于一些全局配置的插件，可以在插件中进行调用，这样直接引用插件javascript即可，不用再调用</p><h2 id="给jQuery的原型添加方法"><a href="#给jQuery的原型添加方法" class="headerlink" title="给jQuery的原型添加方法"></a>给jQuery的原型添加方法</h2><p>这是插件开发中最常用的一种方法</p><h3 id="最简单的形式"><a href="#最简单的形式" class="headerlink" title="最简单的形式"></a>最简单的形式</h3><pre><code>(function($)&#123;           $.fn.pluginName = function() &#123;              // code        &#125;;     &#125;)(jQuery);  </code></pre><h3 id="上下文"><a href="#上下文" class="headerlink" title="上下文"></a>上下文</h3><p>在插件函数的立即作用域中，关键字this指向调用插件的jQuery对象，不需要再用$包裹</p><pre><code>(function($)&#123;    $.fn.pluginName = function() &#123;                // 没有必要再写$(this)，因为&quot;this&quot;就是jQuery对象                   &#125;;          &#125;)(jQuery);</code></pre><h3 id="保持链式调用"><a href="#保持链式调用" class="headerlink" title="保持链式调用"></a>保持链式调用</h3><p>为了保持链式调用，插件请return this。</p><h3 id="设置默认参数并将之暴露出来"><a href="#设置默认参数并将之暴露出来" class="headerlink" title="设置默认参数并将之暴露出来"></a>设置默认参数并将之暴露出来</h3><pre><code>(function($)&#123;    $.fn.pluginName = function(options) &#123;            var opts = $.extend(&#123;&#125;, $.fn.hilight.defaults, options);          &#125;;      $.fn.pluginName.defaults = &#123;            foo: &#39;bar&#39;       &#125;;                        &#125;)(jQuery); </code></pre><p>这样用户既可以用过传参也可以通过修改$.fn.pluginName.defaults来修改默认参数</p><h3 id="暴露一些公有函数"><a href="#暴露一些公有函数" class="headerlink" title="暴露一些公有函数"></a>暴露一些公有函数</h3><pre><code>(function($)&#123;    $.fn.pluginName = function(options) &#123;            var opts = $.extend(&#123;&#125;, $.fn.pluginName.defaults, options);          &#125;;      $.fn.pluginName.defaults = &#123;            foo: &#39;bar&#39;       &#125;;      $.fn.pluginName.foo = function() &#123;            return &#39;bar&#39;;        &#125;;                       &#125;)(jQuery);</code></pre><p>这样用户既可以调用公有函数，也可以去修改它。</p><h3 id="更安全的闭包写法"><a href="#更安全的闭包写法" class="headerlink" title="更安全的闭包写法"></a>更安全的闭包写法</h3><pre><code>;(function($,window,document,undefined)&#123;    $.fn.pluginName = function() &#123;              // code        &#125;;&#125;)(jQuery,window,document);</code></pre><p>加上“;”是为了防止插件之前代码没有“;”引发的错误，加上window和document是这样window等系统变量在插件内部就有了一个局部的引用，可以提高访问速度，同时内部也可以压缩这些变量，undefined是为了防止他人误修改undefined引发插件bug。</p><h3 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h3><p>以下出自网友的<a href="http://www.ghugo.com/javascript-writing-better-jquery-plugins/">博客</a></p><pre><code>(function () &#123;       var Plugin,        privateMethod;  //插件的私有方法         /**     * 这里是一个自运行的单例模式。     *      */    Plugin = (function () &#123;         /**         * 插件实例化部分，初始化时调用的代码可以放这里         */        function Plugin(element, options) &#123;            //将插件的默认参数及用户定义的参数合并到一个新的obj里            this.settings = $.extend(&#123;&#125;, $.fn.plugin.defaults, options);            //将dom jquery对象赋值给插件，方便后续调用            this.$element = $(element);                     &#125;         /**         * 插件的公共方法，相当于接口函数，用于给外部调用         */        Plugin.prototype.doSomething = function () &#123;            /**             * 方法内容             */        &#125;;                 return Plugin;     &#125;)();     /**     * 插件的私有方法     */    privateMethod = function () &#123;         &#125;;     /**     * 这里是关键     * 定义一个插件 plugin     */    $.fn.plugin = function (options) &#123;        var instance;        instance = this.data(&#39;plugin&#39;);        /**         *判断插件是否已经实例化过，如果已经实例化了则直接返回该实例化对象         */        if (!instance) &#123;            return this.each(function () &#123;                //将实例化后的插件缓存在dom结构里（内存里）                return $(this).data(&#39;plugin&#39;, new Plugin(this, options));            &#125;);        &#125;        if (options === true) return instance;        /**         * 优雅处： 如果插件的参数是一个字符串，则 调用 插件的 字符串方法。         * 如 $(&#39;#id&#39;).plugin(&#39;doSomething&#39;) 则实际调用的是 $(&#39;#id).plugin.doSomething();         * doSomething是刚才定义的接口。         * 这种方法 在 juqery ui 的插件里 很常见。         */        if ($.type(options) === &#39;string&#39;) instance[options]();        return this;    &#125;;         /**     * 插件的默认值     */    $.fn.plugin.defaults = &#123;        property1: &#39;value&#39;,        property2: &#39;value&#39;    &#125;;     /**     * 优雅处： 通过data-xxx 的方式 实例化插件。     * 这样的话 在页面上就不需要显示调用了。     */    $(function () &#123;        return new Plugin($(&#39;[data-plugin]&#39;));    &#125;);   &#125;).call(this);</code></pre><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://www.learningjquery.com/2007/10/a-plugin-development-pattern">A Plugin Development Pattern</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机 </tag>
            
            <tag> 前端 </tag>
            
            <tag> javascript </tag>
            
            <tag> jQuery </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript常见封装方法</title>
      <link href="/posts/48038.html"/>
      <url>/posts/48038.html</url>
      
        <content type="html"><![CDATA[<p>1.最简单的，使用变量，然后用匿名函数包裹，不封装</p><p>2.对象字面量简单封装（不完整的模块模式，因为无法达到变量、方法私有效果。不过确实有分离和组织代码的能力，也就算一种简略的模块模式的实现方式）</p><pre><code>var Carousel = &#123;    init: function()&#123;...&#125;,    bind: function()&#123;...&#125;,    showPre: function()&#123;...&#125;,    showNext: function()&#123;...&#125;&#125;;</code></pre><p>3.原型构造器模式封装</p><pre><code>function Carousel()&#123;    this.init();&#125;Carousel.prototype = &#123;    init: function()&#123;...&#125;,    bind: function()&#123;...&#125;,    showPre: function()&#123;...&#125;,    showNext: function()&#123;...&#125;&#125;;</code></pre><p>4.模块模式与原型构造器模式绑定多个：使用一个数组保存实例</p><pre><code>var CarouselCenter = (function()&#123;    var carouselList = [];    function init($carousel)&#123;        $carousel.each(function()&#123;            var $cal = $(this);            if($cal.hasClass(&#39;init&#39;))&#123;                return;            &#125;            carouselList.push( new Carousel($cal) );            $cal.addClass(&#39;init&#39;)        &#125;);    &#125;    function getList()&#123;        return carouselList;    &#125;    function Carousel($carousel)&#123;    &#125;    Carousel.prototype = &#123;        bind: function()&#123;            var _this = this;            this.$pre.on(&#39;click&#39;, function()&#123;                _this.showPre();            &#125;);            this.$next.on(&#39;click&#39;, function()&#123;                _this.showNext();            &#125;);        &#125;,        showPre: function()&#123;            this.$ct.prepend(this.$ct.children().last());            this.$ct.css(&#39;left&#39;, 0-this.imgWidth);            this.$ct.animate(&#123;&#39;left&#39;: 0&#125;);        &#125;,        showNext: function()&#123;            var $ct = this.$ct;            $ct.animate(&#123;&#39;left&#39;: 0-this.imgWidth&#125;,function()&#123;                $ct.append($ct.children().first());                $ct.css(&#39;left&#39;, 0);            &#125;);        &#125;    &#125;;    return &#123;        init: init,        getList: getList    &#125;&#125;)(); // 调用    // CarouselCenter.init($(&#39;#c1&#39;))// CarouselCenter.init($(&#39;#c2&#39;))// CarouselCenter.init($(&#39;#c2&#39;)) //不会重复绑定// CarouselCenter.init($(&#39;.carousel&#39;)) </code></pre><p>5.通用写法</p><pre><code>(function(window,$)&#123;    function Carousel()&#123;    &#125;;    Carousel.prototype = &#123;    &#125;;    window.Carousel = Carousel;&#125;)(window,jQuery)</code></pre><p>ps:</p><p>模式目的：编写易于维护的代码，其中一个最重要方面是能够找到代码中重复出现的主题并优化它们。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机 </tag>
            
            <tag> 前端 </tag>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js高级程序设计学习之高级函数</title>
      <link href="/posts/31836.html"/>
      <url>/posts/31836.html</url>
      
        <content type="html"><![CDATA[<h2 id="安全的类型检测"><a href="#安全的类型检测" class="headerlink" title="安全的类型检测"></a>安全的类型检测</h2><pre><code>function isArray(value)&#123;    return Object.prototype.toString.call(value) === &quot;[object Array]&quot;;&#125;function isFunction(value)&#123;    return Object.prototype.toString.call(value) === &quot;[object Function]&quot;;&#125;//检测原生JSON对象function isRegExp(value)&#123;    return Object.prototype.toString.call(value) === &quot;[object RegExp]&quot;;&#125;var isNativeJson = window.JSON &amp;&amp; Object.prototype.toString.call(JSON) === &quot;[object JSON]&quot;;</code></pre><p>不过要注意Object.prototype.toString本身可能被改写。</p><h2 id="作用域安全的构造函数"><a href="#作用域安全的构造函数" class="headerlink" title="作用域安全的构造函数"></a>作用域安全的构造函数</h2><p>当使用new调用构造函数时，构造函数内用到的this对象会指向新创建的对象实例，如：</p><pre><code>function Person (name) &#123;    this.name = name;&#125;var person = new Person(&quot;oliver&quot;);console.log(person.name);</code></pre><p>问题是当没有使用new操作符，直接调用构造函数，this会映射到全局对象window上，导致错误对象属性的意外增加：</p><pre><code>function Person (name) &#123;    this.name = name;&#125;var person = Person(&quot;oliver&quot;);console.log(window.name); //oliver</code></pre><p>解决办法是创建一个作用域安全的构造函数：</p><pre><code>function Person(name) &#123;    if (this instanceof Person) &#123; //如果this是Person的实例        this.name = name;    &#125; else &#123;        return new Person(name); //否则调用new操作符    &#125;&#125;var person1 = Person(&quot;oliver&quot;);console.log(person1.name); //olivervar person2 = new Person(&quot;troy&quot;);console.log(person2.name); //troyconsole.log(window.name); //&quot;&quot;</code></pre><p>但是，如果使用构造函数窃取模式的继承且不实用原型链，那么这个继承很可能被破坏如：</p><pre><code>function Person(name) &#123;    if (this instanceof Person) &#123; //如果this是Person的实例        this.name = name;    &#125; else &#123;        return new Person(name); //否则调用new操作符    &#125;&#125;function People (name,age) &#123;    Person.call(this, name);    this.age = age;&#125;var p = new People(&quot;Oliver&quot;, 18);console.log(p.name); //undefinedconsole.log(p.age); //18</code></pre><p>结合使用原型链或者寄生组合则可以解决这个问题：</p><pre><code>function Person(name) &#123;    if (this instanceof Person) &#123; //如果this是Person的实例        this.name = name;    &#125; else &#123;        return new Person(name); //否则调用new操作符    &#125;&#125;function People (name,age) &#123;    Person.call(this, name);    this.age = age;&#125;People.prototype = new Person(); //关键点var p = new People(&quot;Oliver&quot;, 18);console.log(p.name); //Oliverconsole.log(p.age); //18</code></pre><h2 id="惰性载入函数"><a href="#惰性载入函数" class="headerlink" title="惰性载入函数"></a>惰性载入函数</h2><p>惰性函数表示函数执行的分支仅会发生一次。有两种实现惰性载入函数的方式，第一种就是在函数被调用时在处理函数。在第一次调用的过程中，该函数被覆盖为另一个按合适方式执行的函数，这样任何对原函数的调用就不用再经过执行的分支了。</p><pre><code>function createXHR () &#123;    if (typeof XMLHttpRequest !== &quot;undefined&quot;) &#123;        createXHR = function () &#123; //关键点            return new XMLHttpRequest();        &#125;    &#125; else if (typeof ActiveXObject !== &quot;undefined&quot;) &#123;        createXHR = function () &#123; //关键点            return new ActiveXObject([&quot;MSXML2.XMLHttp&quot;]);        &#125;    &#125; else &#123;        createXHR = function () &#123; //关键点            throw new Error(&quot;No XHR object available.&quot;);        &#125;    &#125;    return createXHR(); //关键点&#125;</code></pre><p>第二种实现惰性载入函数的方式就是在声明函数时就指定适当的函数。这样，第一次调用函数时就不会损失性能了，而在代码首次加载时会损失一些性能。</p><pre><code>var createXHR = (function() &#123;    if (typeof XMLHttpRequest !== &quot;undefined&quot;) &#123;        return function () &#123; //关键点            return new XMLHttpRequest();        &#125;    &#125; else if (typeof ActiveXObject !== &quot;undefined&quot;) &#123;        return function () &#123; //关键点            return new ActiveXObject([&quot;MSXML2.XMLHttp&quot;]);        &#125;    &#125; else &#123;        return function () &#123; //关键点            throw new Error(&quot;No XHR object available.&quot;);        &#125;    &#125;&#125;)();</code></pre><p>这个例子中使用的技巧是创建一个匿名、自执行的函数，用以确定应该使用哪一个函数实现。</p><h2 id="函数绑定"><a href="#函数绑定" class="headerlink" title="函数绑定"></a>函数绑定</h2><p>函数绑定要创建一个函数，可以在特定的this环境中以指定参数调用另一个函数。该技巧常常和回调函数与事件处理程序一起使用， 以便在将函数作为变量传递的同时保留代码的执行环境。</p><pre><code>var handler = &#123;  message: &quot;Event handled&quot;,  handleClick: function(event)&#123;    console.log(this.message);  &#125;&#125;;handler.handleClick();var a = handler.handleClick;a();var btn1 = document.getElementById(&#39;my-btn1&#39;);btn1.addEventListener(&#39;click&#39;,handler.handleClick,false);var btn2 = document.getElementById(&#39;my-btn2&#39;);btn2.addEventListener(&#39;click&#39;,function()&#123;  handler.handleClick();&#125;,false);</code></pre><p>btn1点击后显示undefined，btn2利用闭包来修正这个问题</p><p>由于代码之中存在着this变量，而this在当前环境下指向确定的对象，但是当更改代码的执行环境时，就会出现问题了。为了解决这个问题， javascript函数库中实现了一个bind() 函数来解决这个问题。</p><p>一个简单的bind() 函数接收一个函数和一个环境， 并返回一个在给定环境中调用给定函数的函数， 并且将所有参数原封不动传递过去。 语法如下：</p><pre><code>function bind(fn, context) &#123;    return function() &#123;        return fn.apply(context, arguments);    &#125;&#125;</code></pre><p>注意这里使用的arguments并不是bind() 的， 是内部函数的。</p><pre><code>var handler = &#123;    message: &quot;Event handled&quot;,    handleClick: function(event) &#123;        alert(this.message);    &#125;&#125;;var btn = document.getElementById(&quot;my-btn&quot;);EventUtil.addHandler(btn, &quot;click&quot;, bind(handler.handleClick, handler));</code></pre><p>ECMAScript5为所有函数定义了一个原生的bind() 方法， 进一步简化了操作。</p><pre><code>var handler = &#123;    message: &quot;Event handled&quot;,    handleClick: function(event) &#123;        alert(this.message);    &#125;&#125;;var btn = document.getElementById(&quot;my-btn&quot;);EventUtil.addHandler(btn, &quot;click&quot;, handler.handleClick.bind(handler));</code></pre><p>它们主要用于事件处理程序以及setTimeout() 和setInterval()。 然而被绑定函数与普通函数相比有更多的开销， 它们需要更多内存， 同时也因为多重函数调用稍微慢一些， 所以最好只在必要时使用。</p><h2 id="函数柯里化"><a href="#函数柯里化" class="headerlink" title="函数柯里化"></a>函数柯里化</h2><p>它用于创建已经设置好了一个或多个参数的函数。 函数柯里化的基本方法是： 使用一个闭包返回一个函数。 当函数被调用时， 返回的函数还需要设置一些传入的参数。</p><p>柯里化函数通常由以下步骤动态的创建： 调用另一个函数并为它传入要柯里化的函数和必要参数。 下面是创建柯里化函数的通用方式：</p><pre><code>function curry(fn) &#123;    var args = Array.prototype.slice.call(arguments, 1);    return function() &#123;        var innerArgs = Array.prototype.slice.call(arguments);        var finalArgs = args.concat(innerArgs);        return fn.apply(null, finalArgs);    &#125;&#125;</code></pre><p>函数柯里化还常常作为函数绑定的一部分包含在其中，构造出更为复杂的bind函数</p><pre><code>function bind(fn,contenxt) &#123;    var args = Array.prototype.slice.call(arguments,2);    return function() &#123;        var innerArgs = Array.prototype.slice.call(arguments);        var finalArgs = args.cancat(innerArgs);        return fn.apply(context,finalArgs);    &#125;&#125;</code></pre><p>当你想除了event对象再额外给事件处理程序传递参数时，这非常有用。</p><pre><code>EventUtil.addHandler(btn, &quot;click&quot;, bind(handler.handleClick,handler,&quot;my-btn&quot;)); </code></pre><p>ES5的bind方法也实现了函数柯里化，只需要在this值后再传另一个参数</p><pre><code>EventUtil.addHandler(btn, &quot;click&quot;, handler.handleClick.bind(handler,&quot;my-btn&quot;));</code></pre><p>函数绑定和柯里化都不应滥用，因为每个函数会带来额外的开销</p>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机 </tag>
            
            <tag> 前端 </tag>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jQuery API学习总结</title>
      <link href="/posts/25542.html"/>
      <url>/posts/25542.html</url>
      
        <content type="html"><![CDATA[<p>jQuery，在工作中很常用，但是很多API或者使用这些API的注意事项也经常会忘记，因此写个博客总结一下，这样也能复习一下jQuery API。主要参考了<a href="http://www.css88.com/jqapi-1.9/">jQuery中文文档</a>,适用于jQuery1.9~3.1版本。</p><p>jQuery API主要分为选择器、属性/CSS相关（属性、CSS、尺寸、位置）、数据data、DOM操作、遍历和筛选、事件、效果、Ajax、jQuery核心、实用工具、延迟对象、回调对象和其他一些杂项。</p><h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><p>基本选择、层级选择、属性选择、子元素筛选这些和CSS基本一致。jQuery还支持这些选择器：</p><h3 id="基本筛选"><a href="#基本筛选" class="headerlink" title="基本筛选"></a>基本筛选</h3><p>:animated  </p><p><em>注意事项1:  如果您使用一个自定义的jQuery绑定一个没有效果模块，:animated选择器会抛出一个错误；</em></p><p><em>注意事项2: 因为:animated是一个jQuery延伸出来的选择器，并不是的CSS规范的一部分，使用:animated查询不能充分利用原生DOM提供的querySelectorAll() 方法来提高性能。为了当使用:animated 的时候在现代浏览器上获得更佳的性能，首先使用纯CSS选择器选择元素，然后使用.filter(“:animated”)，其他非CSS规范选择器同理。</em></p><p>:eq(index)  </p><p>要匹配元素的索引值，从0开始计数（由于JavaScript数组使用基于0的索引，而:nth-child(n)是基于1的索引的，以符合CSS规范），支持负值</p><p>:even </p><p>这是基于0的索引，所以:even选择器是选择第一个元素，第三个元素，依此类推在匹配</p><p>:first</p><p>:first伪类选择器相当于:eq(0)。它也可以写为:lt(1)。虽然:first只匹配一个单独的元素，但是:first-child选择器可以匹配多个：即为每个父级元素匹配第一个子元素。</p><p>:gt()</p><p>:header</p><p>选择所有标题元素</p><p>:lang()</p><p>选择指定语言的所有元素。</p><p>:last</p><p>:lt()</p><p>:not()</p><p>.not()方法可以让代码更易读。而使用 :not() 通常会构建出一个非常复杂的选择器。所以大多数情况下，推荐使用 .not()方法。</p><p>:odd</p><p>:root</p><p>在HTML中，文档的根元素，和$(“:root”)选择的元素一样，永远是&lt;html&gt;元素</p><p>:target</p><p>如果文档的URI包含一个格式化的标识符，或hash（哈希），然后:target选择器将匹配ID和标识符相匹配的元素。例如，给定的URI <a href="http://example.com/#foo%EF%BC%8C">http://example.com/#foo，</a> $( “p:target” )，将选择&lt;p id=”foo”&gt;元素。</p><h3 id="内容筛选"><a href="#内容筛选" class="headerlink" title="内容筛选"></a>内容筛选</h3><p>:contains()</p><p>选择所有包含指定文本的元素。</p><p>:empty</p><p>选择所有没有子元素的元素（包括文本节点）。</p><p><em>注意：W3C的建议p元素都至少有一个子节点，即使这个子节点是文字（见 <a href="http://www.w3.org/TR/html401/struct/text.html%EF%BC%83edef-P%EF%BC%89%E3%80%82%E5%8F%A6%E4%B8%80%E6%96%B9%E9%9D%A2%EF%BC%8C%E5%85%B6%E4%BB%96%E4%B8%80%E4%BA%9B%E5%85%83%E7%B4%A0%E5%A7%8B%E7%BB%88%E6%98%AF%E7%A9%BA%E7%9A%84%EF%BC%88%E5%8D%B3%E6%B2%A1%E6%9C%89%E5%AD%90%E8%8A%82%E7%82%B9%EF%BC%89%EF%BC%9A%E4%BE%8B%E5%A6%82input,img,br%E5%92%8Chr%E3%80%82">http://www.w3.org/TR/html401/struct/text.html＃edef-P）。另一方面，其他一些元素始终是空的（即没有子节点）：例如input,img,br和hr。</a></em></p><p>:has()</p><p>选择元素其中至少包含指定选择器匹配的一个/种元素。</p><p>:parent</p><p>选择所有含有子元素或者文本的父级元素。这个正好和 :empty相反。</p><h3 id="可见性筛选"><a href="#可见性筛选" class="headerlink" title="可见性筛选"></a>可见性筛选</h3><p>:hidden</p><p>:visible</p><p>元素可以被认为是隐藏的几个情况：</p><ul><li>他们的CSS display值是none。</li><li>他们是type=”hidden”的表单元素。</li><li>它们的宽度和高度都显式设置为0。</li><li>一个祖先元素是隐藏的，因此该元素是不会在页面上显示。</li></ul><p>元素visibility:hidden或opacity:0被认为是可见的，因为他们仍然占据布局空间。在动画，隐藏一个元素，该元素被认为是可见的直到动画结束。<br>不在文档中的元素是被认为是不可见的;如果当他们被插入到文档中，jQuery没有办法知道他们是否是可见的，因为元素可见性依赖于适用的样式。<br>jQuery 3稍微修改了:hidden (以及:visible)的含义。 这个版本开始，如果一个元素没有任何布局盒子，那么它将被视为:hidden。例如，br 元素和没有内容的内联元素将不能通过:hidden选择器被选择。</p><h3 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h3><p>:button</p><p>:checkbox</p><p>:checked</p><p>:disabled</p><p>:enabled</p><p>:focus</p><p>:file</p><p>:image</p><p>:input</p><p>:password</p><p>:radio</p><p>:reset</p><p>:selected</p><p>:submit</p><p>:text</p><h2 id="属性-CSS相关"><a href="#属性-CSS相关" class="headerlink" title="属性/CSS相关"></a>属性/CSS相关</h2><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>属性有.attr()，.prop()，.removeAttr()，.removeProp()，.val()这5个方法。</p><p>1 .attr()</p><p>获取匹配的元素集合中的第一个元素的属性的值  或 设置每一个匹配元素的一个或多个属性。</p><p><em>jQuery的很多方法都是默认获取的时候为第一个元素的值，而写入或设置的时候为修改所有匹配的元素</em></p><p>1.1 .attr( attributeName )</p><p>获取匹配的元素集合中的第一个元素的属性的值。</p><p>根据W3C的表单规范 ，checked属性是一个布尔属性，这意味着,如果这个属性（attribute）是目前存在，即使，该属性没有对应的值，或者被设置为空字符串值，或甚至是”false”，相应的属性（property）为true。这才是真正的所有布尔属性（attributes）。<br>checked特性（attribute）值不会因为复选框的状态而改变，而checked属性（property）会因为复选框的状态而改变。因此，跨浏览器兼容的方法来确定一个复选框是否被选中，是使用该属性（property）：</p><pre><code>if ( elem.checked )if ( $(elem).prop(&quot;checked&quot;) )if ( $(elem).is(&quot;:checked&quot;) )</code></pre><p><em>除了checked，对于其他的动态属性selected，disabled和value也应该使用prop()方法</em></p><p><em>在Internet Explorer 9之前的版本，使用.prop()设置DOM元素的属性进行赋值时，若所赋值的类型不是基本类型(number, string, 或 boolean)，而且也没有在DOM元素从文档中被移除之前使用 .removeProp() 方法。为了安全的在 DOM 对象上进行赋值而不用担心内存泄露问题，请使用 .data()方法。</em></p><p>1.2 .attr( attributeName, value )</p><p>value类型: String or Number or Null。如果为null， 指定的属性将被删除（就像.removeAttr()一样）</p><p>1.3 .attr( attributes )</p><p>attributes类型: PlainObject，一个要设置的属性-值集合对象</p><p>1.4 .attr( attributeName, function(Integer index, String attr) )</p><p>这个函数返回用来设置的值。this指向当前的元素。接收该元素在集合中索引位置（index）和 原来属性值（attr）作为参数。</p><p><em>注意 如果setter函数没有返回任何数据（例如：function(index, attr){})，属性的当前值返回值是undefined，作为一个getter行为。实际上，如果不进行任何更改的setter函数不返回的东西。</em></p><p><em>警告： 当设置样式名（“class”）属性时，必须使用引号！</em></p><p><em>注意: 试图改变 由document.createElement()创建的input 或 button 的type属性，在Internet Explorer 8或更老的版本中将抛出一个例外。</em></p><p>2 .prop()</p><p>参见attr().</p><p>禁用页面所有复选框</p><pre><code>&lt;script&gt;$(&quot;input[type=&#39;checkbox&#39;]&quot;).prop(&#123;  disabled: true&#125;);&lt;/script&gt;</code></pre><p>3 .removeAttr( attributeName )</p><p>attributeName类型: String，要移除的属性名,从1.7版本开始，它可以是一个空格分隔的属性列表。</p><p><em>注意: Internet Explorer 8， 9 ，和11中，使用.removeAttr()<br>删除一个内联onclick事件处理程序不会达到预期的效果，为了避免潜在的问题，使用 .prop()代替：</em></p><pre><code>$element.prop(&quot;onclick&quot;, null);console.log(&quot;onclick property: &quot;, $element[0].onclick);</code></pre><p>4 .removeProp( propertyName )</p><p>若尝试移除 DOM 元素或 window 对象上一些内建的 属性（ property ） ，浏览器可能会产生错误。如果真的那么做了，那么 jQuery 首先会将 属性（ property ） 设置成 undefined ，然后忽略任何浏览器产生的错误。一般来说,只需要移除自定义的 属性（ property ） ，而不是移除内建的（原生的）属性（ property ）。</p><p><em>注意: 不要使用此方法来删除原生的属性（ property ），比如checked, disabled, 或者selected。这将完全移除该属性，一旦移除，不能再次被添加到元素上。使用.prop()来设置这些属性设置为false代替。</em></p><p>5 .val()</p><p>5.1 .val()</p><p>当该集合中第一个元素是一个select-multiple（即select元素设置了multiple属性），.val()返回一个包含每个选择项值的数组。在jQuery 3.0中， 如果没有选项被选中，它将返回一个空数组；在jQuery 3.0之前的版本中， 它将返回null。</p><pre><code>function displayVals() &#123;  var singleValues = $(&quot;#single&quot;).val();  var multipleValues = $(&quot;#multiple&quot;).val() || []; //确保没有选项被选中时为[]  $(&quot;p&quot;).html(&quot;&lt;b&gt;Single:&lt;/b&gt; &quot; +              singleValues +              &quot; &lt;b&gt;Multiple:&lt;/b&gt; &quot; +              multipleValues.join(&quot;, &quot;));&#125;$(&quot;select&quot;).change(displayVals);displayVals();</code></pre><p>对于选择框（select），复选框（checkbox）和单选按钮（radio button），您也可以使用:selected 和 :checked选择器来获取值。</p><p><em>注意: 通过 .val() 方法从 &lt;textarea&gt; 元素中获取的值是不含有回车（\r）字符的。但是如果该值是通过 XHR 传递给服务器的，回车（\r）字符会被保留（或者是被浏览器添加的，但是在原始数据中并不包含回车（\r））。可以使用下面的 valHook 方法解决这个问题：</em></p><pre><code>$.valHooks.textarea = &#123;  get: function( elem ) &#123;    return elem.value.replace( /\r?\n/g, &quot;\r\n&quot; );  &#125;&#125;;</code></pre><p>5.2 .val( value )</p><p>value类型: String or Number or Array，一个文本字符串,一个数字，或一个以字符串形式的数组来设定每个匹配元素的值。</p><p>val() 允许你传递一个元素值的数组。当使用在包含像<input type="checkbox">, <input type="radio">, 和<select>中的 <option>元素的jQuery对象上的时候是非常有用的。在这种情况下，input和option的value与数组元素相匹配的情况下将被选中（checked）或选定（selected），而那些与数组元素值不匹配的value是未选中（unchecked）或未被选（unselected），这取决于元素类型。对于 <input type="radio"> 属于一个单选按钮组 ，还有<select>的其他元素都将被取消选中。</p><pre><code>&lt;select id=&quot;single&quot;&gt;  &lt;option&gt;Single&lt;/option&gt;  &lt;option&gt;Single2&lt;/option&gt;&lt;/select&gt; &lt;select id=&quot;multiple&quot; multiple=&quot;multiple&quot;&gt;  &lt;option selected=&quot;selected&quot;&gt;Multiple&lt;/option&gt;  &lt;option&gt;Multiple2&lt;/option&gt;  &lt;option selected=&quot;selected&quot;&gt;Multiple3&lt;/option&gt;&lt;/select&gt;&lt;br/&gt;&lt;input type=&quot;checkbox&quot; name=&quot;checkboxname&quot; value=&quot;check1&quot;/&gt; check1&lt;input type=&quot;checkbox&quot; name=&quot;checkboxname&quot; value=&quot;check2&quot;/&gt; check2&lt;input type=&quot;radio&quot;  name=&quot;r&quot; value=&quot;radio1&quot;/&gt; radio1&lt;input type=&quot;radio&quot;  name=&quot;r&quot; value=&quot;radio2&quot;/&gt; radio2&lt;script&gt;     $(&quot;#single&quot;).val(&quot;Single2&quot;);    $(&quot;#multiple&quot;).val([&quot;Multiple2&quot;, &quot;Multiple3&quot;]);    $(&quot;input&quot;).val([&quot;check1&quot;,&quot;check2&quot;, &quot;radio1&quot; ]); &lt;/script&gt;</code></pre><p>使用这个方法（或使用原生的value属性（property））设置值，不会触发change事件。为此，相关的事件处理程序不会被执行。如果要执行它们，你应该在设置值之后调用 .trigger( “change” )</p><p>5.3 .val( function( Integer index, String value )  )</p><pre><code>$(&#39;input:text.items&#39;).val(function( index, value ) &#123;  return value + &#39; &#39; + this.className;&#125;);</code></pre><h3 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h3><p>CSS主要有以下一些方法：</p><p>.addClass()</p><p>.css()</p><p>jQuery.cssHooks</p><p>jQuery.cssNumber</p><p>jQuery.escapeSelector()</p><p>.hasClass()</p><p>.removeClass()</p><p>.toggleClass()</p><p>1 .addClass()</p><p>1.1 .addClass( className )</p><p>1.2 .addClass( function(index, currentClass) )</p><p>在jQuery 1.12/2.2 版本之前， .addClass()方法操纵是选定元素的className特性（property），不是class属性（attribute）。一旦特性（property）改变，浏览器就会更新相应地的属性（attribute）。此行为的一个言外之意是，这种方法只适用于HTML DOM语义的文档（例如，不是纯XML文档）。</p><p>在jQuery1.12/2.2中，改变了这种行为以改善对XML文档，包括SVG的支持。从这个版本开始，class 属性（attribute）被替换（愚人码头注：这个版本开始，.addClass()方法操作的是class 属性（attribute），而不是className特性（property））。因此，.addClass()可以在XML或SVG文档中使用。</p><p>对所有匹配的元素可以一次添加多个用空格隔开的样式类名。</p><p>2 .hasClass( className )</p><p>在 jQuery 1.12/2.2 中, 这个方法支持 XML 文档, 包括 SVG。</p><p>3 .removeClass()</p><p>如果一个样式类名作为一个参数,只有这样式类会被从匹配的元素集合中删除 。 如果没有样式名作为参数，那么所有的样式类将被移除。</p><p>4 .toggleClass()</p><p>4.1 .toggleClass( className )</p><p>4.2 .toggleClass( className, state )</p><p>state类型: Boolean,一个布尔值（不止是真值/假值），用于判断样式是否应该被添加或移除。</p><p>4.3 .toggleClass( function( Integer index, String className, Boolean state ) [, state ] )</p><p>5 .css()</p><p>.css( propertyName )</p><p>.css( propertyNames )</p><p>.css( propertyName, value )</p><p>.css( propertyName, function(index, value) )</p><p>.css( properties )</p><p>5.1 从jQuery 1.9开始, 传递一个CSS的样式属性的数组给.css()将返回 属性 - 值 配对的对象。例如，要获取元素4个边距宽度值border-width，你可以使用$( elem ).css([ “borderTopWidth”, “borderRightWidth”, “borderBottomWidth”, “borderLeftWidth” ]).</p><p>5.2 当一个数只被作为值（value）的时候， jQuery会将其转换为一个字符串，并添在字符串的结尾处添加px(愚人码头注：.css(“width”,50})，.css(“width”,”50”})，.css(“width”,’50px’})这3条语句是等价的，具体可以查看 <a href="http://jsfiddle.net/feiwen8772/b78mgmdd/)%E3%80%82">http://jsfiddle.net/feiwen8772/b78mgmdd/)。</a> 如果属性值需要非px的其他单位，请使用添加了合适单位的字符串（愚人码头注：例如，’12em’）</p><p>5.3 样式属性的值设置为空字符串 — 例如，$(‘#mydiv’).css(‘color’, ‘’) — 那么会从元素上移除该属性（若该属性存在的话）， 该属性之前可能是通过 jQuery 的 .css() 方法设置的 HTML style 属性，也有可能是通过直接对 style 属性进行 DOM 操作而被设置的。 因此，该属性的元素样式将恢复到之前应用的任何值。</p><p><em>注意: .css()忽略了!important声明！ 因此，语句$( “p” ).css( “color”, “red !important” )，不会将页面中所有段落颜色转变为红色。 强烈建议使用类（class）来代替; 否则请使用jQuery插件。</em></p><p>5.4 从jQuery1.6开始，.css()接受类似于.animate()的相对值。相对值时以+= 或者 -=开头的字符串，表示递增或递减当前的值。 例如，如果一个元素的左边填充（padding-left）是10px的，.css( “padding-left”, “+=15” )将返回总的左填充（padding-left ）为55px。</p><p>5.5 <em>注意: 如果设置函数没有返回任何东西(例如. function(index, style){})，或者如果返回undefined，当前的值不会改变。只有当某些条件得到满足，选择性的设定值的时后是有用的。</em></p><p>6 jQuery.cssHooks</p><p>直接向 jQuery 中添加钩子，用于覆盖设置或获取特定 CSS 属性时的方法，目的是为了标准化 CSS 属性名或创建自定义属性。</p><pre><code>(function($) &#123;  if ( !$.cssHooks ) &#123;    throw(&quot;jQuery 1.4.3+ is needed for this plugin to work&quot;);    return;  &#125;   function styleSupport( prop ) &#123;    var vendorProp, supportedProp,        capProp = prop.charAt(0).toUpperCase() + prop.slice(1),        prefixes = [ &quot;Moz&quot;, &quot;Webkit&quot;, &quot;O&quot;, &quot;ms&quot; ],        div = document.createElement( &quot;div&quot; );     if ( prop in div.style ) &#123;      supportedProp = prop;    &#125; else &#123;      for ( var i = 0; i &lt; prefixes.length; i++ ) &#123;        vendorProp = prefixes[i] + capProp;        if ( vendorProp in div.style ) &#123;          supportedProp = vendorProp;          break;        &#125;      &#125;    &#125;     div = null;    $.support[ prop ] = supportedProp    return supportedProp;  &#125;   var borderRadius = styleSupport( &quot;borderRadius&quot; );   // Set cssHooks only for browsers that  // support a vendor-prefixed border radius  if ( borderRadius &amp;&amp; borderRadius !== &quot;borderRadius&quot; ) &#123;    $.cssHooks.borderRadius = &#123;      get: function( elem, computed, extra ) &#123;        return $.css( elem, borderRadius );      &#125;,      set: function( elem, value) &#123;        elem.style[ borderRadius ] = value;      &#125;    &#125;;  &#125;&#125;)(jQuery);</code></pre><p>7 jQuery.cssNumber</p><p>一个对象，这个包含所有可以不使用单位的CSS属性。.css() 方法使用这个对象来确定是否可能附加px到无单位的值。</p><p>jQuery.cssNumber.someCSSProp = true;</p><p>默认情况下，这个对象包含以下属性：</p><ul><li>zIndex</li><li>fontWeight</li><li>opacity</li><li>zoom</li><li>lineHeight</li><li>widows (jQuery 1.6开始添加)</li><li>orphans (jQuery 1.6开始添加)</li><li>fillOpacity (jQuery 1.6.2开始添加)</li><li>columnCount (jQuery 1.9开始添加)</li><li>order (jQuery 1.10.2开始添加)</li><li>flexGrow (jQuery 1.11.1开始添加)</li><li>flexShrink (jQuery 1.11.1开始添加)</li></ul><p>8 jQuery.escapeSelector()</p><p>转义CSS选择器中任何具有特殊的含义字符。</p><p>添加版本: 3.0</p><p>此方法对于一个CSS类名或一个ID包含的字符在CSS中具有特殊含义的情况下非常有用，如点或分号。</p><p>该方法本质上是<a href="https://drafts.csswg.org/cssom/#the-css.escape()-method">CSS工作组CSS.escape()方法</a>的shim（垫片）。 主要的区别在于，$.escapeSelector() 可以可靠地使用在所有jQuery支持的浏览器中。</p><p>转义包含hash的ID.</p><pre><code>$.escapeSelector( &quot;#target&quot; ); // &quot;\#target&quot;</code></pre><p>选择在一个div内，所有类名为.box的元素。</p><pre><code>$( &quot;div&quot; ).find( &quot;.&quot; + $.escapeSelector( &quot;.box&quot; ) );</code></pre><h3 id="尺寸"><a href="#尺寸" class="headerlink" title="尺寸"></a>尺寸</h3><p>主要有.height()，.width()，.innerHeight()，.innerWidth()，.outerHeight()，.outerWidth()</p><p>1 .height()</p><p>1.1 .height()</p><p>.css(‘height’) 和 .height()之间的区别是后者返回一个没有单位的数值（例如，400），前者是返回带有完整单位的字符串（例如，400px）。当一个元素的高度需要数学计算的时候推荐使用.height() 方法 。</p><p><em>注意.height()总是返回容器的高度,不管CSS box-sizing属性值。截至jQuery 1.8，这可能需要检索的CSS的宽度加加上box-sizing的属性，然后当元素有 box-sizing: border-box时候，减去个元素上任何潜在border和padding值。为了避免这种问题，使用.css( “height” )而非.height()。</em></p><p><em>尺寸相关的API返回的数字， 包括的 .height()， 在某些情况下可能带有小数。你的代码不应该假定它是一个整数。  另外，当页面被用户缩放时，返回的尺寸可能是不正确的;浏览器没有一个公开的API来检测这种情况。</em></p><p><em>当元素或其父元素被隐藏时，.height()得到的值不能保证准确。要得到准确的值，你应该确保该元素在使用.height()前可见。jQuery将尝试临时显示，然后再隐藏元素来测量元素尺寸，但这是不可靠的，（即使得到准确的值）也会显著影响页面的性能。这总临时显示然后再隐藏的测量功能，可能在jQuery未来的版本中删除。</em></p><p>1.2 .height( value )</p><p>1.3 .height( function(index, height) )</p><p>当调用.height(value)方法的时候，这个“value”参数可以是一个字符串（数字加单位）或者是一个数字。如果这个“value”参数只提供一个数字，jQuery会自动加上单位px。如果只提供一个字符串，任何有效的CSS尺寸都可以为高度赋值（就像100px, 50%, 或者 auto）。注意在现代浏览器中，CSS高度属性不包含padding, border, 或者 margin。</p><p>如果没有给定明确的单位（像’em’ 或者 ‘%’），那么默认情况下”px”会被直接添加上去（也理解为”px”是默认单位）。</p><p><em>注意.height(‘value’)设置的容器宽度是根据CSS box-sizing属性来定的, 将这个属性值改成border-box，将造成这个函数改变这个容器的outerHeight，而不是原来的内容高度。</em></p><p>以上的注意事项，尺寸的其他方法同理。</p><p>2 .width()</p><p>3 .innerHeight()</p><p>用于获得匹配集合中第一个元素的当前计算的内部高度（包括padding，但不包括border），或 设置每一个匹配元素的内部高度。</p><p>这个方法返回元素的高度，包括顶部和底部的padding，单位是像素。</p><p>这个方法不适用于window 和 document对象，对于这些对象可以使用.height()代替。</p><p>4 .innerWidth()</p><p>5 .outerHeight()</p><p>获取匹配元素集合中第一个元素的当前计算宽度值,包括padding，border和选择性的margin。返回一个整数（不包含“px”）表示的值 ，或如果在一个空集合上调用该方法，则会返回 null。</p><p>.outerHeight( [includeMargin ] )</p><p>includeMargin (默认: false),类型： Boolean,一个布尔值，表明是否在计算时包含元素的margin值。</p><p>6 .outerWidth()</p><h3 id="位置"><a href="#位置" class="headerlink" title="位置"></a>位置</h3><p>位置主要有.offset(),.offsetParent(),.position(),.scrollLeft(),.scrollTop()</p><p>1 .offset()</p><p>1.1 .offset()</p><p>在匹配的元素集合中，获取的第一个元素的当前坐标，坐标相对于文档。</p><p>.offset()返回一个包含top 和 left属性的对象 。</p><p><em>注意：jQuery不支持获取隐藏元素的偏移坐标。同样的，也无法取得隐藏元素的 border, margin, 或 padding 信息。</em></p><p><em>若元素的属性设置的是 visibility:hidden，那么我们依然可以取得它的坐标。但是若设置的属性是 display:none，由于在绘制 DOM 树时根本就不绘制该元素，所以它的位置属性值是 undefined。</em></p><p>1.2 .offset( coordinates )</p><p>coordinates类型: PlainObject,一个包含top 和 left属性的对象，用整数指明元素的新顶部和左边坐标。</p><p>1.3 .offset( function(index, coords) )</p><p>返回用于设置坐标的一个函数。接收元素在匹配的元素集合中的索引位置作为第一个参数，和当前坐标作为第二个参数。这个函数应该返回一个包含top 和 left属性的对象。</p><p>.offset()方法允许我们重新设置元素的位置，这个元素的位置是相对于document对象的。如果对象原先的.position()样式属性是static的话，会被改成relative来实现重定位。</p><p>2 .offsetParent()</p><p>取得离指定元素最近的含有定位信息的祖先元素。含有定位信息的元素指的是，CSS 的 position 属性是 relative, absolute, 或 fixed 的元素</p><p>3 .position()<br>获取匹配元素中第一个元素的当前坐标，相对于offset parent的坐标。( 译者注：offset parent指离该元素最近的而且被定位过的祖先元素 )</p><p>.position()方法可以取得元素相对于父元素的偏移位置。与.offset()不同, .offset()是获得该元素相对于documet的当前坐标,当把一个新元素放在同一个容器里面另一个元素附近时，用.position()更好用。</p><p>.position()返回一个包含 top 和 left属性的对象.</p><p>4 .scrollLeft()</p><p>4.1 .scrollLeft()</p><p>获取匹配的元素集合中第一个元素的当前水平滚动条的位置。</p><p><em>注意:.scrollLeft(), 当直接调用或使用.animate()做动画，当元素被应用了隐藏，将不做任何改变。</em></p><p>4.2 .scrollLeft( value )</p><p>5 .scrollTop()</p><h2 id="数据data"><a href="#数据data" class="headerlink" title="数据data"></a>数据data</h2><p>有三个底层的方法jQuery.data()，jQuery.hasData()，jQuery.removeData()和两个元素上的方法.data()，.removeData()，一般不要使用底层的方法，而是使用元素上的方法。</p><p>1 jQuery.hasData()</p><p>jQuery.hasData( element )</p><p>确定任何一个元素是否有与之相关的jQuery数据。</p><p>jQuery.hasData()方法提供了一种方法来确定一个元素是否有任何数据，这些数据是使用jQuery.data()设置的。如果一个元素没有关联的data对象，该方法返回false ;否则返回true 。</p><p>jQuery.hasData(element) 的主要优点是它并不创建 data 对象。如果元素上没有 data 对象，那么该方法也不会与元素上的 data 对象关联。相反，jQuery.data(element)总是向调用者返回一个 data 对象，即使该元素上不含有 data 对象，它也会创建一个。</p><p><em>请注意，jQuery的事件系统是使用jQuery数据 存储事件处理程序的。 因此，使用.on(), .bind(), .live(), .delegate()，或一个速记事件方法 绑定事件到一个元素上的时候，也会在那个元素上关联一个 data 对象。</em></p><p>2 .data()</p><p>在匹配元素上存储任意相关数据 或 返回匹配的元素集合中的第一个元素的给定名称的数据存储的值。</p><p>2.1 .data( key, value )</p><p>key类型: String，一个字符串，用户存储数据的名称。（译者注：存储的数据名）</p><p>value类型: Anything，新的数据值；它可以是任意的Javascript数据类型，除了undefined。</p><p>2.2 .data( obj )</p><p>obj类型: Object，一个用于更新数据的 键/值对</p><p>.data() 方法允许我们在DOM元素上绑定任意类型的数据,避免了循环引用的内存泄漏风险。我们可以在一个元素上设置不同的值，并获取这些值：</p><p>由于浏览器用插件和外部代码相互作用,.data()方法不能在<object>（除非是Flash插件），<applet> 或 <embed>元素上使用。</p><p><em>注意这个方法目前并不提供在XML文档上跨平台设置数据，作为Internet Explorer不允许通过自定义属性附加数据。</em></p><p><em>undefined不是认可的数据值。比如这样调用.data( “name”, undefined ) ，将返回 “name”对应的数据， 也就是等同于调用.data( “name” )。</em></p><p>2.3 .data( key )</p><p>返回匹配的元素集合中的第一个元素的给定名称的数据存储的值。 通过.data(name, value)或HTML5 data-* 属性设置</p><p>2.4 .data()</p><p>从jQuery 1.4.3起， HTML 5 data- 属性 将自动被引用到jQuery的数据对象中。嵌入式破折号处理属性（ attributes）的方式在 jQuery 1.6 中已经改变，以使之符合W3C HTML5 规范.</p><p>如果没有传递key参数的数据存储， jQuery将在元素的属性中搜索， 将驼峰式字符串转化为中横线字符串，然后在结果前面加上data-。 所以，该字符串lastValue将被转换为data-last-value。</p><p>每次尝试将字符串转换为一个JavaScript值（包括布尔值（booleans），数字（numbers），对象（objects），数组（arrays）和空（null））。如果这样做不会改变值的表示，那么该值将转换为一个数字（number）。例如，“1E02”和“100.000”是等同于数字（数字值100），但将转换它们会改变他们的表示，所以他们被保留为字符串。字符串值“100”被转换为数字100。</p><p>如果数据(data)属性是一个对象（以“{”开始）或数组（以’[‘开始），可以用jQuery.parseJSON 将其解析成字符串；它必须遵循<a href="https://en.wikipedia.org/wiki/JSON#Data_types.2C_syntax_and_example">有效的JSON的语法</a>，包括带双引号的属性名称。如果该值不能解析为一个JavaScript值，它将被保留为字符串。</p><p>如果不想将取出的属性值直接当作字符串的话，请使用attr()方法。</p><p>data-属性是在第一次使用这个数据属性后不再存取或改变（所有的数据值都在jQuery内部存储）。</p><p>调用 .data() 时如果不带参数，将会以 JavaScript 对象的形式获取所有数据。这个对象可以安全的存放在变量中，因为一旦这个新对象被提取出来，之后对元素进行的 .data(obj)操作，将不会再影响这个对象。另外，直接操作这个对象会比每次调用 .data() 来设置或获取值要快一些：</p><p>3 .removeData( [name ] )</p><p>在元素上移除绑定的数据</p><p>3.1 .removeData( [name ] )</p><p>name类型: String,要移除的存储数据名.</p><p>3.2 .removeData( [list ] )</p><p>list类型: Array or String,一个数组或空间分隔的字符串命名要删除的数据块。</p><p>.removeData()方法允许我们移除用.data()绑定的值。当带name参数调用的时候，.removeData()将删除那个特有的值，当不带任何参数的时候，.removeData()将移除所有的值。</p><p>需要注意的是.removeData()仅会删除来自jQuery内部.data()缓存中的数据， 并且元素上任何相应的data-属性不会被删除。后调用data()，会重新检索data-的属性的值。 为了防止这种情况，可以在.removeData()旁边使用.removeAttr()来移除data-属性。jQuery 1.4.3以前,data()没有使用data-属性，所以不存在这类问题。</p><p>从jQuery 1.7开始, 当键数组或一个空间分隔键的字符串作为参数，调用.removeData()时，将删除在该数组每一项元素或字符串的键值。</p><p>4 jQuery.data()</p><p>jQuery.data( element, key, value )</p><p>jQuery.data( element, key )</p><p>jQuery.data( element )</p><p>注意：这是一个底层的方法，你应该用.data()代替。</p><p>jQuery.data() 方法允许我们在DOM元素上附加任意类型的数据,避免了循环引用的内存泄漏风险。如果 DOM 元素是通过 jQuery 方法删除的或者当用户离开页面时，jQuery 同时也会移除添加在上面的数据。我们可以在一个元素上设置不同的值，并获取这些值：</p><p><em>.unload()方法只是作为.on( “unload”, handler )的一个速记写法，移除该事件可以使用.off( “unload” )。</em></p><p>关于 HTML5 data-* 属性: 这个低层次的方法不检索的data-*属性， 除非.data()方法已经返回了它们。</p><p>调用jQuery.data(element)时将获取一个JavaScript对象，它包含了元素上所有存储的数据。jQuery内部自身使用这个方法来绑定数据，如事件处理器，所以不要以为这对象只包含你的代码中储存的数据。</p><p>其他和元素上的data方法一样</p><p>5 .removeData()</p><p>和元素上的removeDate()同理</p><h2 id="DOM操作"><a href="#DOM操作" class="headerlink" title="DOM操作"></a>DOM操作</h2><h3 id="拷贝"><a href="#拷贝" class="headerlink" title="拷贝"></a>拷贝</h3><p>.clone( [withDataAndEvents ] )</p><p>withDataAndEvents (默认: false)<br>类型: Boolean，<br>一个Boolean值，表示是否会复制元素上的事件处理函数。从jQuery 1.4开始，元素数据也会被复制。</p><p>.clone( [withDataAndEvents ] [, deepWithDataAndEvents ] )</p><p>withDataAndEvents (默认: false)<br>类型: Boolean，<br>一个Boolean值，表示是否会复制元素上的事件处理函数。 默认值是 false。*对于1.5.0的默认值被不适当地设置成了true，将在1.5.1以上改回false 。</p><p>deepWithDataAndEvents (默认: value of withDataAndEvents)<br>类型: Boolean，<br>一个布尔值，指示是否对事件处理程序和克隆的元素的所有子元素的数据应该被复制。默认情况下它的值相匹配的第一个参数的值（ 默认值是 false）</p><p><em>注意:出于性能方面的考虑，表单元素动态的状态（例如，用户将数据输入到 textarea中的值，或者用户在select中已经选中某一项）不会被复制到克隆元素。当克隆input元素时候，该元素的动态状态（例如，用户数据输入到文本输入框(愚人码头注： <input type="text">) 和用户选中一个复选框）将被保留在克隆元素中。</em></p><p>像我们讨论.append()一样，通常我们将页面上一个元素插入到DOM里另立个地方，它会被从老地方移走（愚人码头注：不是复制）</p><p>但是我们如果需要的是复制而不是移除，我们可以像下面这样写代码：</p><pre><code>$(&#39;.hello&#39;).clone().appendTo(&#39;.goodbye&#39;);</code></pre><p>然而，元素数据（data）内对象和数组不会被复制，将继续被克隆元素和原始元素共享。深复制的所有数据，需要手动复制每一个：</p><pre><code>// Original element with attached datavar $elem = $( &quot;#elem&quot; ).data( &quot;arr&quot;, [ 1 ] ),    $clone = $elem.clone( true )      // Deep copy to prevent data sharing      .data( &quot;arr&quot;, $.extend( [], $elem.data( &quot;arr&quot; ) ) );</code></pre><p>在jQuery 1.5，withDataAndEvents可以选择性增强deepWithDataAndEvents复制元素的事件和数据的克隆的所有子元素。</p><p><em>注意: 使用.clone()可能产生id属性重复的元素的副作用，id应该是唯一的。在可能的情况下，建议，应避免克隆有此属性或标识符的元素，使用类（class）属性代替。</em></p><p>当使用 .clone()克隆一组元素，并且这些克隆生成的元素尚未被添加到 DOM 中，那么当这些元素被插入到 DOM 中时，不能保证是按它们的原顺序被插入的。但是，可以像下面例子中提到的那样，保证顺序的正确性：</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;  &lt;style&gt;  #orig, #copy, #copy-correct &#123;    float: left;    width: 20%;  &#125;&lt;/style&gt;  &lt;script src=&quot;http://code.jquery.com/jquery-latest.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;orig&quot;&gt;    &lt;div class=&quot;elem&quot;&gt;&lt;a&gt;1&lt;/a&gt;&lt;/div&gt;    &lt;div class=&quot;elem&quot;&gt;&lt;a&gt;2&lt;/a&gt;&lt;/div&gt;    &lt;div class=&quot;elem&quot;&gt;&lt;a&gt;3&lt;/a&gt;&lt;/div&gt;    &lt;div class=&quot;elem&quot;&gt;&lt;a&gt;4&lt;/a&gt;&lt;/div&gt;    &lt;div class=&quot;elem&quot;&gt;&lt;a&gt;5&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;div id=&quot;copy&quot;&gt;&lt;/div&gt;&lt;div id=&quot;copy-correct&quot;&gt;&lt;/div&gt; &lt;script&gt;// sort order is not guaranteed here and may vary with browser$(&#39;#copy&#39;).append($(&#39;#orig .elem&#39;)          .clone()          .children(&#39;a&#39;)          .prepend(&#39;foo - &#39;)          .parent()          .clone()); // correct way to approach where order is maintained$(&#39;#copy-correct&#39;)          .append($(&#39;#orig .elem&#39;)          .clone()          .children(&#39;a&#39;)          .prepend(&#39;bar - &#39;)          .end());&lt;/script&gt; &lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="DOM-插入-包裹"><a href="#DOM-插入-包裹" class="headerlink" title="DOM 插入, 包裹"></a>DOM 插入, 包裹</h3><p>有三个方法：.wrap()，.wrapAll()，.wrapInner()</p><p>1 .wrap()</p><p> 在集合中匹配的每个元素周围包裹一个HTML结构。</p><p>.wrap( wrappingElement )</p><p>wrappingElement<br>类型: Selector 或 htmlString 或 Element 或 jQuery，<br>一个选择器，元素，HTML字符串，或jQuery对象指定的html结构环绕包裹的匹配元素。 当你传递一个包含多个元素一个jQuery集合， 或选择器的匹配多个元素时， 第一元素将被使用。</p><p>.wrap( function )<br>function<br>类型: Function( Integer index ) =&gt; String 或 jQuery，<br>一个回调函数，返回用于包裹匹配元素的 HTML 内容或 jQuery 对象。接受的 index 参数表示匹配元素在集合中的索引位置。该函数内的 this 指向集合中的当前元素。</p><pre><code>$(&#39;.inner&#39;).wrap(function() &#123;  return &#39;&lt;div class=&quot;&#39; + $(this).text() + &#39;&quot; /&gt;&#39;;&#125;);&lt;div class=&quot;container&quot;&gt;  &lt;div class=&quot;Hello&quot;&gt;    &lt;div class=&quot;inner&quot;&gt;Hello&lt;/div&gt;  &lt;/div&gt;  &lt;div class=&quot;Goodbye&quot;&gt;    &lt;div class=&quot;inner&quot;&gt;Goodbye&lt;/div&gt;  &lt;/div&gt;&lt;/div&gt;</code></pre><p>使用一个嵌套深度为两层 div 的 jQuery 对象来包裹所有的段落。注意，这并不会移动用于包裹的对象，只是将克隆后的对象用于包裹。</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;  &lt;style&gt;   div &#123; border: 2px solid blue; margin:2px; padding:2px; &#125;  .doublediv &#123; border-color:red; &#125;  p &#123; background:yellow; margin:4px; font-size:14px; &#125;  &lt;/style&gt;  &lt;script src=&quot;http://code.jquery.com/jquery-latest.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;  &lt;p&gt;Hello&lt;/p&gt;  &lt;p&gt;cruel&lt;/p&gt;  &lt;p&gt;World&lt;/p&gt;  &lt;div class=&quot;doublediv&quot;&gt;&lt;div&gt;&lt;/div&gt;&lt;/div&gt;&lt;script&gt;$(&quot;p&quot;).wrap($(&quot;.doublediv&quot;));&lt;/script&gt; &lt;/body&gt;&lt;/html&gt;</code></pre><p>2 .wrapAll()</p><p>.wrapAll( wrappingElement )</p><p>wrappingElement</p><p>类型: Selector 或 htmlString 或 Element 或 jQuery</p><p>一个选择器，元素，HTML字符串，或jQuery对象指定的html结构环绕包裹的匹配元素。</p><p>.wrapAll( function )</p><p>function</p><p>类型: Function() =&gt; String 或 jQuery，</p><p>一个回调函数，返回的HTML内容或jQuery对象将包裹所有匹配的元素。函数内的this指向集合中的第一个元素。在jQuery 3.0 之前，回调函数错误地调用集合中的每一个元素并且接收所述集合中这个元素的索引位置作为参数。</p><p>.wrapAll()函数可以接受任何字符串或对象，可以传递给$()工厂函数来指定一个DOM结构。这种结构可以嵌套多层，但是最内层只能有一个元素。所有匹配元素将会被当作是一个整体，在这个整体的外部用指定的 HTML 结构进行包裹。</p><p>为 span 标签包裹一个对象树。注意，任何 span 之间的元素都不会被包裹，例如例子中使用的 <strong> (红色文本)。即使是 span 之间的空格也不会被包裹。可以查看原始 HTML 的源代码。</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;  &lt;style&gt;   div &#123; border:2px blue solid; margin:2px; padding:2px; &#125;  p &#123; background:yellow; margin:2px; padding:2px; &#125;  strong &#123; color:red; &#125;  &lt;/style&gt;  &lt;script src=&quot;http://code.jquery.com/jquery-latest.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;  &lt;span&gt;Span Text&lt;/span&gt;  &lt;strong&gt;What about me?&lt;/strong&gt;  &lt;span&gt;Another One&lt;/span&gt;&lt;script&gt;$(&quot;span&quot;).wrapAll(&quot;&lt;div&gt;&lt;div&gt;&lt;p&gt;&lt;em&gt;&lt;b&gt;&lt;/b&gt;&lt;/em&gt;&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&quot;);&lt;/script&gt; &lt;/body&gt;&lt;/html&gt;</code></pre><p>3 .wrapInner()</p><p>注意: 当通过一个选择器字符串传递给.wrapInner() 函数，其参数应该是格式正确的 HTML，并且 HTML 标签应该是被正确关闭的。下面是一些正确的例子：</p><pre><code>$(elem).wrapInner(&quot;&lt;div class=&#39;test&#39; /&gt;&quot;);$(elem).wrapInner(&quot;&lt;div class=&#39;test&#39;&gt;&lt;/div&gt;&quot;);$(elem).wrapInner(&quot;&lt;div class=\&quot;test\&quot;&gt;&lt;/div&gt;&quot;);</code></pre><h3 id="DOM-插入-内部插入"><a href="#DOM-插入-内部插入" class="headerlink" title="DOM 插入, 内部插入"></a>DOM 插入, 内部插入</h3><p>有.append()，.appendTo()，.prepend()，.prependTo()，.html()，.text()</p><p>1 .append()</p><p>.append( content [, content ] )</p><p>content<br>类型: String, Element, jQuery，<br>DOM 元素，文本节点，元素和文本节点的数组，HTML字符串，或者jQuery对象，用来插在每个匹配元素里面的末尾。</p><p>content<br>类型: String, Element, Array, jQuery，<br>一个或多个DOM元素，文本节点，元素和文本节点的数组，HTML字符串，或jQuery对象插入到每个匹配元素的末尾。</p><p>.append( function(index, html) )</p><p>function(index, html)<br>类型: Function()，<br>一个返回HTML字符串，DOM元素（或多个），文本节点（或多个），jQuery对象的函数，该字符串用来插入到匹配元素的末尾。接收index 参数表示元素在匹配集合中的索引位置和html 参数表示元素上原来的 HTML 内容。在函数中this指向元素集合中的当前元素。</p><p>如果一个被选中的元素被插入到另外一个地方，这是移动而不是复制。</p><p>和其他添加内容的方法类似， 例如.prepend() 和 .before(), .append() 还支持传递输入多个参数。支持的输入包括DOM元素，jQuery对象，HTML字符串，DOM元素的数组。</p><p>.append() 可以接受任何数量的额外的参数</p><p><em>设计上，任何jQuery的构造或方法，都接受一个HTML字符串（作为参数） - jQuery(),.append(), .after()等 -可以潜在地执行代码。这可能会出现注入script标签或使用HTML属性执行的代码（例如，<img onload="">）。不要使用这些方法来插入来自不受信任来源的内容，如网址查询参数，Cookie或表单输入获得的字符串。这样做可能会引起跨站点脚本（XSS）漏洞。将内容添加到文档之前删除或避免用户任何输入内容。</em></p><p><em>jQuery没有正式的支持SVG。在SVG文档上使用jQuery方法，除非该方法有明确的说明，否则可能会导致意外的行为。例如jQuery 3.0中支持SVG的方法有addClass 和 removeClass。</em></p><p>2 .appendTo()</p><p>然而，如果有多个目标元素，插入元素的克隆副本被创建到每个目标元素，而不是只插入到最后一个目标元素，并且新的集合（原始元素加克隆元素）被返回。</p><p>在jQuery 1.9以前，追加到单个元素的情况下没有创建一个新的集合，而是返回原来的集合，当被用与数目不详的元素时，使得它难以可靠地使用.end()方法。</p><p>3 .prepend()</p><p>4 .prependTo()</p><p>5 .html()</p><p>5.1 .html()</p><p>这种方法使用浏览器的innerHTML 属性。有些浏览器返回的结果可能不是原始文档的 HTML 源代码。例如，如果属性值只包含字母数字字符，Internet Explorer有时丢弃包裹属性值的引号。</p><p>5.2 .html( htmlString )</p><p>5.3 .html( function(index, oldhtml) )</p><p>这个 .html() 方法对 XML 文档无效.</p><p>我们可以使用 .html() 来设置元素的内容，这些元素中的任何内容会完全被新的内容取代。此外，用新的内容替换这些元素前，jQuery从子元素删除其他结构，如数据和事件处理程序。（愚人码头注：这样可以防止内存溢出。）</p><p>这种方法使用浏览器的innerHTML 属性。有些浏览器可能不完全复制所提供的HTML源代码生成DOM。例如，Internet Explorer的版本8之前转换所有链接的href属性为绝对URL路径，和Internet Explorer第9版之前，不增加一个单独的兼容层的情况下，将无法正确处理HTML5元素。</p><p><em>要设置一个&lt;script&gt;元素的内容， 其不包含HTML， 使用的 .text()方法，而不是.html()。所以在定义在script标签中的模板应该用.html()方法获取</em></p><p><em>注意:在Internet Explorer中，包括第9版，  设置HTML元素的文本内容可能会破坏其子节点的文本节点，结果导致子节点的文本节点从文档中被删除。如果你想保留这些 DOM 元素的引用，需要他们将保持不变，请使用.empty().html(string)来代替.html(string)，以便从文档中删除元素之前的元素被分配到新的字符串</em></p><p>6 .text()</p><p>6.1 .text()</p><p>和 .html() 方法不同， .text() 在XML 和 HTML 文档中都能使用。.text() 方法返回一个字符串，包含所有匹配元素的合并文本。  （由于在不同的浏览器中的HTML解析器的变化，返回的文本中换行和其他空白可能会有所不同。）</p><p>.text() 方法不能使用在 input 元素或scripts元素上。 input 或 textarea 需要使用 .val() 方法获取或设置文本值。得到scripts元素的值，使用.html()方法</p><p>从 jQuery 1.4开始， .text()方法返回文本内容和作为元素节点的CDATA 节点。</p><p>6.2 .text( text )</p><p>text<br>类型: String or Number or Boolean,<br>用于设置匹配元素内容的文本。当提供的是一个数值或布尔值得时候，那么将被转换成一个字符串表现形式，提供给这个方法。</p><p>6.3 .text( function(index, text) )</p><p>function(index, text)<br>类型: Function(),<br>用来返回设置文本内容的一个函数。接收元素的索引位置和文本值作为参数。</p><h3 id="DOM-插入-外部插入"><a href="#DOM-插入-外部插入" class="headerlink" title="DOM 插入, 外部插入"></a>DOM 插入, 外部插入</h3><p>有.after()，.before()，.insertAfter()，.insertBefore()</p><p>1 .after()</p><p>1.1 .after( content [, content ] )</p><p>1.2 .after( function )</p><p>function类型: Function( Integer index ) =&gt; htmlString or Element or jQuery</p><p>一个返回HTML字符串，DOM元素（或多个），文本节点（或多个），或jQuery对象的函数，返回的内容用来插入到集合中每个匹配元素的后面（愚人码头注：外部插入）。 接收元素集合中该元素的索引位置作为一个参数（index 参数）。在函数中this指向元素集合中的当前元素。</p><p>1.3 .after( function-html ),1.10版本添加</p><p>function类型: Function( Integer index, String html ) =&gt; htmlString or Element or jQuery<br>一个返回HTML字符串，DOM元素，jQuery对象的函数，返回的内容用来插入到集合中每个匹配元素的后面（愚人码头注：外部插入）。接收元素集合中该元素的索引位置（愚人码头注：index 参数）和元素的原来HTML值（愚人码头注：html 参数）作为参数。在函数中this指向元素集合中的当前元素。</p><p><em>在此之前的jQuery1.9， 如果该集合中的第一个节点没有在文档中， .after()将尝试添加 或 在当前的jQuery集合改变节点，在这种情况下返回一个新的jQuery集合，而不是原来的集合。该方法可能会或可能不会返回一个新的结果，这取决于它的参数个数或参数的连贯性！ 从jQuery1.9开始，.after(), .before(), 和 .replaceWith()总是返回原始未修改的集合。 试图在一个没有父级元素的节点上使用这些方法是没有效果的，也就是说，集合和它包含的节点都不会改变。</em></p><p>2 .before()</p><p>3 .insertAfter()</p><p>4 .insertBefore()</p><h3 id="DOM-移除"><a href="#DOM-移除" class="headerlink" title="DOM 移除"></a>DOM 移除</h3><p>有.detach()，.empty()，.remove()，.unwrap()</p><p>1 .detach()</p><p>.detach( [selector ] )，从DOM中去掉所有匹配的元素。</p><p>.detach() 方法和.remove()一样, 除了 .detach()保存所有jQuery数据和被移走的元素相关联。当需要移走一个元素，不久又将该元素插入DOM时，这种方法很有用。</p><p>2 .empty()</p><p>从DOM中移除集合中匹配元素的所有子节点。</p><p>为了避免内存泄漏，jQuery先移除子元素的数据和事件处理函数，然后移除子元素。</p><p>如果你想删除元素，不破坏他们的数据或事件处理程序（这些绑定的信息还可以在之后被重新添加回来），请使用.detach()代替 </p><p>3 .remove()</p><p>.remove( [selector ] )，将匹配元素集合从DOM中删除。</p><p>和 .empty()相似。.remove() 将元素移出DOM。 当我们想将元素自身移除时我们用 .remove()，同时也会移除元素内部的一切，包括绑定的事件及与该元素相关的jQuery数据。要删除的元素不删除数据和事件的情况下，使用.detach()来代替。</p><p>4 .unwrap()</p><p>将匹配元素集合的父级元素删除，保留自身（和兄弟元素，如果存在）在原来的位置。</p><p>4.1 .unwrap()</p><p>4.2 .unwrap( [selector ] )，添加版本3.0</p><p>selector类型: String，<br>一个选择器，用来检查匹配的父元素。如果一个元素的父不匹配该选择器，该元素将不会被解开。 (愚人码头注：该签名官网还未提供示例，可以查看我写的简单示例：<a href="http://jsbin.com/rufaqu/edit?html,css,js,output">http://jsbin.com/rufaqu/edit?html,css,js,output</a>)</p><p>.unwrap()删除元素的父级元素。和 .wrap()的功能相反。匹配的元素（以及他们的兄弟元素，如果有的话）取代他们的父母在DOM结构。</p><h3 id="DOM-替换"><a href="#DOM-替换" class="headerlink" title="DOM 替换"></a>DOM 替换</h3><p>有.replaceAll()，.replaceWith()</p><p>1 .replaceAll()</p><p>.replaceAll( target )，用集合的匹配元素替换每个目标元素。</p><p>.replaceAll() 方法会删除与节点相关联的所有数据和事件处理程序 。</p><p>2 .replaceWith()</p><p>.replaceWith()方法，和大部分其他jQuery方法一样，返回jQuery对象，所以可以和其他方法链接使用， 但是需要注意的是： （original）原始jQuery对象被返回。该对象指向已经从 DOM 中被移除的对象，而不是指向已经取代了它的新元素。</p><h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><h3 id="筛选"><a href="#筛选" class="headerlink" title="筛选"></a>筛选</h3><p>有.eq(),.filter(),.first(),.has(),.is(),.last(),.map(),.not(),.slice()</p><p>1 .eq()</p><p>.eq( index ),支持负值，负值从最后一个元素倒数</p><p>2 .first()</p><p>3 .last()</p><p>4 .has()</p><p>.has( selector )</p><p>.has( contained )</p><p>contained<br>类型: Element，<br>用于匹配元素的DOM元素。</p><p>5 .is()</p><p>5.1 .is( selector )</p><p>5.2 .is( function(index) )</p><p>5.3 .is( jQuery object )</p><p>5.4 .is( element )</p><p>6 .filter()</p><p>参数种类同上</p><p>7 .not()</p><p>从匹配的元素集合中移除指定的元素。参数同理</p><p>8 .map()</p><p>.map( callback(index, domElement) )</p><p>如果你想处理一个简单的数组或对象中，使用jQuery.map()代替。</p><p>由于返回值是一个jQuery包裹的数组，所以通常会使用get()方法将其转换成普通的数组。</p><p>.map()方法特别适用于获取或设置元素集合中的值,如下获取一组checkbox的值</p><pre><code>$(&#39;:checkbox&#39;).map(function() &#123;  return this.id;&#125;).get().join();</code></pre><p>在回调函数中，this指向每次迭代中的当前DOM元素。该函数可以返回一个单独的数据或数据数组，并在结果集合中插入。如果数组返回，数组中的元素插入到集合。如果函数返回null或undefined ，没有元素将被插入。</p><p>将一组div等高：</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;  &lt;style&gt;div &#123; width: 40px; float:left; &#125;input &#123; clear:left&#125;  &lt;/style&gt;  &lt;script src=&quot;http://code.jquery.com/jquery-latest.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;  &lt;input type=&quot;button&quot; value=&quot;equalize div heights&quot;&gt; &lt;div style=&quot;background:red; height: 40px; &quot;&gt;&lt;/div&gt;&lt;div style=&quot;background:green; height: 70px;&quot;&gt;&lt;/div&gt;&lt;div style=&quot;background:blue; height: 50px; &quot;&gt;&lt;/div&gt;  &lt;script&gt;$.fn.equalizeHeights = function() &#123;  var maxHeight = this.map(function(i,e) &#123; //this为实例，即jquery对象    return $(e).height();  &#125;).get();   return this.height( Math.max.apply(this, maxHeight) );&#125;; $(&#39;input&#39;).click(function()&#123;  $(&#39;div&#39;).equalizeHeights();&#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;</code></pre><p>9 .slice()</p><p>.slice( start [, end ] )</p><p>根据指定的下标范围，过滤匹配的元素集合，并生成一个新的 jQuery 对象。</p><p>jQuery的.slice()方法是仿照的JavaScript 数组的.slice()方法。其中的一个功能就是允许传入负的 start 和 end 参数。如果传递的是负数，那么下标位置是从结尾开始的，而不是从起始位置开始。</p><h3 id="各种遍历"><a href="#各种遍历" class="headerlink" title="各种遍历"></a>各种遍历</h3><p>.add()，.contents()，.each()，.end()</p><p>1 .add()</p><p>创建一个新的jQuery对象 ，元素添加到匹配的元素集合中。</p><p>1.1 .add( selector )</p><p>1.2 .add( elements )</p><p>1.3 .add( html )</p><p>1.4 .add( jQuery object )</p><p>1.5 .add( selector, context )</p><p>2 .contents()</p><p>获得匹配元素集合中每个元素的子元素，包括文字和注释节点。</p><p>给定一个jQuery对象，表示一个DOM元素的集合，.contents()方法允许我们通过DOM树中查找集合中的直接子元素，并根据匹配的元素创建一个新的 jQuery 对象。.contents()和.children()方法类似，只不过前者包括文本节点和注释节点，以及jQuery对象中产生的HTML元素。请注意，虽然这种方式可以传递文本节点和注释节点给一个jQuery集合，但是大多数操作不会支持他们。少数几个支持的操作将在他们的API文档页面中有一个明确的说明。</p><p>如果iframe与主页同域，.contents()方法也可用于获取iframe中的文件内容。</p><p>3 .each()</p><p>遍历一个jQuery对象，为每个匹配元素执行一个函数。</p><p>我们可以通过返回 false以便在回调函数内中止循环。</p><p>注意: jQuery的方法，返回一个jQuery对象遍历jQuery集合中的元素 - 被称为隐式迭代的过程。当这种情况发生时，它通常不需要显式地循环的.each()方法：</p><p>4 .end()</p><p>终止在当前链的最新过滤操作，并返回匹配的元素的以前状态。</p><p>大多数 jQueryDOM遍历 方法来操作 jQuery 对象实例，并创建一个新的对象，匹配一个不同的 DOM 元素集合。当发生这种情况时，实际上是新的元素集合被压入到对象内部维护的栈中。每次过滤方法都会被压入栈中。当我们需要返回到前一个状态时，我们可以使用end() 进行出栈操作，来返回栈中的前一个状态。</p><h3 id="树遍历"><a href="#树遍历" class="headerlink" title="树遍历"></a>树遍历</h3><p>有.addBack()，.children()，.find()，.closest()，.parent()，.parents()，.parentsUntil()，.next()，.nextAll()，.nextUntil()，.prev()，.prevAll()，.prevUntil()，.siblings()</p><p>1 .addBack()</p><p>.addBack( [selector ] )</p><p>添加堆栈中元素集合到当前集合，一个选择性的过滤选择器。</p><p>如上所述在讨论中的.end()， jQuery对象维护一个堆栈内部来跟踪匹配的元素集合的变化。当一个DOM遍历方法被调用时，新的元素集合推入到堆栈中。 如果还需要包含先前的元素集合，.addBack() 可以提供帮助。</p><pre><code>$(&#39;li.third-item&#39;).nextAll().addBack()      .css(&#39;background-color&#39;, &#39;red&#39;);</code></pre><p>2 .children()</p><p>.children()方法允许我们通过在DOM树中对这些元素的直接子元素进行搜索，并且构造一个新的匹配元素的jQuery对象。.find()和.children()方法是相似的，但后者只是针对向下一个级别的DOM树。还要注意的是和大多数的jQuery方法一样，.children()不返回文本节点;让所有子元素包括使用文字和注释节点，建议使用.contents()。</p><p>3 .find()</p><p>.find( selector )</p><p>.find( element ) 元素或jQuery对象</p><p>4 .closest()</p><p>从元素本身开始，在DOM 树上逐级向上级元素匹配，并返回最先匹配的祖先元素。</p><p>.parents()和.closest()方法类似，它们都在DOM树遍历了。两者之间的差异，尽管细微，是重要的：</p><ul><li>.closest()开始于当前元素，.parents()开始于父元素</li><li>.closest()在 DOM 树中向上遍历，直到找到与提供的选择器相匹配的元素，.parents()向上遍历DOM树到文档的根元素，每个祖先元素加入到临时集合，如果提供一个选择器，则会使用该选择器在集合中进行过滤</li><li>.closest()返回包含零个或一个元素的jQuery对象，.parents()返回包含零个，一个或多个元素的jQuery对象</li></ul><p>5 .parent()</p><p>6 .parents()</p><p>.parents()和.parent()方法是相似的，但后者只是进行了一个单级的DOM树查找（愚人码头注：也就是只查找一层，直接的父元素，而不是更加上级的祖先元素）。此外，$( “html” ).parent()方法返回一个包含document的集合，而$( “html” ).parents()返回一个空集合。</p><p>7 ..parentsUntil()</p><p>8 .next()</p><p>9 .nextAll()</p><p>10 .nextUntil()</p><p>11 .prev()</p><p>12 .prevAll()</p><p>13 .prevUntil()</p><p>14 .siblings()</p><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><h3 id="浏览器事件"><a href="#浏览器事件" class="headerlink" title="浏览器事件"></a>浏览器事件</h3><p>1 .resize()</p><p>1.1 .resize( handler(eventObject) )</p><p>1.2 .resize( [eventData ], handler(eventObject) )</p><p>1.3 .resize()</p><p>这个函数的前两个用法是 .bind(‘resize’, handler) 的快捷方式，第3个不带参数的用法是 .trigger(‘resize’) 的快捷方式。</p><p>当浏览器window的尺寸改变时，window元素上绑定的resize事件将被触发</p><p>2 .scroll()</p><p>当用户在元素内执行了滚动操作，就会在这个元素上触发scroll事件。它适用于window对象，但也可以是可滚动frames与CSS overflow属性设置为scroll的元素（或auto时，元素的显示高度小于其内容高度）</p><p>每当元素的滚动位置的变化时，该元素就会触发scroll事件，不管什么原因。鼠标点击或拖动滚动条，拖动里面的元素，按箭头键，或使用鼠标的滚轮都可能导致触发此事件。</p><h3 id="文档加载"><a href="#文档加载" class="headerlink" title="文档加载"></a>文档加载</h3><p>1 jQuery.holdReady()</p><p> 暂停或恢复.ready() 事件的执行。</p><p> jQuery.holdReady( hold )</p><p>hold类型: Boolean</p><p>指示是否暂停或恢复被请求的ready事件</p><p>在$.holdReady()方法允许调用者延迟jQuery的ready事件。这种先进的功能，通常会被用来允许在 ready 事件发生之前，动态加载其它的 JavaScript，例如 jQuery 插件，即使 DOM 可能已经准备就绪。该方法必须在文档早期被调用，例如，在 <head> 中加载完 jQuery 脚本之后，立刻调用该方法。如果在 ready 事件已经被调用后再调用该方法，将不会起作用。</p><p>为了延迟 ready 事件，首先要调用 $.holdReady(true)，当 ready 事件准备执行时，再调用 $.holdReady(false) 。注意，在 ready 事件中可以设置多个 hold。每一个都对应一次 $.holdReady(true) 调用。直到所有的 hold 都被释放，也就是调用了对应数量的 $.holdReady(false)之后，并且满足正常的文档 ready 条件时，ready 事件才会被真正执行。（见ready的更多信息。）)</p><pre><code>$.holdReady(true);$.getScript(&quot;myplugin.js&quot;, function() &#123;  $.holdReady(false);&#125;);</code></pre><p>2 .ready()</p><p>当DOM准备就绪时，指定一个函数来执行。</p><p>大多数浏览器提供了 DOMContentLoaded 事件形式的类似功能。 然而，jQuery的 .ready() 方法的不同之处在于它是一个重要并且有效的方法：在代码调用.ready( handler )之前，如果 DOM 已经准备就绪并且浏览器已经触发DOMContentLoaded，handler处理函数仍然会被执行。 相反，如果 DOMContentLoaded 事件侦听器在这个事件触发后才被添加进来，那么这个DOMContentLoaded 事件的处理程序将永远不会被执行。</p><p>浏览器还提供了 window 对象上的load事件。当这个事件触发时候，表明该网页上的所有资源已加载，包括图像。此事件可以使用jQuery的$( window ).on( “load”, handler )监听。当代码依赖加载的资源情况下，（例如，必需知道图像的尺寸时），那么代码应放置在一个 load事件的处理程序中。</p><p>值得注意的是，虽然 DOM 准备就绪（ready）总是在页面被完全加载之前，但是在已经生效执行的 .ready() 处理程序代码中绑定load事件侦听器，通常是不安全的。例如，在页面加载后，可以使用一些方法动态加载脚本，如$.getScript() 。虽然动态加载的脚本中的 .ready() 处理程序始终会被执行， 但是在动态加载脚本中的 window 的 load 事件已经触发过了，所以那些load 事件监听器将永远不会运行。</p><p>jQuery提供了几种方法来绑定函数，当DOM已准备就绪时，绑定的函数将会运行。在jQuery 3.0 中，只建议使用第一种语法（愚人码头注：即 $( handler )）; 其他语法仍然能正常工作，但已被标记为弃用（愚人码头注：将来的某个版本会被删除）。$(document).on( “ready”, handler ),从jQuery 1.8开始已被标记为弃用，在jQuery 3.0中已经被删除。请注意。</p><p>当$快捷方式不再可用时，$.noConflict()可以用于避免命名空间冲突。然而，传递给.ready() 的处理函数可以传递一个引用jQuery对象的参数。这使得处理程序中能够使用jQuery对象，例如，用作$,这样就可以不用关心它的别名：</p><pre><code>jq2 = jQuery.noConflict();jq2(function( $ ) &#123;  // 在这个代码块中可以像往常一样使用 $ ;实际的jQuery 对象是 jq2 &#125;);</code></pre><h3 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h3><p>1 .bind()</p><p>在jQuery 3.0中，.bind()已被标记为弃用。从jQuery 1.7开始，.on() 方法是将事件处理程序绑定到文档（document）的首选方法。所以我们不建议使用该方法。</p><p>2 .delegate()</p><p>在jQuery 3.0中，.delegate()已被标记为弃用。从jQuery 1.7开始，它已经被.on()方法取代。所以我们不建议使用该方法。</p><p>3 .on()</p><p>3.1 .on( events [, selector ] [, data ], handler(eventObject) )</p><p>events<br>类型: String，<br>一个或多个空格分隔的事件类型和可选的命名空间，或仅仅是命名空间，比如”click”, “keydown.myPlugin”, 或者 “.myPlugin”。</p><p>selector<br>类型: String，<br>一个选择器字符串，用于过滤出被选中的元素中能触发事件的后代元素。如果选择器是 null 或者忽略了该选择器，那么被选中的元素总是能触发事件。，</p><p>data<br>类型: Anything，<br>当一个事件被触发时，要传递给事件处理函数的event.data。</p><p>handler(eventObject)<br>类型: Function()，<br>事件被触发时，执行的函数。若该函数只是要执行return false的话，那么该参数位置可以直接简写成 false。</p><p>3.2 .on( events [, selector ] [, data ] )</p><p>events<br>类型: PlainObject，<br>一个对象，键是由一个或多个由空格分隔的事件类型及可选的名字空间，值是这些事件类型所对应的事件处理函数。</p><p>selector<br>类型: String，<br>一个选择器字符串，用于过滤出被选中的元素中能触发事件的后代元素。如果选择器是 null 或者忽略了该选择器，那么被选中的元素总是能触发事件。</p><p>data<br>类型: Anything，<br>当一个事件被触发时，要传递给事件处理函数的event.data。</p><p>（1）Event names and namespaces（事件名称和命名空间）</p><p>事件名称可以添加指定的event namespaces（命名空间） 来简化删除或触发事件。例如，”click.myPlugin.simple”为 click 事件同时定义了两个命名空间 myPlugin 和 simple。通过上述方法绑定的 click 事件处理，可以用.off(“click.myPlugin”) 或 .off(“click.simple”)删除绑定到相应元素的Click事件处理程序，而不会干扰其他绑定在该元素上的“click（点击）” 事件。命名空间类似CSS类，因为它们是不分层次的;只需要有一个名字相匹配即可。以下划线开头的名字空间是供 jQuery 使用的。</p><p>在.on()方法的第二种用法中，events参数是一个JavaScript对象或者键值对。键等同于events参数，用空格分隔的事件名称字符串和可选命名空间。每个键的值是一个函数（或false 的值），相当于 handler 参数，但是该值并不是方法中的最后一个参数。在其它方面，这两种形式在下面描述的内容中其行为都是相同的。</p><p>（2）Direct and delegated events（直接和委托的事件）</p><p>除了可以给未创建的后代元素绑定事件外，代理事件的另一个好处就是，当需要监视很多元素的时候，代理事件的开销更小。</p><p>注意: 委托事件不能用于SVG.</p><p>（3）The event handler and its environment（事件处理程序和它的环境）</p><p>默认情况下，大多数事件的冒泡从最初的 event target（目标元素） 开始的，直到document 元素。每个元素都沿着DOM层级这条路，jQuery会调用任何匹配的已被绑定的事件处理程序。一个处理程序可以调用的event.stopPropagation()防止事件向上冒泡文档树（从而防止这些元素的处理程序运行）。任何绑定到当前元素上的其他处理程序都将运行，为了防止这种情况，可以调用event.stopImmediatePropagation()。（绑定在元素上的事件被调用的顺序和它们被绑定的顺序时一样的。 ）</p><p>类似地，一个处理程序可以调用的event.preventDefault()取消浏览器默认操作行为。</p><p>调用event.stopPropagation() 和 event.preventDefault()会从一个事件处理程序会自动返回false。也可以直接将 false 当作 handler 的参数，作为 function(){ return false; } 的简写形式。</p><p>当jQuery的调用处理程序时，this关键字指向的是当前正在执行事件的元素。对于直接事件而言，this 代表绑定事件的元素。对于代理事件而言，this 则代表了与 selector 相匹配的元素。(注意，如果事件是从后代元素冒泡上来的话，那么 this 就有可能不等于 event.target。)若要使用 jQuery 的相关方法，可以根据当前元素创建一个 jQuery 对象，即使用 $(this)。</p><p>（4） Passing data to the handler（将数据传递到处理程序）</p><p>如果data参数给.on()并且不是null 或者 undefined，那么每次触发事件时，event.data都传递给处理程序。data参数可以是任何类型，但如果是字符串类型时，那么selector参数必须提供，或明确地传递null，这样的 data 参数不会误认为是选择器。最好是使用一个对象（键值对） ，所以可以作为属性传递多个值。</p><p>jQuery的1.4以后 ，相同的事件处理程序可以多次绑定到一个元素。这对于使用 event.data 功能，或者在闭包中使用唯一的数据时是特别有用的。例如：</p><pre><code>function greet( event ) &#123;  alert( &quot;Hello &quot; + event.data.name );&#125;$( &quot;button&quot; ).on( &quot;click&quot;, &#123;  name: &quot;Karl&quot;&#125;, greet );$( &quot;button&quot; ).on( &quot;click&quot;, &#123;  name: &quot;Addy&quot;&#125;, greet );</code></pre><p>按一下按钮时，上面的代码会产生两个不同的警告（alert）。</p><p>除了可以向 .on() 方法传入 data 参数外，还可以向 .trigger() 或 .triggerHandler() 中传入该参数。 这种方式提供数据（Data）被传递给事件处理程序的Event 对象内，作为进一步的参数。 如果传递给.trigger() 和 .triggerHandler()的第二个参数是一个数组， 数组中的每个元素将作为事件处理程序的单独参数。</p><p>（5）Event performance（事件性能）</p><p>对于高频率事件，可以按如下的办法提高事件的性能：</p><ul><li>减少事件处理函数中的工作量；</li><li>对于在事件处理函数中要用到的信息做好缓存而不是再重新计算一次；</li><li>或使用setTimeout限制的页面更新的实际次数。</li></ul><p>为了获得更好的性能，在绑定代理事件时，绑定的元素最好尽可能的靠近目标元素。避免在大型文档中，过多的在 document 或 document.body 上添加代理事件。</p><p>若代理事件的选择器使用了过于复杂的形式，特别是使用了分层选择器的情况，虽然说这样做会大大的降低性能，但是对于大多数应用而言，它的速度依然是足够快的。通过为寻找更合适的元素绑定事件的方法，就可以很简单的避免使用分层选择器的情况。</p><p>（6）Additional notes（其他注意事项）</p><p>虽然不建议，伪类事件名称”hover”可以作为”mouseenter mouseleave”的缩写使用。不要与 接受两个函数的.hover()方法混淆，这里只用一个处理函数绑定到伪类事件名称”hover”;处理程序应该检查的event.type 以确定是否是mouseenter或 mouseleave事件。</p><p>jQuery的事件系统需要一个DOM元素可以通过元素的属性附加数据，使事件就可以被跟踪和传递。object, embed, 和applet元素不能绑定数据，因此不能有jQuery的事件绑定。</p><p>W3C指定明确指定focus 和 blur事件没有冒泡，但是jQuery定义的跨浏览器的focusin 和 focusout事件，并且可以冒泡。当focus 和 blur绑定委派的事件处理程序时，jQuery分析名称，并提供将他们分别交付给focusin 和 focusout。为了保持一致性和清晰度，使用冒泡事件类型的名称。</p><p>在所有的浏览器，load ，scroll, 和 error 事件(例如, 在一个 <img> 元素上)不会冒泡。在Internet Explorer 8和更低，paste 和 reset事件不会冒泡，这样的事件是不支持委派使用，但若事件处理函数是直接绑定在产生事件的元素上的话，是可以使用这些事件的。</p><p>window对象上的error 事件使用非标准的参数和返回值约定，所以jQuery 不支持该事件。作为替代，直接用window.onerror属性分配一个处理函数。</p><p>当事件被首次触发时，处理函数列表才会被设置到元素上。当前元素上添加或删除事件处理函数不会立即生效，直到下一次的事件被处理。 为了避免任何后续事件处理函数在一个元素的事件处理函数中执行，调用event.stopImmediatePropagation() 这种行为违反了<a href="https://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-EventTarget-removeEventListener">W3C的事件规范</a>。 为了更好地了解这种情况下，考虑下面的代码：</p><pre><code>var $test = $( &quot;#test&quot; );function handler1() &#123;  console.log( &quot;handler1&quot; );  $test.off( &quot;click&quot;, handler2 );&#125; function handler2() &#123;  console.log( &quot;handler2&quot; );&#125; $test.on( &quot;click&quot;, handler1 );$test.on( &quot;click&quot;, handler2 );</code></pre><p>在上面的代码，handler2第一次无论如何都会被执行，即使使用.off()删除。 然而，该处理函数在下一次click事件被触发时将不执行。（愚人码头注：查看代码运行效果：<a href="http://jsfiddle.net/feiwen8772/dgxru81d/%EF%BC%89">http://jsfiddle.net/feiwen8772/dgxru81d/）</a></p><p>（7）一些事例</p><p>传递一个数组给.trigger()的事件处理程序，作为第二个参数。</p><pre><code>$( &quot;div&quot; ).on( &quot;click&quot;, function( event, salutation, name ) &#123;  alert( salutation + &quot;, &quot; + name );&#125;);$( &quot;div&quot; ).trigger( &quot;click&quot;, [ &quot;Goodbye&quot;, &quot;Jim&quot; ] );</code></pre><p>添加并触发自定义事件（非浏览器事件）。</p><pre><code>&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;utf-8&quot;&gt;  &lt;title&gt;on demo&lt;/title&gt;  &lt;style&gt;  p &#123;    color: red;  &#125;  span &#123;    color: blue;  &#125;  &lt;/style&gt;  &lt;script src=&quot;//code.jquery.com/jquery-1.10.2.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;Has an attached custom event.&lt;/p&gt;&lt;button&gt;Trigger custom event&lt;/button&gt;&lt;span style=&quot;display:none;&quot;&gt;&lt;/span&gt; &lt;script&gt;$( &quot;p&quot; ).on( &quot;myCustomEvent&quot;, function( event, myName ) &#123;  $( this ).text( myName + &quot;, hi there!&quot; );  $( &quot;span&quot; )    .stop()    .css( &quot;opacity&quot;, 1 )    .text( &quot;myName = &quot; + myName )    .fadeIn( 30 )    .fadeOut( 1000 );&#125;);$( &quot;button&quot; ).click(function () &#123;  $( &quot;p&quot; ).trigger( &quot;myCustomEvent&quot;, [ &quot;John&quot; ] );&#125;);&lt;/script&gt; &lt;/body&gt;&lt;/html&gt;</code></pre><p>使用 对象 同时添加多个事件处理函数。</p><pre><code>$( &quot;div.test&quot; ).on(&#123;  click: function() &#123;    $( this ).toggleClass( &quot;active&quot; );  &#125;, mouseenter: function() &#123;    $( this ).addClass( &quot;inside&quot; );  &#125;, mouseleave: function() &#123;    $( this ).removeClass( &quot;inside&quot; );  &#125;&#125;);</code></pre><p>在同一个元素上绑定多个事件，一个mouseenter和mouseleave：</p><pre><code>$( &quot;#cart&quot; ).on( &quot;mouseenter mouseleave&quot;, function( event ) &#123;  $( this ).toggleClass( &quot;active&quot; );&#125;);</code></pre><p>4 .off()</p><p>5 .one()</p><p>6 .trigger()</p><pre><code>$(&#39;#foo&#39;).on(&#39;custom&#39;, function(event, param1, param2) &#123;  alert(param1 + &quot;\n&quot; + param2);&#125;);$(&#39;#foo&#39;).trigger(&#39;custom&#39;, [&#39;Custom&#39;, &#39;Event&#39;]);</code></pre><p>注意: 对于非window的普通的对象和DOM对象， 如果一个触发事件名称和对象的一个属性名称相匹配， 如果事件处理程序没有调用event.preventDefault()，jQuery将尝试调用属性的方法。 如果不希望这种行为发生，请使用.triggerHandler() 来代替。（愚人码头注 .triggerHandler() 方法并不会触发事件的默认行为。）</p><p>注意: 和.triggerHandler()一样， 当调用.trigger()时，当一个事件名称匹配对象上属性名称时，属性名称会加上on前缀（如，在 具有非空onclick方法的window上触发click），  jQuery将尝试调用该属性作为方法。</p><p>注意: 当通过一个普通的对象不是类数组触发时 但仍然包含了length属性， 你应该传递对象到数组中（例如：[ { length: 1 } ]）。</p><p>7 .triggerHandler()</p><p>这个方法的行为与 .trigger() 相似，不同之处有如下几点：</p><ul><li><p>.triggerHandler( “event” )方法被触发时不会调用元素上的 .event()。 这意味着在表单上触发 .triggerHandler( “submit” )将不会调用表单上的.submit()。（愚人码头注：可以理解为.triggerHandler() 方法并不会触发事件的默认行为。(例如，表单提交)。）</p></li><li><p>.trigger() 会影响所有与 jQuery 对象相匹配的元素，而 .triggerHandler() 仅影响第一个匹配到的元素。</p></li><li><p>使用 .triggerHandler() 触发的事件，并不会在 DOM 树中向上冒泡。 如果它们不是由目标元素直接触发的，那么它就不会进行任何处理。<br>与普通的方法返回 jQuery 对象(这样就能够使用链式用法)相反，.triggerHandler()返回最后一个处理的事件的返回值。如果没有触发任何事件，会返回 undefined。</p></li></ul><p>8 .unbind()</p><p>在jQuery 3.0中，.unbind()已被标记为弃用。从jQuery 1.7开始，它已经被.off()方法取代。所以我们不建议使用该方法。</p><p>9 .undelegate()</p><p>在jQuery 3.0中，.undelegate()已被标记为弃用。从jQuery 1.7开始，它已经被.off()方法取代。所以我们不建议使用该方法。</p><h3 id="表单事件"><a href="#表单事件" class="headerlink" title="表单事件"></a>表单事件</h3><p>1 .blur()</p><p>一个元素失去焦点将触发blur事件。起初，这个事件仅适用于表单元素，如元素<input> 。在最新的浏览器中，这个事件适用范围已经扩大到包括所有元素类型。一个元素可以通过键盘命令失去焦点，比如tab键，或用鼠标点击网页上的其他地方。</p><p>应用不带参数的.blur()，我们可以手动触发这个事件:</p><p>2 .change()</p><p>一个元素的值改变的时候将触发change事件。此事件仅限用于<input>元素，<textarea>和<select>元素。对于下拉选择框，复选框和单选按钮，当用户用鼠标作出选择，该事件立即触发，但对于其他类型的input元素，该事件触发将推迟，直到元素失去焦点才会触发。</p><p>注意: 使用JavaScript改变输入元素的值，例如使用.val()，将不会触发该事件。</p><p>3 .focus()</p><p>当一个元素获得焦点时，focus事件被触发。此事件起初适用于有限的元素，比如表单元素（<input>, <select>等）和链接元素（<a href>）。在最近版本的浏览器中，该事件可以扩展到所有包括通过显式设置tabindex属性的元素类型。一个元素可以通过键盘命令获得焦点，如Tab键，或按鼠标点击的元素。</p><p>试图将焦点设置到一个隐藏的元素在Internet Explorer中导致错误。请注意，.focus()只能在可见元素上使用。要在一个元素执行focus事件却又不想让这个元素获取焦点的话， 请使用.triggerHandler(“focus”) 来代替 .focus()。</p><p>focus事件不会在Internet Explorer中冒泡。因此，用focus事件委派，跨浏览器无法正常工作。但是，在1.4.2版本， jQuery的解决此限制，将focus模拟为focusin 事件</p><p>4 .select()</p><p>当用户在一个元素中进行文本选择时，这个元素上的select事件就会被触发。此事件只能用在<input type="text"> 和<textarea>。</p><p>用于检索当前选定文本的方法在各个浏览器中是不同的。jQuery的一个插件都提供跨平台的解决方案。</p><p>5 .submit()</p><p>当用户试图提交表单时，就会在这个表单元素上触发submit事件。它只能绑定在<form>元素上。以下几种情况会导致表单被提交：用户点击了<input type="submit">, <input type="image">, 或者 <button type="submit">，或者当某些表单元素获取焦点时，敲击Enter（回车键），都可以提交。</p><p>根据不同的浏览器，Enter 键可能会导致表单被提交，如果这个表单只有一个文本框或只有一个 submit 按钮的话。界面不应该依赖于这个键的特殊行为，除非已经使用了 keypress 事件来监听 Enter 键的按下。</p><p>我们可以通过调用事件对象的.preventDefault()或在处理函数中返回 false 来取消提交：</p><p>在Internet Explorer中，JavaScript的submit事件不会冒泡。但是，依赖 submit 事件代理的脚本，从 jQuery 1.4 开始，可以跨浏览器正常使用。</p><h3 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件"></a>键盘事件</h3><p>1 .keydown()</p><p>当用户在一个元素上按下键盘上的键的时候，keydown事件就会发送给这个元素。 如果按下该键不放（保持按下状态），事件被重复发送到该键，时间间隔取决于操作系统。它可以绑定到任何元素，但该事件只是发送到具有焦点的元素上。不同的浏览器中，可获得焦点的元素略有不同，但是表单元素总是能获取焦点，所以对于此事件类型表单元素是最合适的。</p><p>如果需要任何按键被捕获（例如，要实现网页全局上的快捷键），那么把这个事件附加到document对象上是非常有用的。所有的按键事件都会沿着各自的 DOM 树冒泡到 document 对象上，除非明确停止。</p><p>要确定哪个键被按下，我们可以检测传递给处理函数的event 对象。而浏览器使用不同的属性来存储这些信息，jQuery的规范了.which属性，以便我们能够可靠地使用它来检索关键代码。此代码对应一个键盘上的按键，包括像方向键这种特殊键的代码，如果要捕获实际输入文本， .keypress()可能是一个更好的选择。</p><p>2 .keypress()</p><p>注意:：由于keypress事件没有统一的官方规范说明，所以在不同的浏览器，不同的浏览器版本，和不同的平台实际使用这个事件时可能遇到的问题。</p><p>当浏览器捕获一个元素上键盘输入时，keypress就会发送个元素。这是类似keydown事件，除了当按键被一直按下（即连续插入字符的场合）时的处理。如果用户按下并按住这个键（不松开释放）的时候，keydown事件只触发一次，但是keypress会在每个字符插入的时候都会触发事件。此外，组合键（如Shift）会触发keydown事件，但不会触发keypress事件。</p><p>值得注意的是keydown 和 keyup提供一个代码，表示哪一个键被按下，而keypress表示被输入哪个字符。例如，按下了小写的 “a”，在 keydown和keyup 中，对应该键的代码是 65，但是对于 keypress 而言，接收到的代码是 97。如果是大写 “A” 的话，则所有的相关事件接收到的代码都是 65。由于这个区别，若想捕获敲击了哪个特殊键的话，例如，方向键，使用 .keydown()或.keyup() 更好。</p><p>在文本框中按下某个键时，显示 event 对象。注意：输出 event 对象时，要依赖一个简单的 $.print() 插件 (<a href="http://api.jquery.com/scripts/events.js)%E3%80%82">http://api.jquery.com/scripts/events.js)。</a></p><p>3 .keyup()</p><h3 id="鼠标事件"><a href="#鼠标事件" class="headerlink" title="鼠标事件"></a>鼠标事件</h3><p>1 .click()</p><p>2 .contextmenu()</p><p>当在一个元素上点击鼠标的右键时,contextmenu事件被发送到这个元素上,但在显示的上下文菜单(右键菜单)之前。 这时上下文菜单键被按下，该事件在html元素上被触发。 任何HTML元素都可以接受此事件。</p><p>3 .dblclick()</p><p>在同一元素上同时绑定 click 和 dblclick 事件是不可取的。各个浏览器事件触发的顺序是不同的，一些浏览器在dblclick之前接受两个 click 事件 ，而和其它浏览器只接受一个 click 事件。用户往往可通过不同的操作系统和浏览器配置双击灵敏度（两次点击之间的最大时间被检测为双击）</p><p>4 .focusin()</p><p>focusin 事件会在元素（或者其内部的任何元素）获得焦点时触发。这跟 focus 事件的显著区别在于，它可以在父元素上检测子元素获得焦点的情况(换而言之，它支持事件冒泡)。</p><p>5 .focusout()</p><p>focusout 事件会在元素（或者其内部的任何元素）失去焦点时触发。这跟 blur 事件的显著区别在于，它可以在父元素上检测子元素失去焦点的情况(换而言之，它支持事件冒泡)。</p><p>6 .hover()</p><p>.hover()方法是同时绑定 mouseenter和 mouseleave事件</p><p>7 .mousedown()</p><p>任何鼠标按钮被按下时mousedown事件就会被发送。若要区分是哪个键被按下了，我们可以使用 event 对象的which属性。并非所有浏览器都支持这个属性（在 IE 中，要使用 button 属性来代替），但是jQuery对该属性进行了标准化，因此你可以放心的在任何浏览器中使用该属性。敲击鼠标左键which的值是1，敲击鼠标中键which的值是2，敲击鼠标右键which的值是3。</p><p>此事件主要用于确保主要按钮是用来开始拖动操作;如果不进行这样的判断，当用户尝试使用上下文菜单，可能会出现奇怪的结果。虽然可以通过这些属性，来检测鼠标中键和右键的点击，但不一定是可靠的。例如，在 Opera 和 Safari 中，默认情况下是无法检测鼠标右键的点击的。</p><p>如果在一个元素按住了鼠标不放，并且拖动鼠标离开这个元素，并释放鼠标键，这仍然是算作mousedown事件。在大多数的用户界面，这个动作的顺序被视为一个“取消”的按键，所以通常最好使用click事件，除非我们知道mousedown事件针对一个特定情况较好。</p><p>8 .mouseup()</p><p>9 .mouseenter()</p><p>mouseenter事件和mouseover的不同之处是事件的冒泡的方式。如果mouseover在这个例子中使用了，然后当鼠标指针在Inner元素上移动，该处理程序将被触发。这通常是不受欢迎的行为。另一方面, mouseenter 事件只会在绑定它的元素上被调用，而不会在后代节点上被触发。</p><p>10 .mouseleave()</p><p>mouseleave事件和mouseover的不同之处是事件的冒泡的方式。如果mouseover在这个例子中使用了，然后当鼠标指针在Inner元素上移出，该处理程序将被触发。这通常是不受欢迎的行为。另一方面, mouseleave 事件只会在绑定它的元素上被调用，而不会在后代节点上被触发</p><p>11 .mousemove()</p><p>当跟踪鼠标移动时，我们通常需要知道实际的鼠标指针的位置。event 对象传递给处理程序包含了一些有关鼠标的坐标信息。比如.clientX, .offsetX, 和 .pageX属性是有效的，但对他们的支持不同浏览器。幸运的是，jQuery的规范了.pageX和.pageY属性，以便他们能够在所有浏览器上使用。这些属性提供了鼠标指针位置相对于页面的左上角的X和Y坐标。</p><p>我们必须记住， mousemove事件是当鼠标指针移动时触发的，即使是一个像素。这意味着多个事件在短时间内被触发。如果处理器做任何重大的处理，或者如果该事件存在多个处理函数，这可能造成浏览器的严重的性能问题。因此，优化mousemove处理程序尽可能，这一点很重要，当不再需要他们时应尽快解除绑定。</p><p>一个常见的模式是在mousedown处理器内部绑定mousemove处理器，并在一个相应mouseup处理函数解除绑定。要实现这一系列事件，请记住，与 mouseup 事件相比，mouseup 事件可能会被发送到不同的 HTML 元素上。由于这个原因，mouseup 事件通常应该绑定在更高的 DOM 树中，例如 <body>。</p><p>12 .mouseout()</p><p>由于此事件类型冒泡，可能导致引起的很多头痛的问题。例如，在这个例子中当鼠标指针移出Inner元素，mouseout事件将被发送到Inner元素，然后冒泡到Outer元素 。这可能会不合时宜的触发绑定的mouseout处理函数。这可以用一个替代方法，见讨论. mouseleave ()。</p><p>13 .mouseover()</p><p>由于此事件类型冒泡，可能导致引起的很多头痛的问题。例如，在这个例子中当鼠标指针移出Inner元素，mouseover事件将被发送到Inner元素，然后冒泡到Outer元素 。这可能会不合时宜的触发绑定的mouseover处理函数。这可以用一个替代方法，见讨论. mouseenter ()。</p><h3 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h3><p>1 event.currentTarget</p><p>在事件冒泡过程中的当前DOM元素。</p><p>这个属性总是等于函数的this。</p><p>如果您使用jQuery.proxy或另一种形式操作作用域，this 将等于您所提供的context（上下文），而不是event.currentTarget</p><p>2 event.target</p><p>target 属性可以是注册事件时的元素，或者它的子元素。通常用于比较 event.target 和 this 来确定事件是不是由于冒泡而触发的。经常用于事件冒泡时处理事件委托。</p><p>3 event.relatedTarget</p><p>在事件中涉及的其它任何DOM元素。</p><p>对于 mouseout 事件，它指向被进入的元素；对于 mouseover 事件，它指向被离开的元素。</p><p>4 event.data</p><p>当当前正在执行的处理程序绑定时，一个可选的数据对象传递给一个事件方法。</p><p>5 event.type</p><p>6 event.timeStamp</p><p>通过在代码中获得两个点之间的 event.timeStamp 值，并给出差值来分析事件的性能，此属性是很有用的。如果只是要确定当前的时间内的事件处理程序，使用(new Date).getTime()来代替。</p><p>7 event.which</p><p>event.which 将 event.keyCode 和 event.charCode 标准化了。推荐用 event.which 来监视键盘输入。更多细节请参阅： event.charCode on the MDN.</p><p>event.which也将正常化的按钮按下(mousedown 和 mouseupevents)，左键报告1，中间键报告2，右键报告3。使用event.which代替event.button。</p><p>8 event.namespace</p><p>当事件被触发时此属性包含指定的命名空间。</p><p>这属性主要提供给插件作者用来处理的不同任务，具体取决于事件使用的命名空间。</p><p>9 event.result</p><p>事件被触发的一个事件处理程序的最后返回值，除非值是 undefined。</p><p>此属性当获取自定义事件前一个返回值时非常有用的。</p><p>10 event.pageX</p><p>11 event.pageY</p><p>12 event.isDefaultPrevented()</p><p>13 event.isImmediatePropagationStopped()</p><p>14 event.isPropagationStopped()</p><p>15 event.stopImmediatePropagation()</p><p>阻止剩余的事件处理函数执行并且防止事件冒泡到DOM树上。</p><p>16 event.stopPropagation()</p><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p>1 .hide()</p><p>1.1 .hide()</p><p>1.2 .hide( [duration ] [, complete ] )</p><p>duration (默认: 400)<br>类型: Number or String，<br>一个字符串或者数字决定动画将运行多久。</p><p>complete<br>类型: Function()，<br>在动画完成时执行的函数。</p><p>1.3 .hide( [duration ] [, easing ] [, complete ] )</p><p>1.4 .hide( options )</p><p>options<br>类型: PlainObject，<br>一组包含动画选项的值的集合。 支持的选项：</p><p>duration (default: 400)</p><p>easing (default: swing)，jQuery自身提供”linear” 和 “swing”，其他效果可以使用<a href="http://gsgd.co.uk/sandbox/jquery/easing/">jQuery Easing Plugin</a>插件）</p><p>queue (default: true)<br>Type: Boolean or String,<br>一个布尔值，指示是否将动画放置在效果队列中。如果为false时，将立即开始动画。 从jQuery1.7开始，队列选项也可以接受一个字符串，在这种情况下，在动画被添加到由该字符串表示的队列中。当一个自定义的队列名称被使用，动画不会自动启动;你必须调用.dequeue(“queuename”)来启动它。</p><p>specialEasing,<br>Type: PlainObject,<br>一组一个或多个通过相应的参数和相对简单函数定义的CSS属性 ( 1.4 新增)</p><p>step,<br>Type: Function( Number now, Tween tween ),<br>每个动画元素的每个动画属性将调用的函数。这个函数为修改Tween 对象提供了一个机会来改变设置中得属性值。</p><p>progress,<br>Type: Function( Promise animation, Number progress, Number remainingMs ),<br>每一步动画完成后调用的一个函数，无论动画属性有多少，每个动画元素都执行单独的函数。 (version added: 1.8)</p><p>complete,<br>Type: Function(),<br>在动画完成时执行的函数。</p><p>done<br>Type: Function( Promise animation, Boolean jumpedToEnd )<br>在动画完成时执行的函数。 (他的Promise对象状态已完成). (version added: 1.8)</p><p>fail<br>Type: Function( Promise animation, Boolean jumpedToEnd )<br>动画失败完成时执行的函数。(他的Promise对象状态未完成)。 (version added: 1.8)</p><p>always<br>Type: Function( Promise animation, Boolean jumpedToEnd )<br>在动画完成或未完成情况下停止时执行的函数。(他的Promise对象状态已完成或未完成)。 (version added: 1.8)</p><p><em>所有jQuery效果，包括.hide(),都能通过设置jQuery.fx.off = true全局的关闭，效果等同于持续时间设置为0。更多信息查看 jQuery.fx.off</em></p><p>2 .show()</p><p>注意: 如果使用!important在你的样式中，比如display: none !important，如果你希望.show()方法才能正常工作，必须使用.css(‘display’, ‘block !important’)重写样式。</p><p>3 .toggle()</p><p>3.1 .toggle( [duration ] [, complete ] )</p><p>3.2 .toggle( options )</p><p>3.3 .toggle( [duration ] [, easing ] [, complete ] )</p><p>3.4 .toggle(display)</p><p>display<br>类型: Boolean,<br>一个布尔值，使用 true 来显示元素，或者 false 隐藏它.</p><p>注意: 事件处理套件也有一个名为.toggle()方法(.toggle( handler(eventObject), handler(eventObject) [, handler(eventObject) ] ),在1.8被宣布过时，1.9已删除),哪一个被调用取决于传递的参数的设置。</p><h3 id="自定义"><a href="#自定义" class="headerlink" title="自定义"></a>自定义</h3><p>1 .animate()</p><p>.animate()方法允许我们在任意的数值的CSS属性上创建动画。唯一必要的属性就是一组CSS属性键值对。这组属性和用于设置.css()方法的属性键值对类似，除了属性范围做了更多限制。</p><p>所有用于动画的属性必须是数字的，除非另有说明；这些属性如果不是数字的将不能使用基本的jQuery功能。（例如，width, height或者left可以执行动画，但是background-color不能，除非使用jQuery.Color插件。）属性值的单位像素（px）,除非另有说明。单位em 和 %需要指定使用。</p><p>除了样式属性， 一些非样式的属性，如scrollTop 和 scrollLeft，以及自定义属性，也可应用于动画。</p><p>CSS简写属性（例如font, background, border）没有得到充分的支持。例如， 如果你想边框宽度做动画呈现，至少边框样式和边框宽度必须预先设定不为”auto” 。或者，如果你想字体大小做动画， 你可以使用fontSize的或相当于CSS的 ‘font-size’ ，而不是简单的’font’。</p><p>除了定义数值，每个属性能使用’show’, ‘hide’, 和 ‘toggle’。这些快捷方式允许定制隐藏和显示动画用来控制元素的显示或隐藏。为了使用jQuery内置的切换状态跟踪，’toggle’关键字必须在动画开始前给定属性值。（愚人码头注：jquery中有两个.toggle()方法，一个是显示或隐藏匹配元素。另一个是绑定两个或多个处理程序绑定到匹配的元素，用来执行在交替的点击。哪一个被调用取决于传递的参数的设置。所以这里’toggle’关键字必须在动画开始前给定属性值，以确认调用哪个’toggle’方法。）</p><p>动画属性也可以是一个相对值。如果提供一个以+= 或 -=开始的值，那么目标值就是以这个属性的当前值加上或者减去给定的数字来计算的。</p><p><em>注意: 不同于动画的简便方法，比如.slideDown() 和 .fadeIn(),.animate()方法不会影响隐藏元素的可见性部分的效果。例如，给定$(‘someElement’).hide().animate({height:’20px’}, 500)，动画将执行，但该元素将保持隐藏。</em></p><pre><code>$(&#39;#clickme&#39;).click(function() &#123;  $(&#39;#book&#39;).animate(&#123;    opacity: 0.25,    left: &#39;+=50&#39;,    height: &#39;toggle&#39;  &#125;, 5000, function() &#123;    // Animation complete.  &#125;);&#125;);</code></pre><p>Step Function</p><p>第二个版本的.animate()提供了一个step选项- 每步动画执行后调用的回调函数。启用自定义动画类型或改变正在执行的动画，此功能是非常有用。它接受两个参数（now 和 fx），this是当前正在执行动画的DOM元素集合。</p><p>now: 每一步动画属性的数字值</p><p>fx: jQuery.fx 原型对象的一个引用，其中包含了多项属性，比如elem 表示前正在执行动画的元素，start和end分别为动画属性的第一个和最后一个的值，prop为进行中的动画属性。</p><p>需要注意的是step函数被每个动画元素的每个动画属性调用。例如，给定两个列表项，step函数会被激发四次：</p><pre><code>$(&#39;li&#39;).animate(&#123;  opacity: .5,  height: &#39;50%&#39;&#125;,&#123;  step: function(now, fx) &#123;    var data = fx.elem.id + &#39; &#39; + fx.prop + &#39;: &#39; + now;    $(&#39;body&#39;).append(&#39;&lt;div&gt;&#39; + data + &#39;&lt;/div&gt;&#39;);  &#125;&#125;);</code></pre><p>Per-property Easing</p><pre><code>$(&#39;#clickme&#39;).click(function() &#123;  $(&#39;#book&#39;).animate(&#123;    width: [&#39;toggle&#39;, &#39;swing&#39;],    height: [&#39;toggle&#39;, &#39;swing&#39;],    opacity: &#39;toggle&#39;  &#125;, 5000, &#39;linear&#39;, function() &#123;      $(this).after(&#39;&lt;div&gt;Animation complete.&lt;/div&gt;&#39;);  &#125;);&#125;);</code></pre><p>在.animate()的第二个版本中，选项对象能包含specialEasing属性，该属性本身是一组CSS属性与相应的缓冲函数。例如，我们可以同时的使用linear缓冲函数来做width动画，并且用easeOutBounce缓冲函数来做height动画：</p><pre><code>$(&#39;#clickme&#39;).click(function() &#123;  $(&#39;#book&#39;).animate(&#123;    width: &#39;toggle&#39;,    height: &#39;toggle&#39;  &#125;, &#123;    duration: 5000,    specialEasing: &#123;      width: &#39;linear&#39;,      height: &#39;easeOutBounce&#39;    &#125;,    complete: function() &#123;      $(this).after(&#39;&lt;div&gt;Animation complete.&lt;/div&gt;&#39;);    &#125;  &#125;);&#125;);    </code></pre><p>2 .delay()</p><p>.delay( duration [, queueName ] )</p><p>设置一个延时来推迟执行队列中后续的项。</p><p>queueName<br>类型: String,<br>一个作为队列名的字符串。默认是动画队列 fx。标准的效果队列。</p><p><em>.delay()是用来在jQuery动画效果和类似队列中是最好的。但是，由于其本身的限制，比如无法取消延时,.delay()，它不是JavaScript的原生 setTimeout函数的替代品，这可能是更适合某些使用情况。</em></p><p>3 .queue()</p><p>显示或操作匹配的元素上已经执行的函数列队。</p><p>3.1 .queue( [queueName ] )</p><p>3.2 .queue( [queueName ], newQueue )</p><p>3.3 .queue( [queueName ], callback( next ) )</p><p>显示列队的长度: $div.queue(“fx”).length</p><p>值得注意的是，当使用.queue()添加一个函数的时候，我们应该保证在函数最后调用了 jQuery.dequeue()，这样就能让队列中的其它函数按顺序执行。</p><p>从jQuery 1.4开始，向队列中追加函数时，可以向该函数中传入另一个函数，作为第一个参数。当调用函数时，会自动从函数队列中弹出下一个项目，保证队列中函数的继续进行。我们可以像下面这样使用：</p><pre><code>$(&quot;#test&quot;).queue(function(next) &#123;    // Do some stuff...    next();&#125;);</code></pre><p>4 .dequeue()</p><p>执行匹配元素队列的下一个函数。</p><p>.dequeue( [queueName ] )</p><p>当.dequeue()被调用的时候，列队中的下一个函数将从这个列队中被移除，然后再执行。这个执行的函数中也应当直接或间接的包含 .dequeue()语句，这样才能继续执行队列中的其它函数，所以,这个序列可以继续。</p><p>5 jQuery.queue()</p><p>6 jQuery.dequeue()</p><p>7 jQuery.fx.interval</p><p>此属性在 3.0 版本中已经标记为弃用， 并在支持requestAnimationFrame方法的浏览器中没有效果。</p><p>对于不支持requestAnimationFrame的浏览器，该属性可以被改变，以调整动画将运行的时间间隔。默认为13毫秒。</p><p>由于jQuery中，该属性是全局性的，因此在没有动画正在运行或停止所有动画时，此属性的变化才能生效。</p><p>8 jQuery.fx.off</p><p>当这个属性设置为true的时候，调用时所有动画方法将立即设置元素为他们的最终状态，而不是显示效果。有时候确实有必要这样做：</p><p>jQuery是被用在低资源设备。</p><p>动画使用户遇到可访问性问题(查看这篇文章获得更多信息 Turn Off Animation)。</p><p>动画可以通过设置这个属性为false重新打开</p><p>9 .stop()</p><p>9.1 .stop( [clearQueue ] [, jumpToEnd ] )</p><p>clearQueue (默认: false)<br>类型: Boolean，<br>一个布尔值，指示是否取消列队动画。默认 false.</p><p>jumpToEnd (默认: false)<br>类型: Boolean，<br>一个布尔值指示是否当前动画立即完成。默认false.</p><p>9.2 .stop( [queue ] [, clearQueue ] [, jumpToEnd ] )</p><p>当一个元素调用.stop()，当前正在运行的动画（如果有的话）立即停止。</p><p>如果同一元素调用多个动画方法，尚未被执行的动画被放置在元素的效果队列中。这些动画不会开始，直到第一个完成。当调用.stop()的时候，队列中的下一个动画立即开始。如果clearQueue参数提供true值,那么在队列中的动画其余被删除并永远不会运行。</p><p>如果提供jumpToEnd参数，并且值为true时，当前动画将停止，但该元素上的 CSS 属性会被立刻修改成动画的目标值。</p><p>当我们需要对元素做mouseenter和mouseleave动画时，.stop()方法明显是有效的：</p><p>10 .finish()</p><p>停止当前正在运行的动画，删除所有排队的动画，并完成匹配元素所有的动画</p><p>.finish( [queue ] )</p><p>当.finish()在一个元素上被调用，立即停止当前正在运行的动画和所有排队的动画（如果有的话），并且他们的CSS属性设置为它们的目标值（愚人码头注：就是所有动画的目标值）。所有排队的动画将被删除。</p><p>.finish()方法和.stop(true, true)很相似，.stop(true, true)将清除队列，并且目前的动画跳转到其最终值。但是，不同的是，.finish() 会导致所有排队的动画的CSS属性跳转到他们的最终值。</p><p>.stop(true, true)等于.clearQueue().finish();</p><h3 id="渐变"><a href="#渐变" class="headerlink" title="渐变"></a>渐变</h3><p>.fadeIn()</p><p>.fadeOut()</p><p>.fadeTo()</p><p>.fadeToggle()</p><h3 id="滑动"><a href="#滑动" class="headerlink" title="滑动"></a>滑动</h3><p>.slideDown()</p><p>.slideToggle()</p><p>.slideUp()</p><h2 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h2><h3 id="全局Ajax事件处理程序"><a href="#全局Ajax事件处理程序" class="headerlink" title="全局Ajax事件处理程序"></a>全局Ajax事件处理程序</h3><p>这些方法用于注册事件处理器，用来处理页面上的任何 Ajax 请求，当某些事件触发后，这些事件处理器被调用。如何 jQuery.ajaxSetup() 中的 global 属性被设置为 true （这也是默认设置），那么，每个 Ajax 请求都会触发全局事件。注意：全局事件绝对不会被跨域（cross-domain）脚本或 JSONP 请求触发，和 global 属性的设置毫无关系。</p><p>1 .ajaxStart()</p><p>在AJAX 请求刚开始时执行一个处理函数</p><p><em>在jQuery1.9中，jQuery全局AJAX事件的所有处理程序， 包括那些.ajaxStart()添加的方法，必须 附加到 document上。</em></p><p><em>如果 $.ajax() 或 $.ajaxSetup()调用时， global 选项设置为 false， .ajaxStart()将不会触发。</em></p><p>2 .ajaxSend()</p><p>在Ajax请求发送之前绑定一个要执行的函数</p><p>无论哪一个Ajax请求被发送，所有ajaxSend处理器都将被执行。如果我们必须区分不同的请求,我们可以使参数传递给这个处理器。 每次ajaxSend 处理器执行，它传递事件对象，jqXHR对象（在 jQuery 1.4中是XMLHttpRequest对象），和用来创建请求的设置（settings object）对象。如果请求失败，因为JavaScript抛出一个异常，并且作为第四个参数的异常对象被传递给处理程序。举个例子,我们能限制我们的回调到只处理事件处理某一特定的URL:</p><pre><code>$(document).ajaxSend(function(event, jqxhr, settings) &#123;  if ( settings.url == &quot;ajax/test.html&quot; ) &#123;    $( &quot;.log&quot; ).text( &quot;Triggered ajaxSend handler.&quot; );  &#125;&#125;);</code></pre><p>3 .ajaxStop()</p><p>在AJAX 请求完成时执行一个处理函数。</p><p>每当一个Ajax请求完成，jQuery检查是否有任何其他响应过程中的Ajax请求（愚人码头注：未完成的请求）。如果都执行完成，jQuery就会触发ajaxStop事件，在这个时间点所有处理函数都会使用.ajaxStop()方法注册并执行。如果一个未处理完成的Ajax请求用beforeSend回调函数返回false取消，ajaxStop事件也被触发</p><p>4 .ajaxSuccess()</p><p>绑定一个函数当 Ajax 请求成功完成时执行</p><p>.ajaxSuccess( handler(event, XMLHttpRequest, ajaxOptions) )</p><p>5 .ajaxError()</p><p>Ajax请求出错时注册一个回调处理函数</p><p>.ajaxError( handler(event, jqXHR, ajaxSettings, thrownError) )</p><p>6 .ajaxComplete()</p><p>当Ajax请求完成后注册一个回调函数</p><p>每当一个Ajax请求完成，jQuery就会触发ajaxComplete事件，在这个时间点所有处理函数会使用.ajaxComplete()方法注册并执行。</p><h3 id="辅助函数"><a href="#辅助函数" class="headerlink" title="辅助函数"></a>辅助函数</h3><p>1 jQuery.param()</p><p>创建一个数组，一个普通的对象，或一个jQuery对象的序列化表示形式，用于URL查询字符串或Ajax请求。 如果传递一个jQuery对象传递，它应该包含输入元素（愚人码头注：input，textarea等）的名称/值属性。</p><p>1.1 jQuery.param( obj )</p><p>obj<br>类型: Array 或 PlainObject 或 jQuery，<br>一个用来序列化的一个数组，一个普通的对象，或一个jQuery对象。</p><p>1.2 jQuery.param( obj, traditional )</p><p>traditional<br>类型: Boolean，<br>一个布尔值，指示是否执行了传统的“shallow”的序列化。</p><p>在 jQuery 1.4中, $.param() 方法将会通过深度递归的方式序列化对象，以便符合现代化脚本语言和框架的需求，比如 PHP 和 Ruby on Rails。 你可以通过设置 jQuery.ajaxSettings.traditional = true;废除这个全局功能。</p><p>在jQuery 3.0中，$.param()方法，不再使用jQuery.ajaxSettings.traditional 作为其默认设置，将默认为 false。对于最好的跨版本兼容性，调用 $.param()时传递明确的值给第二个参数，不使用默认值。</p><p>如果传递的对象是一个数组，它必须是一个对象数组，其格式要跟.serializeArray()返回的格式一样：</p><pre><code>[  &#123; name: &quot;first&quot;, value: &quot;Rick&quot; &#125;,  &#123; name: &quot;last&quot;, value: &quot;Astley&quot; &#125;,  &#123; name: &quot;job&quot;, value: &quot;Rock Star&quot; &#125;]</code></pre><p><em>因为一些框架解析序列化的数字的能力有限， 在传递 obj 参数时我们应该谨慎，尽量不要传递含有对象的数组，或者数组中嵌套其它数组。</em></p><p><em>由于目前对序列化字符串没有统一的规约，此方法无法对复杂数据结构进行编码，使之可以支持所有语言。在此之前，$.param 方法将继续保持其目前的形式。</em></p><p>2 .serialize()</p><p>将用作提交的表单元素的值编译成字符串。</p><p>注意: 只有 “successful controls”可以被序列化成字符串。其中，提交按钮的值不会被序列化。另外，如果想要一个表单元素的值被序列化成字符串，这个元素必须含有 name 属性。此外，复选框（checkbox）和单选按钮（radio）(input 类型为 “radio” 或 “checkbox”)的值只有在被选中时才会被序列化。另外，文件选择元素的数据也不会被序列化。</p><pre><code>$(&quot;form&quot;).serialize();</code></pre><p>3 .serializeArray()</p><p>将用作提交的表单元素的值编译成拥有name和value对象组成的数组。例如[ { name: a value: 1 }, { name: b value: 2 },…]</p><p>.serializeArray()方法使用标准的W3C”successful controls”的标准来检测哪些元素应当包括在内。被禁用的元素不会被包括在内。并且,元素必须含有 name 属性。此外，提交按钮的值也不会被序列化。文件选择元素的数据也不会被序列化。</p><h3 id="底层接口"><a href="#底层接口" class="headerlink" title="底层接口"></a>底层接口</h3><p>1 jQuery.ajax()</p><p>jQuery最复杂的一个API，因为参数实在是太多了。</p><p>1.1 jQuery.ajax( url [, settings ] )</p><p>1.2 jQuery.ajax( [settings ] )</p><p>settings</p><p>类型: PlainObject</p><p>一个以”{键:值}”组成的AJAX 请求设置。所有选项都是可选的。可以使用$.ajaxSetup()设置任何默认参数。</p><p>1）accepts (默认: 取决于数据类型)</p><p>类型: PlainObject</p><p>一个键/值对集合映射给定的dataType 到其的MIME类型，它可以从发送Accept请求头信息中获得。 </p><p>请求头信息通知服务器该请求需要接收何种类型的返回结果。 例如，下面定义一个自定义类型的mycustomtype与请求一起发送：</p><pre><code>$.ajax(&#123;  accepts: &#123;    mycustomtype: &#39;application/x-some-custom-type&#39;  &#125;,   // Instructions for how to deserialize a `mycustomtype`  converters: &#123;    &#39;text mycustomtype&#39;: function(result) &#123;      // Do Stuff      return newresult;    &#125;  &#125;,   // Expect a `mycustomtype` back from server  dataType: &#39;mycustomtype&#39;&#125;);</code></pre><p>注意: 对于这种类型，为了使其正常工作，您将需要在converters中指定补充项。</p><p>2）async (默认: true)</p><p>跨域请求和 dataType: “jsonp” 请求不支持同步操作。</p><p>3）beforeSend</p><p>类型: Function( jqXHR jqXHR, PlainObject settings )<br>请求发送前的回调函数，用来修改请求发送前jqXHR（在jQuery 1.4.x的中，XMLHttpRequest）对象，此功能用来设置自定义 HTTP 头信息，等等。在beforeSend函数中返回false将取消这个请求</p><p>4）cache (默认: true, dataType为”script”和”jsonp”时默认为false)</p><p>如果设置为 false ，浏览器将不缓存此页面。注意: 设置cache为 false将在 HEAD和GET请求中正常工作。它的工作原理是在GET请求参数中附加”_={timestamp}”（译者注：时间戳）。该参数不是其他请求所必须的，除了在IE8中，当一个POST请求一个已经用GET请求过的URL。</p><p>5）complete</p><p>6）contents</p><p>类型: PlainObject，<br>一个以”{字符串/正则表达式}”配对的对象，根据给定的内容类型，解析请求的返回结果。 (1.5新增)</p><p>7）contentType (default: ‘application/x-www-form-urlencoded; charset=UTF-8’)</p><p>从 jQuery 1.6 开始，你可以传递false来告诉jQuery，没有设置任何内容类型头信息。 注意：W3C的XMLHttpRequest的规范规定，数据将总是使用UTF-8字符集传递给服务器；指定其他字符集无法强制浏览器更改编码。 注意:对于跨域请求，内容类型设置为application/x-www-form-urlencoded, multipart/form-data, 或 text/plain以外， 将触发浏览器发送一个预检OPTIONS请求到服务器。</p><p>8）context</p><p>类型: Object</p><p>这个对象用于设置Ajax相关回调函数的上下文。 默认情况下，这个上下文是一个ajax请求使用的参数设置对象。比如指定一个DOM元素作为context参数，这样就设置了complete回调函数的上下文为这个DOM元素。</p><pre><code>$.ajax(&#123;  url: &quot;test.html&quot;,  context: document.body&#125;).done(function() &#123;  $(this).addClass(&quot;done&quot;);&#125;);</code></pre><p>9)converters (默认: {“* text”: window.String, “text html”: true, “text json”: jQuery.parseJSON, “text xml”: jQuery.parseXML})</p><p>类型: PlainObject</p><p>一个数据类型到数据类型转换器的对象。每个转换器的值是一个函数，返回经转换后的请求结果</p><p>10)crossDomain (默认: 同域请求为false， 跨域请求为true</p><p>如果你想在同一域中强制跨域请求（如JSONP形式），例如，想服务器端重定向到另一个域，那么需要将crossDomain设置为 true 。</p><p>11)data</p><p>类型: PlainObject 或 String 或 Array</p><p>发送到服务器的数据。它被转换成一个查询字符串,如果已经是一个字符串的话就不会转换。查询字符串将被追加到GET请求的URL后面。参见 processData 选项说明，以防止这种自动转换。对象必须为”{键:值}”格式。如果这个参数是一个数组，jQuery会按照traditional 参数的值， 将自动转化为一个同名的多值查询字符串(查看下面的说明)。愚人码头注：如 {foo:[“bar1”, “bar2”]} 转换为 ‘&amp;foo=bar1&amp;foo=bar2’。</p><p>12)dataFilter</p><p>类型: Function( String data, String type ) =&gt; Anything</p><p>一个函数被用来处理XMLHttpRequest的原始响应数据。这是一个预过滤功能，净化响应。您应该返回安全数据。提供data和type两个参数：data是Ajax返回的原始数据，type是调用jQuery.ajax时提供的dataType参数。</p><p>13)dataType (default: Intelligent Guess (xml, json, script, or html))</p><p>从服务器返回你期望的数据类型。 如果没有指定，jQuery将尝试通过MIME类型的响应信息来智能判断（一个XML MIME类型就被识别为XML，在1.4中 JSON将生成一个JavaScript对象，在1.4中 script 将执行该脚本，其他任何类型会返回一个字符串）。</p><p>可用的类型（以及结果作为第一个参数传递给成功回调函数）有：</p><ul><li><p>xml 返回 XML 文档</p></li><li><p>html 返回纯文本 HTML 文本；包含的script标签会在插入DOM时执行。</p></li><li><p>script 把响应的结果当作 JavaScript 执行，并将其当作纯文本返回。默认情况下会通过在URL中附加查询字符串变量 _=[TIMESTAMP]， 禁用缓存结果，除非设置了cache参数为true。注意: 在远程请求时(不在同一个域下)，所有POST请求都将转为GET请求。(愚人码头注：因为将使用DOM的script标签来加载)</p></li><li><p>json 把响应的结果当作 JSON 执行，并返回一个JavaScript对象。跨域”json” 请求转换为”jsonp”，除非该请求在其请求选项中设置了jsonp:false。JSON 数据以严格的方式解析; 任何畸形的JSON将被拒绝，并且抛出解析错误信息。在jQuery1.9中，一个空响应也将被拒绝;服务器应该返回null或 {}响应代替。（见<a href="http://json.org/">json.org</a>的更多信息，正确的JSON格式。）</p></li><li><p>jsonp 以 JSONP 的方式载入 JSON 数据块。会自动在所请求的URL最后添加”?callback=?”。默认情况下会通过在URL中附加查询字符串变量 _=[TIMESTAMP]， 禁用缓存结果，除非设置了cache参数为true。</p></li><li><p>text 返回纯文本字符串</p></li></ul><p>多个用空格分割的值:从 jQuery 1.5 开始， jQuery可以内容类型（Content-Type）头收到并转换一个您需要的数据类型。例如，如果你想要一个文本响应为XML处理，使用”text xml”数据类型。您也可以将一个JSONP的请求，以文本形式接受，并用jQuery以XML解析: “jsonp text xml”。同样地可以使用”jsonp xml”简写,首先会尝试从 jsonp 到 xml 的转换，如果转换失败，就先将 jsonp 转换成 text, 然后再由 text 转换成 xml。</p><p>14)error</p><p>类型: Function( jqXHR jqXHR, String textStatus, String errorThrown )</p><p>如果发生了错误，错误信息（第二个参数）除了得到null之外，还可能是”timeout”, “error”, “abort” ，和 “parsererror”。 当一个HTTP错误发生时，errorThrown 接收HTTP状态的文本部分，比如： “Not Found”（没有找到） 或者 “Internal Server Error.”（服务器内部错误）。 从jQuery 1.5开始, 在error设置可以接受函数组成的数组。每个函数将被依次调用。 注意：此处理程序在跨域脚本和JSONP形式的请求时不被调用。</p><p>15)global (默认: true)</p><p>16)headers (默认: {})</p><p>一个额外的”{键:值}”对映射到请求一起发送。此设置会在beforeSend 函数调用之前被设置 ;因此，请求头中的设置值，会被beforeSend 函数内的设置覆盖 。 </p><p>17)ifModified (默认: false)</p><p>只有上次请求响应改变时，才允许请求成功。使用 HTTP 包 Last-Modified 头信息判断。默认值是false，忽略HTTP头信息。</p><p>18)isLocal (默认: 取决于当前的位置协议)</p><p>允许当前环境被认定为“本地”，（如文件系统），即使jQuery默认情况下不会这么做。以下协议目前公认为本地：file, *-extension, and widget。如果isLocal设置需要修改，建议在$.ajaxSetup()方法中这样做一次。 </p><p>19)jsonp</p><p>在一个JSONP请求中重写回调函数的名字。这个值用来替代在”callback=?”这种GET或POST请求中URL参数里的”callback”部分，比如{jsonp:’onJsonPLoad’}会导致将”onJsonPLoad=?”传给服务器。在jQuery 1.5，，设置jsonp选项为false，阻止了jQuery从加入”?callback”字符串的URL或试图使用”=?”转换。在这种情况下，你也应该明确设置jsonpCallback设置。例如, { jsonp: false, jsonpCallback: “callbackName” }。如果你不信任你的Ajax请求的目标，出于安全原因， 考虑 设置jsonp 属性为false。</p><p>20)jsonpCallback</p><p>类型: String, Function</p><p>为jsonp请求指定一个回调函数名。这个值将用来取代jQuery自动生成的随机函数名。这主要用来让jQuery生成一个独特的函数名，这样管理请求更容易，也能方便地提供回调函数和错误处理。你也可以在想让浏览器缓存GET请求的时候，指定这个回调函数名。从jQuery 1.5开始，你也可以使用一个函数作为该参数设置，在这种情况下，该函数的返回值就是jsonpCallback的结果。</p><p>21)method (default: ‘GET’)</p><p>HTTP 请求方法 (比如：”POST”, “GET “, “PUT”)。 (添加版本: 1.9.0)。（愚人码头注：如果你使用jQuery 1.9.0 之前的版本，你需要使用type选项。）</p><p>22)mimeType</p><p>一个mime类型用来覆盖XHR的 MIME类型。</p><p>23)password</p><p>用于响应HTTP访问认证请求的密码</p><p>24)processData (默认: true)</p><p>默认情况下，通过data选项传递进来的数据，如果是一个对象(技术上讲只要不是字符串)，都会处理转化成一个查询字符串，以配合默认内容类型 “application/x-www-form-urlencoded”。如果要发送 DOM 树信息或其它不希望转换的信息，请设置为 false。</p><p>25)scriptCharset</p><p>仅适用于当”script”传输使用时（例如，跨域的”jsonp”或 dataType选项为”script” 和 “GET”类型）。请求中使用在script标签上设置charset 属性。通常只在本地和远程的内容编码不同时使用。</p><p>26)statusCode (默认: {})</p><p>一个 HTTP响应状态码 和 当请求响应相应的状态码时执行的函数 组成的对象。例如： 下面的代码将在http响应状态码为404时弹出“page not found”。</p><pre><code>$.ajax(&#123;  statusCode: &#123;    404: function() &#123;      alert(&quot;page not found&quot;);    &#125;  &#125;&#125;);</code></pre><p>如果请求成功，响应状态代码对应的函数会带着success回调函数相同的参数；如果请求结果是错误的（包含3xx之类的重定向），他们会采用error回调函数相同的参数。</p><p>27)success</p><p>28)timeout</p><p>设置请求超时时间（毫秒）。此设置将覆盖$.ajaxSetup() 里的全局设置。</p><p>29)traditional</p><p>如果你想要用传统的方式来序列化数据，那么就设置为true。请参考工具分类下面的jQuery.param 方法.</p><p>30)type (默认: ‘GET’)</p><p>method选项的别名。如果你使用jQuery 1.9.0 之前的版本，你需要使用type选项</p><p>31)url (默认: 当前页面地址)</p><p>32)username</p><p>响应HTTP访问认证请求的用户名</p><p>33)xhr (默认: 当可用的ActiveXObject（IE）中，否则为XMLHttpRequest)</p><p>类型: Function()</p><p>回调创建XMLHttpRequest对象。当可用时默认为ActiveXObject（IE）中，否则为XMLHttpRequest。提供覆盖你自己的执行的XMLHttpRequest或增强工厂。</p><p>34)xhrFields</p><p>类型: PlainObject</p><p>一对“文件名-文件值”组成的映射，用于设定原生的 XHR对象。例如，如果需要的话，在进行跨域请求时，你可以用它来设置withCredentials为true。</p><pre><code>$.ajax(&#123;   url: a_cross_domain_url,   xhrFields: &#123;      withCredentials: true   &#125;&#125;); </code></pre><h4 id="ajax"><a href="#ajax" class="headerlink" title=".ajax()"></a>.ajax()</h4><p>jQuery 发送的所有 Ajax 请求，内部都会通过调用 $.ajax() 函数来实现。通常没有必要直接调用这个函数，可以使用几个已经封装的简便方法，如$.get()和.load()。如果你需要用到那些不常见的选项，那么， $.ajax()使用起来更灵活。</p><p>注意: 所有的选项都可以通过$.ajaxSetup() 函数来全局设置</p><h4 id="jqXHR-对象"><a href="#jqXHR-对象" class="headerlink" title="jqXHR 对象"></a>jqXHR 对象</h4><p>从jQuery 1.5开始，$.ajax() 返回XMLHttpRequest（jqXHR）对象，该对象是浏览器的原生的XMLHttpRequest对象的一个超集。例如，它包含responseText和responseXML属性，以及一个getResponseHeader()方法。当传输机制不是是XMLHttpRequest时（例如，一个JSONP请求脚本，返回一个脚本 tag 时），jqXHR对象尽可能的模拟原生的XHR功能。</p><p>从jQuery 1.5.1开始， jqXHR对象还包含了overrideMimeType方法 (它在jQuery 1.4.x中是有效的，但是在jQuery 1.5中暂时的被移除)。.overrideMimeType() 方法可能用在beforeSend()的回调函数中，例如，修改响应的Content-Type信息头：</p><p>从 jQuery 1.5 开始，$.ajax()返回的jqXHR对象 实现了 Promise 接口, 使它拥有了 Promise 的所有属性，方法和行为</p><p>jqXHR.done(function(data, textStatus, jqXHR) {});</p><p>jqXHR.fail(function(jqXHR, textStatus, errorThrown) {});</p><p>jqXHR.always(function(data|jqXHR, textStatus, jqXHR|errorThrown) { });</p><p>jqXHR.then(function(data, textStatus, jqXHR) {}, function(jqXHR, textStatus, errorThrown) {});</p><p>推荐使用的注意事项: jqXHR.success(), jqXHR.error(), 和 jqXHR.complete()回调从 jQuery 1.8开始 被弃用过时。他们将最终被取消，您的代码应做好准备， 从jQuery 3.0开始被删除，你可以使用jqXHR.done(), jqXHR.fail(), 和 jqXHR.always() 代替。</p><p>this在所有的回调中的引用，是这个对象在传递给$.ajax的设置中上下文；如果没有指定context（上下文），this 引用的是Ajax设置的本身。</p><p>为了向后兼容XMLHttpRequest ，jqXHR对象将公开下列属性和方法：</p><p>readyState</p><p>status</p><p>statusText</p><p>responseXML and/or responseText 当底层的请求分别作出XML和/或文本响应</p><p>setRequestHeader(name, value) 从标准出发，通过替换旧的值为新的值，而不是替换的新值到旧值</p><p>getAllResponseHeaders()</p><p>getResponseHeader()</p><p>abort()</p><p>这里有$.ajax()提供的回调钩子 （hooks），如下：</p><ul><li><p>beforeSend 在发送请求之前调用，它接收jqXHR对象和settings作为参数对象。</p></li><li><p>error 在请求出错时调用。如果请求失败，在它们的顺序依次登记。他们接受jqXHR ，字符串表示的错误类型，以及异常对象（如果有的话）。一些内置的错误会将 “abort”, “timeout”, “No Transport” 等字符串作为异常对象。</p></li><li><p>dataFilter 在请求成功之后调用。传入返回的数据以及dataType参数的值。并且必须返回新的数据（可能是处理过的）传递给success回调函数。</p></li><li><p>success 当请求成功并接收到返回数据之后调用。传入返回后的数据，以及包含成功代码的字符串和jqXHR对象。</p></li><li><p>Promise callbacks — .done(), .fail(), .always(), and .then() — 根据他们注册的顺序被调用。</p></li><li><p>complete 请求完成时，无论是在失败或成功，它们按顺序依次执行回调。他们收到jqXHR对象，以及一个包含成功或错误代码。</p></li></ul><h4 id="Data-Types（数据类型）"><a href="#Data-Types（数据类型）" class="headerlink" title="Data Types（数据类型）"></a>Data Types（数据类型）</h4><p>$.ajax()调用不同类型的响应，被传递到成功处理函数之前，会经过不同种类的预处理。 预处理的类型取决于由更加接近默认的Content-Type响应，但可以明确使用dataType选项进行设置。如果提供了dataType选项， 响应的Content-Type头信息将被忽略。</p><p>有效的数据类型是text， html， xml， json，jsonp，和 script.</p><p>如果指定的是text 或 html， 则不会预处理。 这些数据被简单地传递给成功处理函数， 并通过该jqXHR对象的responseText属性获得的。</p><p>如果指定的是xml， 响应结果作为XMLDocument，在传递给成功处理函数之前使用jQuery.parseXML进行解析。 XML文档是可以通过该jqXHR对象的responseXML属性获得的。</p><p>如果指定的是json，响应结果作为一个对象，在传递给成功处理函数之前使用jQuery.parseJSON进行解析。 解析后的JSON对象可以通过该jqXHR对象的responseJSON属性获得的。</p><p>如果指定的是script ，$.ajax() 执行这段 JavaScript，这段 JavaScript 从服务器接收到，在传递给成功处理函数之前是一个字符串。</p><p>如果指定的是jsonp ，$.ajax()会自动在请求的URL后面增加一个查询字符串参数 callback=?（默认） 。传递给$.ajax() 设置中的jsonp 和 jsonpCallback属性可以被用来指定， 分别为 查询字符串参数的名称和JSONP回调函数的名称。服务器应返回有效的JavaScript，传递JSON响应到回调函数（愚人码头注：例如，flightHandler({“code”: “CA1998”,”price”: 1780,”tickets”: 5});等）。 在包含JSON对象的相应结果传递给成功处理函数之前，$.ajax() 将执行返回的JavaScript， 调用JSONP回调函数。</p><h4 id="Sending-Data-to-the-Server（发送数据到服务器）"><a href="#Sending-Data-to-the-Server（发送数据到服务器）" class="headerlink" title="Sending Data to the Server（发送数据到服务器）"></a>Sending Data to the Server（发送数据到服务器）</h4><p>data选项既可以包含一个查询字符串，比如 key1=value1&amp;key2=value2，也可以是一个映射，比如 {key1: ‘value1’, key2: ‘value2’} 。如果使用了后者的形式，则数据再发送前会用jQuery.param() 将其转换成查询字符串。这个处理过程也可以通过设置processData选项为false来回避。如果我们希望发送一个XML对象给服务器时，这种处理可能并不合适。并且在这种情况下，我们也应当改变contentType 选项的值，用其他合适的MIME类型来取代默认的 application/x-www-form-urlencoded 。</p><h4 id="Advanced-Options（高级选项）"><a href="#Advanced-Options（高级选项）" class="headerlink" title="Advanced Options（高级选项）"></a>Advanced Options（高级选项）</h4><p>global选项用于阻止响应注册的回调函数，比如.ajaxSend(), .ajaxError()，以及类似的方法。这在有些时候很有用，比如发送的请求非常频繁且简短的时候，就可以在.ajaxSend()里禁用这个。跨域脚本和JSONP请求，全局选项自动设置为false。更多关于这些方法的详细信息，请参阅下面的内容。</p><p>如果服务器需要HTTP认证，可以使用用户名和密码可以通过 username 和 password 选项来设置。</p><p>默认情况下，请求总会被发出去，但浏览器有可能从他的缓存中调取数据。要禁止使用缓存的结果，可以设置cache参数为false。如果希望判断数据自从上次请求后没有更改过就报告出错的话，可以设置ifModified为true。</p><p>$.ajax()函数返回他创建的XMLHttpRequest对象。通常jQuery只在内部处理并创建这个对象，但用户也可以通过xhr 选项来传递一个自己创建的xhr对象。返回的对象通常已经被丢弃了，但依然提供一个底层接口来观察和操控请求。比如说，调用对象上的.abort() 可以在请求完成前挂起请求。</p><p>目前, 在Firefox中有一个bug，虽然.getResponseHeader(‘Content-Type’)返回一个非空的字符串，但是 .getAllResponseHeaders()还是返回空字符串， 在Firefox中使用jQuery不支持自动解码JSON CORS 响应。</p><h4 id="Using-Converters（使用转换器）"><a href="#Using-Converters（使用转换器）" class="headerlink" title="Using Converters（使用转换器）"></a>Using Converters（使用转换器）</h4><p>$.ajax()的转换器支持的数据类型映射到其它数据类型。但是，如果你想把自定义数据类型映射到一个已知的类型（json等）,您必须contents 选项在响应的Content-Type和实际的数据类型之间的添加一个相关的转换函数：</p><pre><code>$.ajaxSetup(&#123;  contents: &#123;    mycustomtype: /mycustomtype/  &#125;,  converters: &#123;    &quot;mycustomtype json&quot;: function ( result ) &#123;      // do stuff      return newresult;    &#125;  &#125;&#125;);</code></pre><p>这额外的对象是必要的，因为响应内容类型(Content-Types)和数据类型从来没有一个严格的一对一对应关系（正则表达式表示结果）。</p><p>转换一个支持的类型（例如text, json）成自定义数据类型，然后再返回，使用另一个直通转换器：</p><pre><code>$.ajaxSetup(&#123;  contents: &#123;    mycustomtype: /mycustomtype/  &#125;,  converters: &#123;    &quot;text mycustomtype&quot;: true,    &quot;mycustomtype json&quot;: function ( result ) &#123;      // do stuff      return newresult;    &#125;  &#125;&#125;);</code></pre><p>现在上面的代码允许通过从text 为mycustomtype ，进而，mycustomtype 转换为 json。</p><p><em>由于浏览器的安全限制，大多数“Ajax”的要求，均采用同一起源的政策 ;该请求不能成功地检索来自不同的域，子域或协议的数据。<br>Script和JSONP形式请求不受同源策略的限制</em></p><p>2 jQuery.ajaxSetup()</p><p>为以后要用到的Ajax请求设置默认的值</p><p>用于设置$.ajaxSetup()的详细参数, 参见 $.ajax().</p><p>所有后面的 Ajax 调用任何函数都将使用新的设置参数,除非它们调用时设置了各自的参数重载了这个默认值。 直到下一次调用$.ajaxSetup().</p><p>注意： 此处指定的设置会影响所有 $.ajax或基于AJAX的衍生方法，如$.get()的调用。这可能会导致不良的行为因为其他调用（例如，插件）可能希望正常的默认设置。出于这个原因，我们强烈建议您不要使用此API。相反我们建议，在调用时明确设置选项或定义一个简单的插件。</p><p>注意: 全局回调函数应使用他们各自的全局Ajax事件处理方法-.ajaxStart(), .ajaxStop(), .ajaxComplete(), .ajaxError(), .ajaxSuccess(), .ajaxSend()-设置，而不是为 $.ajaxSetup() 设置 options 对象。</p><h3 id="快捷方法"><a href="#快捷方法" class="headerlink" title="快捷方法"></a>快捷方法</h3><p>1 jQuery.get()</p><p>jQuery.get( url [, data ] [, success ] [, dataType ] )</p><p>2 jQuery.getJSON()</p><p>jQuery.getJSON( url [, data ] [, success(data, textStatus, jqXHR) ] )</p><pre><code>$.getJSON(&#39;ajax/test.json&#39;, function(data) &#123;  var items = [];   $.each(data, function(key, val) &#123;    items.push(&#39;&lt;li id=&quot;&#39; + key + &#39;&quot;&gt;&#39; + val + &#39;&lt;/li&gt;&#39;);  &#125;);   $(&#39;&lt;ul/&gt;&#39;, &#123;    &#39;class&#39;: &#39;my-new-list&#39;,    html: items.join(&#39;&#39;)  &#125;).appendTo(&#39;body&#39;);&#125;);</code></pre><p>3 jQuery.getScript()</p><p>使用一个HTTP GET请求从服务器加载并执行一个 JavaScript 文件</p><p>定义了一个$.cachedScript（）方法可以获取缓存的脚本：</p><pre><code>jQuery.cachedScript = function(url, options) &#123;   // allow user to set any option except for dataType, cache, and url  options = $.extend(options || &#123;&#125;, &#123;    dataType: &quot;script&quot;,    cache: true,    url: url  &#125;);   // Use $.ajax() since it is more flexible than $.getScript  // Return the jqXHR object so we can chain callbacks  return jQuery.ajax(options);&#125;; // Usage$.cachedScript(&quot;ajax/test.js&quot;).done(function(script, textStatus) &#123;  console.log( textStatus );&#125;);</code></pre><p>4 .load()</p><p>.load( url [, data ] [, complete(responseText, textStatus, XMLHttpRequest) ] )</p><p>默认使用 GET 方式 ， 如果data参数提供一个对象，那么使用 POST 方式。</p><h4 id="Loading-Page-Fragments（加载页面片段）"><a href="#Loading-Page-Fragments（加载页面片段）" class="headerlink" title="Loading Page Fragments（加载页面片段）"></a>Loading Page Fragments（加载页面片段）</h4><p>如果 url 参数的字符串中包含一个或多个空格，那么第一个空格后面的内容，会被当成是 jQuery 的选择器，从而决定应该加载返回结果中的哪部分内容。</p><pre><code>$(&#39;#result&#39;).load(&#39;ajax/test.html #container&#39;);</code></pre><p>5 jQuery.post()</p><p>用 POST 获取的页面是从来不会被缓存, 所以这些请求中的 cache 和 ifModified 选项在 jQuery.ajaxSetup() 是无效的。</p><h2 id="jQuery核心"><a href="#jQuery核心" class="headerlink" title="jQuery核心"></a>jQuery核心</h2><p>1 jQuery()</p><p>1.1 jQuery( selector [, context ] )</p><p>jQuery( selector [, context ] )</p><p>jQuery( element )</p><p>jQuery( elementArray )</p><p>jQuery( object )</p><p>jQuery( jQuery object )</p><p>jQuery()</p><p>1）Cloning jQuery Objects(克隆jQuery对象)</p><p>当一个jQuery对象作为一个参数传递给$()方法时，这个对象的一个克隆对象将被创建。这个新的jQuery对象引用同一DOM元素。</p><p>2）Returning an Empty Set(返回一个空集合)</p><p>在jQuery 1.4中，如果你传递给jQuery()方法一个空参数，一个空的jQuery设置将被返回（.length属性为0）。 在以前的jQuery版本中，一个包含整个文档节点的集合将被返回。</p><p>3）Working With Plain Objects（使用普通的对象）</p><p>目前，只支持包裹在jQuery中的普通的JavaScript对象是：.data(),.prop(),.bind(), .unbind(), .trigger() 和 .triggerHandler()。使用.data()（或者任何返回.data()的方法），在一个普通的对象会产生一个新的属性的名为jQuery{randomNumber}（如jQuery123456789）。</p><pre><code>// define a plain objectvar foo = &#123;foo: &quot;bar&quot;, hello: &quot;world&quot;&#125;; // Pass it to the jQuery functionvar $foo = $( foo ); // test accessing property valuesvar test1 = $foo.prop( &quot;foo&quot; ); // bar // test setting property values$foo.prop( &quot;foo&quot;, &quot;foobar&quot; );var test2 = $foo.prop( &quot;foo&quot; ); // foobar // test using .data() as summarized above$foo.data( &quot;keyName&quot;, &quot;someValue&quot;);console.log( $foo ); // will now contain a jQuery&#123;randomNumber&#125; property // test binding an event name and triggering$foo.bind( &quot;eventName&quot;, function () &#123;  console.log(&quot;eventName was called&quot;);&#125;); $foo.trigger( &quot;eventName&quot; ); // logs &quot;eventName was called&quot;</code></pre><p>1.2 jQuery( html [, ownerDocument ] )</p><p>jQuery( html [, ownerDocument ] )</p><p>jQuery( html, attributes )</p><p>从jQuery 1.4开始，给jQuery() 的第二个参数可以接受一个简单的对象组成的一个属性集合，可以传递.attr()方法。</p><p>重要提示： 如果第二个参数被传递，第一个参数中的HTML字符串 必须代表一个没有任何属性简单的元素。 从 jQuery 1.4开始，一些event type（事件类型）可以传递进来， 而且能够调用以下jQuery方法： val, css, html, text, data, width, height, or offset。</p><p>从 jQuery 1.8开始, 任何jQuery实例方法（一个jQuery.fn的方法），可以被用来作为一个该对象的属性传递给第二个参数：</p><pre><code>$( &quot;&lt;div&gt;&lt;/div&gt;&quot;, &#123;  &quot;class&quot;: &quot;my-div&quot;,  on: &#123;    touchstart: function( event ) &#123;      // do something    &#125;  &#125;&#125;).appendTo( &quot;body&quot; );</code></pre><p>在这个对象中，”class”（类）的名称必须使用引号括起来，因为它是一个JavaScript保留字，还有不能使用”className”，因为它是指的DOM属性（property），不是属性（attribute）。</p><p>虽然第二个参数是方便，它的灵活性可能会导致意想不到的后果（例如$(“<input>“, {size: “4”})调用.size()方法，代替设置size属性）。上面的代码块可以被写入，代替为：</p><pre><code>$( &quot;&lt;div&gt;&lt;/div&gt;&quot; ).addClass( &quot;my-div&quot; ).on(&#123;  touchstart: function( event ) &#123;    // do something  &#125;&#125;).appendTo( &quot;body&quot; );</code></pre><p>1.3 jQuery( callback )</p><p>2 jQuery.noConflict()</p><p>jQuery.noConflict( [removeAll ] )</p><p>removeAll<br>类型: Boolean，<br>一个布尔值，判断是否从全局作用域中内去除所有jQuery变量(包括jQuery本身)。</p><h2 id="jQuery杂项"><a href="#jQuery杂项" class="headerlink" title="jQuery杂项"></a>jQuery杂项</h2><h3 id="DOM-元素方法"><a href="#DOM-元素方法" class="headerlink" title="DOM 元素方法"></a>DOM 元素方法</h3><p>1 .get()</p><p>1.1 .get( index )</p><p>1.2 .get()</p><p>调用这个方法将会返回所有匹配的DOM节点，这些节点包含在一个标准的数组中</p><p>选择文档中的所有div，并且作为一个数组返回。然后使用浏览器原生的 reverse 方法将数组翻转。</p><pre><code>function disp(divs) &#123;    var a = [];    for ( var i = 0; i &lt; divs.length; i++) &#123;      a.push( divs[i].innerHTML );    &#125;    $( &quot;span&quot; ).text( a.join(&quot; &quot;) );&#125;disp( $( &quot;div&quot; ).get().reverse() );</code></pre><p>2 .toArray()</p><p>和.get()方法效果相同</p><p>3 .index()</p><p>3.1 .index()</p><p>3.2 .index( selector )</p><p>3.3 .index( element )</p><p>如果不传递任何参数给 .index() 方法，则返回值就是jQuery对象中第一个元素相对于它同辈元素的位置。</p><p>如果在一组元素上调用 .index() ，并且参数是一个DOM元素或jQuery对象， .index() 返回值就是传入的元素相对于原先集合的位置。</p><p>如果参数是一个选择器， .index() 返回值就是原先元素相对于选择器匹配元素的位置。如果找不到匹配的元素，则 .index() 返回 -1.</p><h3 id="内部构件"><a href="#内部构件" class="headerlink" title="内部构件"></a>内部构件</h3><p>1 .jquery</p><p>.jquery原型指向jQuery的原型， 通常被称为它的别名$.fn。它是一个字符串，其中包含的jQuery的版本号，如“1.5.0”或“1.4.4”。</p><p>2 jQuery.error()</p><p>jQuery.error( message )</p><p>接受一个字符串，并抛出包含这个字符串的异常。</p><p>这个方法主要是为了让插件开发人员可以重载此方法，并以更好的方式显示错误消息，或者提供更多相关信息。</p><p>3 .length</p><p>4 .pushStack()</p><p>将一个DOM元素集合加入到jQuery栈。</p><p><a href="http://www.cnblogs.com/AndyWithPassion/archive/2012/02/06/jquery_pushStack_javascript.html">更多参考</a></p><h2 id="实用工具"><a href="#实用工具" class="headerlink" title="实用工具"></a>实用工具</h2><p>1 jQuery.contains()</p><p>jQuery.contains( container, contained )</p><p>检查一个DOM元素是另一个DOM元素的后代。</p><p>如果第二个参数所提供的DOM元素是第一个参数DOM元素的后裔，那么$.contains() 方法返回true，无论是直接的子元素或者是后代元素。否则，返回false。只支持 element 节点;如果第二个参数是一个文本或注释节点，$.contains()将返回 false。</p><p><em>注意: 第一个参数必须是一个DOM元素，不是一个jQuery对象或普通的JavaScript对象。</em></p><p>2 jQuery.each()</p><p>注意: $.each()函数会在内部检索并且使用传递集合的 length属性。 所以，如果集合有一个名为length的属性 - 比如 {bar: ‘foo’, length: 10} - 这个函数可能无法正常工作。</p><p>我们可以在$.each()返回false来终止迭代。返回非false相当于一个循环中的continue语句，这意味着，它会立即跳出当前的迭代，转到下一个迭代。</p><p><em>jQuery中的each方法和ES5、underscore、Angular都不同，它的回调函数第一个参数为index/key，第二个为value，其他刚好相反</em></p><p>3 jQuery.extend()</p><p>jQuery.extend( [deep ], target, object1 [, objectN ] )</p><p>如果只有一个参数提供给$.extend()，这意味着目标参数被省略。在这种情况下，jQuery对象本身被默认为目标对象。这样，我们可以在jQuery的命名空间下添加新的功能。这对于插件开发者希望向 jQuery 中添加新函数时是很有用的。</p><p>请记住，目标对象（第一个参数）将被修改，并且将通过$.extend()返回。然而，如果我们想保留原对象，我们可以通过传递一个空对象作为目标对象：</p><pre><code>var object = $.extend(&#123;&#125;, object1, object2);</code></pre><p>在默认情况下，通过$.extend()合并操作不是递归的;如果第一个对象的属性本身是一个对象或数组，那么它将完全用第二个对象相同的key重写一个属性。这些值不会被合并。可以通过检查下面例子中 banana 的值，就可以了解这一点。然而，如果将 true 作为该函数的第一个参数，那么会在对象上进行递归的合并。</p><p>警告:不支持第一个参数传递 false 。</p><p>未定义的属性不会被复制。然而，从对象原型的继承属性将被复制。如果属性（Properties）是一个通过构造函数new MyCustomObject(args)定义的，或JavaScript中内置类型，如Date 或 RegExp，是不会重新创建的，并且将被当作普通的对象出在返回的对象或数组中。</p><p>若设置了 deep 参数，对象和数组也会被合并进来，但是对象包裹的原始类型，比如String, Boolean, 和 Number是不会被合并进来的。</p><p>4 jQuery.fn.extend()</p><p>一个对象的内容合并到jQuery的原型，以提供新的jQuery实例方法。</p><p>jQuery.fn.extend()方法继承了jQuery原型($.fn)对象，以提供jQuery原型新的方法，可以链式调用jQuery()函数。</p><pre><code>jQuery.fn.extend(&#123;  check: function() &#123;    return this.each(function() &#123; this.checked = true; &#125;);  &#125;,  uncheck: function() &#123;    return this.each(function() &#123; this.checked = false; &#125;);  &#125;&#125;); // Use the newly created .check() method$( &quot;input[type=&#39;checkbox&#39;]&quot; ).check();</code></pre><p>5 jQuery.globalEval()</p><p>在全局上下文下执行一些JavaScript代码</p><p>此方法的表现不同于正常使用的JavaScript eval()，因为它是在全局上下文下执行（这对加载外部动态脚本很重要）。</p><pre><code>function test()&#123;    jQuery.globalEval(&quot;var newVar = true;&quot;)&#125;test();// newVar === true</code></pre><p>6 jQuery.grep()</p><p>jQuery.grep( array, function(elementOfArray, indexInArray) [, invert ] )</p><p>查找满足过滤函数的数组元素。原始数组不受影响。类似underscore的filter</p><p>7 jQuery.inArray()</p><p>jQuery.inArray( value, array [, fromIndex ] )</p><p>8 jQuery.isArray()</p><p>9 jQuery.isEmptyObject()</p><p>从 jQuery 1.4 开始，这个方法既检测对象本身的属性，也检测从原型继承的属性（因此没有使用hasOwnProperty）。参数应当是一个普通的JavaScript对象， 对于其他类型的对象（DOM元素，原始strings/numbers，host对象）在跨浏览器中可能无法提供一致的结果。 要确定一个对象是否是一个普通的JavaScript对象，使用$.isPlainObject()</p><p>10 jQuery.isFunction()</p><p>11 jQuery.isNumeric()</p><p>$.isNumeric()方法检查它的参数是否能代表一个数值。如果是这样，则返回true。否则返回false。该参数可以是任何类型。（愚人码头注：jQuery 3.0之前，这个方法会强制转换参数为Number，转换后的值类型如果是如果是Number，也会返回true）</p><p>在jQuery 3.0中，$.isNumeric()方法只有接收number类型的参数时候，或者是可以被强制为有限数值的 string类型的参数，才会返回true，在其他情况下，返回false。</p><p>12 jQuery.isPlainObject()</p><p>注意: Host对象（或浏览器宿主环境中所使用的对象，用来完成的ECMAScript执行环境）在检测跨平台时存在很多的不一致，难以提供跨平台的强劲的检测函数。在某些情况下，$.isPlainObject()的结果可能在不同的浏览器评估不一致</p><p>13 jQuery.isWindow()</p><p>这个方法在jQuery很多地方用到，用来确定我们的操作是否为一个浏览器窗口操作。（如当前窗口或一个iframe）。</p><p>14 jQuery.isXMLDoc()</p><p>检查一个DOM节点是否在XML文档中（或者是一个XML文档）。</p><p>15 jQuery.makeArray()</p><p>转换一个类似数组的对象成为真正的JavaScript数组。</p><p>16 jQuery.map()</p><p>17 jQuery.merge()</p><p>合并两个数组内容到第一个数组。</p><p>18 jQuery.noop()</p><p>当你仅仅想要传递一个空函数的时候，就用他吧。</p><p>这对一些插件作者很有用，当插件提供了一个可选的回调函数接口，那么如果调用的时候没有传递这个回调函数，就用jQuery.noop来代替执行。</p><p>19 jQuery.now()</p><p>20 jQuery.parseHTML()</p><p>jQuery.parseHTML( data [, context ] [, keepScripts ] )</p><p>大多数的jQuery的API接受的HTML字符串将运行所包含在HTML中的脚本。jQuery.parseHTML不运行HTML中解析出来的脚本，除非 keepScripts参数为true。然而，它仍然是可能在大多数环境中间接地执行脚本，例如通过<img onerror>属性。调用者应该意识到这一点，并通过清理或避免任何不可信来源的输入，如URL或cookies，来防止它。为了未来的兼容性，当keepScripts为不确定的或false时，调用者不应该依赖于这个能力来运行任何脚本内容。</p><p>21 jQuery.parseJSON()</p><p>在jQuery 1.9之前,如果传递给$.parseJSON一个空字符串，null, 或者 undefined,，将返回null，而不是抛出一个错误，即使这些都不是有效的JSON。</p><p>jQuery 3.0开始，$.parseJSON已经过时（愚人码头注：不建议使用）。要将字符串解析成JSON对象，请使用原生的JSON.parse方法来代替</p><p>22 jQuery.parseXML()</p><p>23 jQuery.proxy()</p><p>24 jQuery.readyException()</p><p>jQuery.readyException( error )</p><p>处理包裹在jQuery()中函数同步抛出的错误。</p><p>25 jQuery.trim()</p><p>26 jQuery.type()</p><p>确定JavaScript 对象的类型[[Class]] 。</p><p>27 jQuery.unique()</p><p>在jQuery 3.0中，这种方法已被弃用，只是jQuery.uniqueSort()的别名。请使用该方法代替。</p><p>$.unique()函数通过搜索的数组对象，排序数组，并移除任何重复的节点。 如果一个节点和已经在数组中的节点完全相同，那么它被认为是重复的;  两个不同的节点具有相同的属性是被认为不重复的。 此功能只适用于普通的JavaScript DOM元素的数组，主要是jQuery内部使用。你可能永远都不需要使用它。</p><h2 id="延迟对象（deferred对象）"><a href="#延迟对象（deferred对象）" class="headerlink" title="延迟对象（deferred对象）"></a>延迟对象（deferred对象）</h2><p>deferred对象就是jQuery的回调函数解决方案。</p><p>1 $.deferred()方法</p><p>作用是生成一个deferred对象。</p><p>2 deferred.done()</p><p>当Deferred（延迟）对象解决时，调用添加处理程序。</p><p>deferred.done( doneCallbacks [, doneCallbacks ] )</p><p>当Deferred（延迟）解决时，doneCallbacks被调用。回调是依照他们添加的顺序执行。</p><p>3 deferred.fail()</p><p>当Deferred（延迟）对象拒绝时，调用添加的处理程序。</p><p>4 deferred.progress()</p><p>当Deferred（延迟）对象生成正在执行中的进度通知时，调用添加处理程序。</p><p>5 deferred.always()</p><p>当Deferred（延迟）对象解决或拒绝时，调用添加处理程序。</p><p>6 deferred.then()</p><p>deferred.then( doneFilter [, failFilter ] [, progressFilter ] )</p><p>有时为了省事，可以把done()和fail()合在一起写，这就是then()方法。</p><p>7 deferred.promise()</p><p>返回Deferred(延迟)的Promise（承诺）对象。</p><p>deferred.promise( [target ] )</p><p>大多数情况下，我们不想让用户从外部更改deferred对象的状态。这时，你可以在deferred对象的基础上，返回一个针对它的promise对象。我们可以把后者理解成，promise是deferred的只读版，或者更通俗地理解成promise是一个对将要完成的任务的承诺。promise对象只开放与改变执行状态无关的方法（比如done()方法和fail()方法），屏蔽与改变执行状态有关的方法（比如resolve()方法和reject()方法），从而使得执行状态不能被改变</p><p>你可以通过promise对象，为原始的deferred对象添加回调函数，查询它的状态，但是无法改变它的状态，也就是说promise对象不允许你调用resolve和reject方法。</p><p>jQuery的ajax() 方法返回的就是一个promise对象。此外，Animation类操作也可以使用promise对象。</p><p>8 deferred.state()</p><p>deferred.state() 方法返回一个字符串，代表Deferred（延迟）对象的当前状态。Deferred对象可以在三种状态之一：</p><ul><li><p>“pending”: Deferred对象是尚未完成状态 (不是 “rejected” 或 “resolved”).</p></li><li><p>“resolved”: Deferred对象是在解决状态，这意味着，deferred.resolve() 或者 deferred.resolveWith()被对象访问和doneCallbacks被访问（或在被调用的过程中） 。</p></li><li><p>“rejected”: Deferred对象是在被拒绝的状态，这意味着，deferred.reject() 或者 deferred.rejectWith() 被对象访问和failCallbacks被访问（或在被调用的过程中） 。</p></li></ul><p>这种方法主要是有用的调试，例如，在准备拒绝（reject）一个延迟对象前，判断它是否已经处于 resolved 状态。</p><p>9 deferred.notify()</p><p>deferred.notify( args )</p><p>根据给定的 args参数 调用Deferred（延迟）对象上进行中的回调 （progressCallbacks）。</p><p>通常情况下，只有递延对象（Deferred）的创建者才能调用此方法; 您可以通过deferred.promise()返回的受限制的 Promise 对象，来防止其他代码改变递延的状态 。</p><p>当 deferred.notify 被访问时， 任何progressCallbacks 可以通过访问deferred.then 好或者 deferred.progress来添加。回调是依照他们添加的顺序执行的。</p><p>10 deferred.notifyWith( context [, args ] )</p><p>Context（上下文） 作为this对象传递给进行中的回调（progressCallbacks ）</p><p>11 deferred.reject()</p><p>拒绝Deferred（延迟）对象，并根据给定的args参数调用任何失败回调函数（failCallbacks）。</p><p>12 deferred.rejectWith()</p><p>13 deferred.resolve()</p><p>解决Deferred（延迟）对象，并根据给定的args参数调用任何完成回调函数（doneCallbacks）。</p><p>14 deferred.resolveWith()</p><p>15 .promise()</p><p>.promise( [type ] [, target ] )</p><p>type (默认: fx),<br>类型: String,<br>需要待观察队列类型。 </p><p>target<br>类型: PlainObject,<br>将要绑定 promise 方法的对象。</p><p>注意: 返回的 Promise 被链接到延迟对象上，保存在元素的 .data() 中。由于 .remove() 方法会移除元素上的 data，同时也会移除元素本身。所以，使用它会防止任何元素上未被受理的（unresolved） Promise 被受理（resolving）。如果有必要在元素的 Promise 被受理（resolved）之前，从 DOM 中移除该元素的话，请使用 .detach() 来代替。之后再调用 .removeData()</p><p>当所有的动画结果时(包括那些在动画回调函数和之后添加的回调函数中初始化的动画），受理（Resolve）返回的 Promise：</p><pre><code>&lt;script&gt;$(&quot;button&quot;).bind( &quot;click&quot;, function() &#123;  $(&quot;p&quot;).append( &quot;Started...&quot;);   $(&quot;div&quot;).each(function( i ) &#123;    $( this ).fadeIn().fadeOut( 1000 * (i+1) );  &#125;);   $( &quot;div&quot; ).promise().done(function() &#123;    $( &quot;p&quot; ).append( &quot; Finished! &quot; );  &#125;);&#125;);&lt;/script&gt;</code></pre><p>16 deferred.catch()</p><p>当Deferred对象被拒绝(reject)时，调用添加的处理程序。</p><p>deferred.catch( failFilter )</p><p>failFilter<br>Type: Function(),<br>一个函数，当 Deferred 对象被拒绝(reject)时被调用</p><p>jQuery3.0添加</p><p>deferred.catch( fn ) 是 deferred.then( null, fn )的一个别名</p><h2 id="回调对象"><a href="#回调对象" class="headerlink" title="回调对象"></a>回调对象</h2><p>jQuery.Callbacks()</p><p>jQuery.Callbacks( flags )</p><p>flags<br>类型: String，<br>一个用空格标记分隔的标志可选列表,用来改变回调列表中的行为。</p><p>$.Callbacks用来管理函数队列。采用了观察者模式，通过add添加操作到队列当中，通过fire去执行这些操作。实际上$.Callbacks是1.7版本从$.Deferred对象当中分离出来的，主要是实现$.Deferred功能。</p><p>$.Callbacks()的内部提供了jQuery的$.ajax() 和 $.Deferred() 基本功能组件。它可以用来作为类似基础定义的新组件的功能。</p><p>$.Callbacks() 支持的方法，包括 callbacks.add(),callbacks.remove(), callbacks.fire() 和 callbacks.disable().</p><h3 id="支持的-Flags"><a href="#支持的-Flags" class="headerlink" title="支持的 Flags"></a>支持的 Flags</h3><p>这个 flags 参数是$.Callbacks()的一个可选参数, 结构为一个用空格标记分隔的标志可选列表,用来改变回调列表中的行为 (比如. $.Callbacks( ‘unique stopOnFalse’ )).</p><p>可用的 flags:</p><ul><li><p>once: 函数队列只执行一次</p></li><li><p>memory: 当函数队列fire或fireWith一次过后，内部会记录当前fire或fireWith的参数。当下次调用add的时候，会把记录的参数传递给新添加的函数并立即执行这个新添加的函数</p></li><li><p>unique: 往内部队列添加的函数保持唯一，不能重复添加。</p></li><li><p>stopOnFalse: 内部队列里的函数是依次执行的，当某个函数的返回值是false时，停止继续执行剩下的函数。</p></li></ul><p>默认情况下，回调列表将像事件的回调列表中可以多次触发。</p><p>这四种基本类型可以相互组合起来使用，例如$.Deferred就使用了once和memory的组合。</p><h3 id="Callbacks-支持的方法"><a href="#Callbacks-支持的方法" class="headerlink" title="$.Callbacks() 支持的方法"></a>$.Callbacks() 支持的方法</h3><p>1 add()</p><p>向内部队列添加函数，总有三种参数形式:</p><ul><li><p>单个函数参数</p></li><li><p>多个函数参数</p></li><li><p>数组参数</p></li></ul><p>2 fire()</p><p>依次执行队列里的函数</p><p>3 fire的参数会传递给我们添加的函数</p><p>4 fireWith</p><p>fire调用的时候，我们添加函数当中的this指向我们的Callbacks实例</p><p>fireWith就是改变我们添加函数的context，即this指向</p><p>fireWith第一个参数是我们的context，第二个参数是我们需要传递的内容数组，注意了是数组！</p><p>5 empty</p><p>清空函数队列</p><p>6 has</p><p>判断函数队列中是否存在某个函数</p><p>7 remove</p><p>从内部队列中移除某些函数</p><p>8 disable</p><p>禁用回调列表中的回调</p><p>9 disabled</p><p>回调管理是否被禁用</p><p>10 lock</p><p>锁定回调列表的当前状态。</p><p>disable和lock的区别</p><p>两者唯一的区别就是添加了memory参数，看一下对比</p><pre><code>var cb = $.Callbacks(&#39;memory&#39;);cb.add(function () &#123;    console.log(&#39;one&#39;);&#125;);cb.fire();cb.disable();//cb.lock();cb.add(function () &#123;    console.log(&#39;two&#39;);&#125;);</code></pre><p>毫无疑问，disable就是禁用所有功能，无论添加什么参数。而在memory的情况下，fire过后再lock，继续add新的函数依旧会立即执行。</p><p>11 locked</p><p>回调管理是否被锁</p><p>12 fired</p><p>回调队列是否执行过</p><h3 id="Callbacks-Deferred-and-Pub-Sub"><a href="#Callbacks-Deferred-and-Pub-Sub" class="headerlink" title="$.Callbacks, $.Deferred and Pub/Sub"></a>$.Callbacks, $.Deferred and Pub/Sub</h3><p>pub / sub（观察者模式）背后的一般思路 是促进应用程序的松散耦合。而比对其他对象的方法调用的单个对象，一个对象，而不是另一个对象的一个特定的任务或活动，并通知当它发生。观察家也被称为订阅者，它指向观察对象。观察者（Publisher）事件发生时通知用户</p><p>作为 $.Callbacks() 的创建组件的一个演示，只使用回调函数列表，就可以实现 Pub/Sub 系统。</p><pre><code>var topics = &#123;&#125;; jQuery.Topic = function( id ) &#123;    var callbacks,        method,        topic = id &amp;&amp; topics[ id ];     if ( !topic ) &#123;        callbacks = jQuery.Callbacks();        topic = &#123;            publish: callbacks.fire,            subscribe: callbacks.add,            unsubscribe: callbacks.remove        &#125;;        if ( id ) &#123;            topics[ id ] = topic;        &#125;    &#125;    return topic;&#125;;</code></pre><p>然后，可以很容易的使用这部分应用程序的发布和订阅感兴趣的事件：</p><pre><code>// Subscribers$.Topic( &quot;mailArrived&quot; ).subscribe( fn1 );$.Topic( &quot;mailArrived&quot; ).subscribe( fn2 );$.Topic( &quot;mailSent&quot; ).subscribe( fn1 ); // Publisher$.Topic( &quot;mailArrived&quot; ).publish( &quot;hello world!&quot; );$.Topic( &quot;mailSent&quot; ).publish( &quot;woo! mail!&quot; ); // Here, &quot;hello world!&quot; gets pushed to fn1 and fn2// when the &quot;mailArrived&quot; notification is published// with &quot;woo! mail!&quot; also being pushed to fn1 when// the &quot;mailSent&quot; notification is published. /*output:hello world!fn2 says: hello world!woo! mail!*/</code></pre><p>尽管上面的代码很有用，但是可以进一步改进其实现。使用 $.Deferreds，可以保证当特定的任务被完成（或被解决）时，发布者只能向订阅者发布通知。参见下面的示例代码，进一步讨论如何在实践中使用这种情况：</p><pre><code>// subscribe to the mailArrived notification$.Topic( &quot;mailArrived&quot; ).subscribe( fn1 ); // create a new instance of Deferredsvar dfd = $.Deferred(); // define a new topic (without directly publishing)var topic = $.Topic( &quot;mailArrived&quot; ); // when the deferred has been resolved, publish a// notification to subscribersdfd.done( topic.publish ); // Here the Deferred is being resolved with a message// that will be passed back to subscribers. It&#39;s possible to// easily integrate this into a more complex routine// (eg. waiting on an ajax call to complete) so that// messages are only published once the task has actually// finished.dfd.resolve( &quot;it&#39;s been published!&quot; );</code></pre><h3 id="use-JQuery-Callbacks"><a href="#use-JQuery-Callbacks" class="headerlink" title="use JQuery.Callbacks"></a>use JQuery.Callbacks</h3><p><a href="http://stackoverflow.com/questions/8070894/when-would-i-use-jquery-callbacks">When would I use JQuery.Callbacks?</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机 </tag>
            
            <tag> 前端 </tag>
            
            <tag> 积累 </tag>
            
            <tag> javascript </tag>
            
            <tag> jQuery </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>fiddler学习总结</title>
      <link href="/posts/18778.html"/>
      <url>/posts/18778.html</url>
      
        <content type="html"><![CDATA[<h3 id="fiddler"><a href="#fiddler" class="headerlink" title="fiddler"></a>fiddler</h3><p>1.基本功能<br>监控HTTP/HTTPs流量<br>查看截获的内容<br>伪造请求（伪造服务器返回来的请求，还可以发送给服务器）<br>测试网站性能<br>解密HTTPs的web会话<br>2.原理：Fiddler的工作原理类似于一个代理。因此，在使用中可能会出现网络问题，可以直接关闭或者点击关掉左下角的capture，也要关闭翻墙软件。fiddler的代理模式有两种：<br>流模式：（streaming）实时传送给客户端（更接近于浏览器本身真实的行为）<br>缓冲模式：（buffering）等http请求所有东西都准备好后才返回给应用程序（可控制最后的服务器响应）<br>在Fiddler的工具栏的Stream可以进行两种模式的切换，默认是缓冲模式<br>3.fiddler使用场景：<br>（1）开发环境host配置：<br>通常情况下，配置host需要改变系统文件很不方便，在多个开发环境下切换很低效。fiddler提供了相对高效的host配置方法<br>（2）前后端接口调试：<br>通常情况下，调试前后端的接口需要真是的环境，一大推假数据，写javascript代码。fiddler只需要一个ui界面进行配置即可<br>（3）线上bugfix<br>fiddler可以将发布文件代理到本地，快速定位线上bug<br>（4）性能分析和优化<br>fiddler会提供请求的实际图，清晰明了，网站需要优化的部分<br>4.工具栏常用功能介绍<br>Replay：回放会话，选中会话并按R键即可回放会话（可多条），清空监控面板，快捷键ctrl+x<br>go：断点调试<br>stream：切换代理模式<br>Decode：解压请求<br>keep all session选项可选保存会话的数量，默认的保存所有，保存的会话越多，fiddler占用的内存越大，可以设置下，而且调试也不希望看到太多会话，可以根据需要清空监控面板或过滤请求<br>All Process：可以用来控制如只捕获chrome浏览器的请求<br>Find：可以查找会话并选择颜色高亮标明<br>TextWizard：解码/编码功能，可选选项很多，避免去网上找解码工具<br>5.状态栏<br>Capture用来控制Fiddler是否工作，点击即可切换状态<br>All Process控制请求来源<br>旁边的数字代表当前会话数量<br>6.命令行<br>help<br>cls    清屏  (Ctrl+x 也可以清屏)<br>select  选择会话的命令<br>?.png  用来选择png后缀的图片<br>bpu  截获request<br>7.右侧窗口功能<br>（1）Statistics： 一个会话的统计信息，可以为优化提供依据，rtt表示一次往返时间<br>（2）Inspectors： 对请求进行解包，可以查看相应的请求，响应信息<br>（3）AutoResponder： 文件代理，可以把请求的资源用本地文件代理掉，方便调试线上bug文件<br>Fiddler的AutoResponder tab允许你从本地返回文件，而不用将http request 发送到服务器上。<br>打开Fiddler把这个文件所在的会话拖到AutoResponer Tab下<br>选择Enable automatic reaponses和Unmatched requests passthrough<br>在下面的Rule Editor下面选择 Find a file… 选择本地保存的图片，最后点击Save保存下。<br>刷新页面，你可以看到请求的文件是本地的。<br>（4）Composer： 前后端端口连调，可以用来伪造请求<br>（5）Log： 记录日志<br>（6）Timeline：网站性能分析<br>8.fiddler插件<br>Fiddler Add-ons 插件：javaScript formatter -&gt; 对关于js文件右击 -&gt; 选择 -&gt; make javascript pretty -&gt; textview / syntaxview 代码全部高亮<br>traffic differ（对比两个不同的会话）： 直接拖进两个不同的请求，会显示完整的对比数据 -&gt; 可以用来对比优化前后的不同<br>willow -&gt; 快速管理host列表 完全可视化 http代理插件 可视化限速<br>9.高级应用<br>网速限速<br>10.tips<br>（1）chrome和firefox浏览器无法被监听<br>fiddler安装之后，默认会在IE浏览器中安装一个fiddler的插件，所以它对IE及国内基于IE内核的各类浏览器都能实现监听，但其他内核的浏览器无法被监听。<br>解决办法：禁用chrome和firefox中具有代理功能的插件，比如chrome如果安装了switchSharp，禁用它或选择“使用系统代理设置”，或在switchSharp中新配置一个代理项（比如名为fiddler，用于指向代理127.0.0.1，端口8888），即可实现监听。<br>（2）抓取HTTPS包<br>这里默认的只会抓取HTTP请求包，如果也要抓取HTTPS包，则在HTTPS标签栏里设置，把Capture HTTPS CONNECTs选项勾上。<br>（3）真机调试<br>首先我们打开Fiddler -&gt; Tools-&gt;Fiddler Options在Connection面板里将Allow remote computers to connect勾选起来，确定后，关闭Fiddler并重新打开Fiddler。<br>然后把手机端的代理设置为Fiddler的代理，代理设置需要一个ip和一个端口，ip就是Fiddler所运行的电脑的局域网ip地址，端口默认是Fiddler代理的端口，请确保手机所在的网段可以访问到电脑所在的网段，同一个局域网里一般没什么问题。<br>（4）设置断点了<br>设置好断点后，你可以修改httpRequest 的任何信息包括host, cookie或者表单中的数据。设置断点有两种方法<br>第一种：打开Fiddler 点击Rules -&gt; Automatic Breakpoint -&gt; Before Requests(这种方法会中断所有的会话)<br>如何消除命令呢？点击Rules -&gt; Automatic Breakpoint -&gt;Disabled<br>第二种:  在命令行中输入命令: bpu <a href="http://www.baidu.com/">www.baidu.com</a> (这种方法只会中断<a href="http://www.baidu.com/">www.baidu.com</a>)<br>如何消除命令呢？在命令行中输入命令 bpu</p>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机 </tag>
            
            <tag> 前端 </tag>
            
            <tag> fiddler </tag>
            
            <tag> 调试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>张鑫旭CSS深入系列学习总结</title>
      <link href="/posts/37668.html"/>
      <url>/posts/37668.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><a href="http://www.zhangxinxu.com/wordpress/">大神博客地址</a></p><h2 id="float浮动"><a href="#float浮动" class="headerlink" title="float浮动"></a>float浮动</h2><h3 id="浮动的设计初衷仅仅是为了文字环绕效果"><a href="#浮动的设计初衷仅仅是为了文字环绕效果" class="headerlink" title="浮动的设计初衷仅仅是为了文字环绕效果"></a>浮动的设计初衷仅仅是为了文字环绕效果</h3><h3 id="浮动的特性：包裹和破坏"><a href="#浮动的特性：包裹和破坏" class="headerlink" title="浮动的特性：包裹和破坏"></a>浮动的特性：包裹和破坏</h3><p>包裹：<br>1.收缩 水平方向<br>2.坚挺 垂直方向<br>3.隔绝 BFC<br>具有包裹性的其他小伙伴：<br>display: inline-block,table-cell,…<br>position: absolute(近亲),fixed,sticky,…<br>overflow: hidden/scroll<br>破坏：父元素高度塌陷<br>display: none<br>position: absolute,fixed,sticky</p><h3 id="浮动是魔鬼，更是情非得已"><a href="#浮动是魔鬼，更是情非得已" class="headerlink" title="浮动是魔鬼，更是情非得已"></a>浮动是魔鬼，更是情非得已</h3><p>浮动使高度塌陷不是bug，而是标准（是为了实现文字环绕效果）</p><h3 id="清除浮动：清除浮动带来的效果"><a href="#清除浮动：清除浮动带来的效果" class="headerlink" title="清除浮动：清除浮动带来的效果"></a>清除浮动：清除浮动带来的效果</h3><p>两种方法：<br>1.脚底插入clear:both（只是搭桥，可以与外部发生外边距重叠）<br>2.父元素BFC（IE8+）或haslayout（IE6/IE7），封闭，不与外界联系<br>clear:both<br>1.html block水平元素底部走起，如<div></div><br>2.css after伪元素底部生成<br>.clearfix:after{content: “”;display: table;clear: both;}<br>.clearfix{*zoom: 1;}</p><h3 id="浮动的滥用"><a href="#浮动的滥用" class="headerlink" title="浮动的滥用"></a>浮动的滥用</h3><p>1.元素的block块状化<br>2.破坏性造成的紧密排列特性（去空格化，空格也是字符，浮动使字符移动到一边），因此常被用来砌砖头<br>砌砖布局的问题<br>1.妙脆角——嘎吱脆——容错性比较糟糕，容易出问题<br>2.吝啬鬼——重用废——需要固定尺寸<br>3.洋葱头——IE7飙泪——低版本问题多<br>ele.style[“cssFloat” in trigger.style?”cssFloat”:”styleFloat”] = ‘left’;<br>获取最终样式：display = this.currentStyle?this.currentStyle.display:window.getComputedStyle(this,null).display;</p><h3 id="浮动与流体布局"><a href="#浮动与流体布局" class="headerlink" title="浮动与流体布局"></a>浮动与流体布局</h3><p>1.文字环绕衍生——单侧固定<br>width+float和padding-left/margin-left<br>2.不改变BOM位置的单侧固定流体布局<br>要在外面加一层：width:100%+float<br>内部：padding-right/margin-right和width+float+margin负值(将自己移上来)<br>3.高级进化-智能自适应尺寸（一侧改变宽度另一侧自动适应）<br>float和display:table-cell(IE8+)/display:inline-block(IE7)</p><pre><code>.left &#123; float: left; margin-right: 20px; &#125;.right &#123; display: table-cell; *display: inline-block; width: 2000px; *width: auto; &#125;</code></pre><p>流体布局常采用宽度分离原则：易维护<br>margin-left: -100%的原理：浮动元素，只有在位置不够的时候才会被挤到第二行，而这能给元素一个位置，恰能到达窗口最左侧</p><h1 id="float兼容性"><a href="#float兼容性" class="headerlink" title="float兼容性"></a>float兼容性</h1><p>1.让IE7飙泪的问题<br>含clear的浮动元素包裹不正确的问题；<br>浮动元素倒数2个莫名垂直间距问题；<br>浮动元素最后一个字符重复问题；<br>浮动元素楼梯排列问题；<br>浮动元素和文本不在同一行的问题；</p><h2 id="absolute"><a href="#absolute" class="headerlink" title="absolute"></a>absolute</h2><h3 id="absolute与float"><a href="#absolute与float" class="headerlink" title="absolute与float"></a>absolute与float</h3><p>相同的特性表现：包裹和破坏<br>兄弟关系：页面可相互转化</p><h3 id="absolute与relative"><a href="#absolute与relative" class="headerlink" title="absolute与relative"></a>absolute与relative</h3><p>是分离的、对立的，不是兄弟关系！<br>absolute越独立越强大<br>超越overflow：独立的absolute可以摆脱overflow的限制，无论是滚动还是隐藏</p><h3 id="无依赖的absolute定位"><a href="#无依赖的absolute定位" class="headerlink" title="无依赖的absolute定位"></a>无依赖的absolute定位</h3><p>不受relative限制的absolute定位，行为表现上是不使用top/left/bottom/right/任何属性或使用auto作为值<br>定位的行为表现<br>1.脱离文档流<br>2.折翼的天使：去浮动、位置跟随<br>IE7永远的inline-block水平<br>配合margin的精确定位，这是不影响其他布局的绝对定位下的相对定位之王</p><h3 id="强大的折翼天使"><a href="#强大的折翼天使" class="headerlink" title="强大的折翼天使"></a>强大的折翼天使</h3><p>1.图片、图标绝对定位覆盖（利用跟随性，更易维护），用<!-- -->去掉换行之间的空格<br>2.下拉框定位最佳实践<br>3.居中以及边缘对齐定位<br>text-align:center + &nbsp;和自身absolute及margin-left:负的自身宽度的一半<br>边缘对齐：</p><pre><code>&lt;div class=&quot;wrap&quot;&gt;    &lt;div class=&quot;center&quot;&gt;&lt;/div&gt;    &lt;div class=&quot;parent&quot;&gt;          &amp;nbsp;&lt;div class=&quot;child&quot;&gt;123&lt;/div&gt;    &lt;/div&gt;  &lt;/div&gt;</code></pre><p>CSS</p><pre><code>.wrap&#123;      width: 1200px;       max-width: 80%;       margin-left: auto;      margin-right: auto;&#125;.center&#123;     width: 100%;      height: 500px;      background: #f00;&#125;.parent&#123;      height: 0;      overflow: hidden;      text-align: right;&#125;.child&#123;      display:inline;      margin-left: 20px;      position: fixed;      bottom: 100px;&#125;</code></pre><p><a href="http://jsbin.com/zidomo/1/edit?html,css,output">demo</a><br>4.各种对齐<br>*号对齐<br>图文混排<br>溢出</p><h3 id="absolute和层级"><a href="#absolute和层级" class="headerlink" title="absolute和层级"></a>absolute和层级</h3><p>动画尽量作用在绝对定位元素上<br>如果非弹窗类的元素z-index&gt;2，必定有冗余，请优化</p><h3 id="absolute和天使的翅膀"><a href="#absolute和天使的翅膀" class="headerlink" title="absolute和天使的翅膀"></a>absolute和天使的翅膀</h3><h3 id="absolute与width和height"><a href="#absolute与width和height" class="headerlink" title="absolute与width和height"></a>absolute与width和height</h3><p>.overlay{<br>    position: absolute;<br>    left: 0;<br>    right: 0;<br>    top: 0;<br>    bottom: 0;<br>}<br>left、right与width，top、bottom与height相互替代性<br>绝对定位方向是对立的，left:0;right:0;会进行暴力拉伸<br>absolute的翅膀拉伸和width/height是可以相互替代的<br>position:absolute;left:0;top:0;width:50%; = position:absolute;left:0;top:0;right:50%;<br>暴力拉伸支持IE7+<br>差异所在：拉伸更强大，width只能使用CSS3 calc计算<br>相互支持性<br>1.容器无需固定width/height值，内部元素亦可拉伸<br>2.容器拉伸，内部元素支持百分比width/height值<br>元素百分比height要想其作用，通常需要父级容器的height值不是auto<br>相互合作性：当尺寸限制、拉伸以及margin:auto同时出现时，会有绝对定位元素的绝对居中效果（IE8+）</p><h3 id="absolute与整体页面布局"><a href="#absolute与整体页面布局" class="headerlink" title="absolute与整体页面布局"></a>absolute与整体页面布局</h3><p>1.body降级、子元素升级<br>升级的子div满屏走起<br>.page{position: absolute;left:0;right:0;top:0;bottom:0;}<br>绝对定位受限于父级，因此需要html,body{height:100%;}<br>2.各模块——各居其位<br>3.内容区域想象成body，避免了移动端position：fixed问题<br>4.全屏覆盖与page平级，可以用来移动端上、下固定的整体布局</p><h2 id="overflow"><a href="#overflow" class="headerlink" title="overflow"></a>overflow</h2><h3 id="overflow基本属性"><a href="#overflow基本属性" class="headerlink" title="overflow基本属性"></a>overflow基本属性</h3><p>visible,hidden,scroll,auto,inherit<br>overflow-x和overflow-y(IE8+)，值相同时，为值属性，当一个为visible，一个为hidden或scroll或auto时，会重置为auto<br>兼容性<br>1.燕肥环瘦，各有千秋<br>2.宽度设定机制（IE7 width:100%出现水平滚动条）<br>作用的前提<br>1.非display:inline水平<br>2.对应方位的尺寸限制：width/height/max-width/max-height/absolute拉伸<br>3.对应td等，还需要设置table为table-layout:fixed</p><h3 id="overflow与滚动条"><a href="#overflow与滚动条" class="headerlink" title="overflow与滚动条"></a>overflow与滚动条</h3><p>无论什么浏览器，默认滚动条均来自html标签,而不是body标签<br>body默认0.5em margin值<br>IE7默认：html{overflow-y:scroll;}<br>IE8+等浏览器默认：html{overflow:auto;}<br>去除页面默认滚动条，只需要html{overflow:hidden;}<br>滚动高度：<br>chrome：document.body.scrollTop;<br>其他：document.documentElement.scrollTop;<br>overflow的padding-bottom缺失现象：chrome不缺失，其他缺失，导致scrollHeight不一样<br>滚动条水平宽度：<br>overfl:auto的潜在布局隐患：因为滚动条会占用容器尺寸<br>水平居中的跳动问题<br>1.html{overflow-y:scroll;}<br>2..container{padding-left:calc(100vm - 100%);}(IE9+)<br>自定义滚动条-webkit<br>::-webkit-scrollbar{ /<em>血槽宽度</em>/<br>    width: 8px;<br>    height: 8px;<br>}<br>::-webkit-scrollbar-thumb{ /<em>拖动条</em>/<br>    background-color: raba(0,0,0,.3);<br>    border-radius: 6px;<br>}<br>::-webkit-scrollbar-track{ /<em>背景槽</em>/<br>    background-color: #ddd;<br>    border-radius: 6px;<br>}<br>自定义滚动条——IE（丑到爆，用<a href="https://github.com/malihu/malihu-custom-scrollbar-plugin">插件</a>）<br>IOS原生滚动回弹效果-webkit-overflow-scrolling:touch;</p><h3 id="overflow与BFC"><a href="#overflow与BFC" class="headerlink" title="overflow与BFC"></a>overflow与BFC</h3><p>visible不触发，其他3个触发<br>1.清除浮动影响<br>2.避免margin穿透问题（指子元素margin穿透父级元素）<br>3.两栏自适应：左浮动，右overflow<br>使用padding做流体自适应布局时，万万不可让自适应层BFC化<br>.cell{overflow:hidden;_display:inline-block;}副作用明显，无法广泛应用，因此最常用：<br>.cell{display:table-cell;width: 2000px;*display:inline-block;*width:auto;}</p><h3 id="overflow与绝对定位"><a href="#overflow与绝对定位" class="headerlink" title="overflow与绝对定位"></a>overflow与绝对定位</h3><p>overflow:hiddenshi失效、overflow滚动失效<br>w3c官方文档是这样解释的：绝对定位元素不总是被父级overflow属性裁剪，尤其是当overflow在绝对定位元素及其包含块之间的时候<br>如何避免失效：<br>1.overflow元素自身为包含块<br>2.overflow元素的子元素为包含块<br>3.任意合法transform声明当做包含块（仅做了解）<br>overflow失效的利用</p><h3 id="依赖overflow的样式表现"><a href="#依赖overflow的样式表现" class="headerlink" title="依赖overflow的样式表现"></a>依赖overflow的样式表现</h3><p>1.css resize:both/horizontal/vertical<br>textarea自带resize特性，因为自带overflow:auto，默认17px*17px<br>2.text-overflow:ellipsis;</p><h3 id="overflow与锚点技术"><a href="#overflow与锚点技术" class="headerlink" title="overflow与锚点技术"></a>overflow与锚点技术</h3><p>锚链：hash（url中#）<br>锚点<br>锚点定位的本质就是：“滚床单”——改变容器的滚动高度<br>1.容器可滚动<br>2.锚点元素在容器内<br>锚点定位的触发：<br>1.url地址中的锚链与锚点元素<br>2.可focus的锚点处于focus状态<br>锚点定位的作用:<br>1.快速定位<br>2.锚点定位与overflow选项卡技术（适应单页，无滚动）</p><h2 id="line-height"><a href="#line-height" class="headerlink" title="line-height"></a>line-height</h2><h3 id="line-height的定义"><a href="#line-height的定义" class="headerlink" title="line-height的定义"></a>line-height的定义</h3><p>行高：两行文字基线（baseline）之间的距离<br>1.什么是基线：baseling，英文字母x下边沿位置<br>2.为什么是基线：可以是基线，但基线乃任意线之根本<br>3.有字母基线、悬挂基线、表意基线（中文）等<br>基线与字体有关，微软雅黑偏下<br>单行文本用line-height看似居中，实际未居中，字体越大差异越明显</p><h3 id="line-height与行内框盒子模型"><a href="#line-height与行内框盒子模型" class="headerlink" title="line-height与行内框盒子模型"></a>line-height与行内框盒子模型</h3><p>1.内容区域（context area）是一种围绕文字看不见的盒子，与font-size大小相关<br>2.内联盒子（inline boxes），如果外部含inline水平的标签，则属于内联盒子，如果是一个光秃秃的文字，则属于匿名内联盒子<br>3.行框盒子（line boxes），每一行就是一个行框盒子，由内联盒子组成<br>4.包含盒子（containing box），由行框盒子组成</p><h3 id="line-height的高度机理"><a href="#line-height的高度机理" class="headerlink" title="line-height的高度机理"></a>line-height的高度机理</h3><p>内联元素的高度由行高决定，不是文字撑起的<br>1.行高由于其继承性，影响无处不在，即使单行文本也不例外<br>2.行高只是幕后黑手，高度的表现不是行高，而是内容区域和行间距<br>行高 = 内容区域 + 行间距<br>内容区域高度只与字体和字号有关，与line-height无关<br>在simsun（宋体）字体下，内容区域高度等于文字大小值<br>simsun字体下，font-size + 行间距 = line-height<br>行间距 = line-height - context area<br>行高决定内联盒子高度，行间距墙头草，可大可小（甚至负值），保证高度正好等于行高</p><h3 id="line-height各类属性值"><a href="#line-height各类属性值" class="headerlink" title="line-height各类属性值"></a>line-height各类属性值</h3><p>1.normal：默认属性值，跟着用户的浏览器走，且与元素字体关联<br>微软雅黑 normal chrome 1.32左右<br>宋体  normal chrome 1.14左右<br>在各浏览器中不一致，因此要在body中重置<br>2.number，length，percent，inherit（IE8+)<br>line-height:1.5 所有可继承元素根据font-size重新计算行高<br>line-height:150%/1.5em 当前元素根据font-size计算行高，继承给下面的元素<br>推荐number：<br>body{font-size:14px;line-height:4.1286;}——匹配20px，重阅读可以1.5，1.6</p><h3 id="line-height与图片的表现"><a href="#line-height与图片的表现" class="headerlink" title="line-height与图片的表现"></a>line-height与图片的表现</h3><p>行高不会影响图片实际占据的高度<br>图片混排，可以感性认为与隐匿文本节点基线对齐<br>如何消除图片底部间隙？<br>1.图片块状化——无基线对齐img{display:block;}<br>2.图片底线对齐——img{vertical-align:middle;}<br>3.行高足够小——.box{line-height:0;}<br>小图片和大文字，基本上高度受行高控制</p><h3 id="line-height的实际应用"><a href="#line-height的实际应用" class="headerlink" title="line-height的实际应用"></a>line-height的实际应用</h3><p>1.图片水平居中(近似)：vertical-align:middle IE8+<br>2.多行文本垂直居中<br>.box{line-height: 200px;}<br>.text{display: inline-block;line-height: normal;text-aling: left;vertical-align: middle;max-width: 100%;}<br><a href="http://jsbin.com/jewuris/1/edit?html,css,output">查看demo</a><br>{height: 36px; line-height: 36px;}前一个多余（其实应该是不一定，至少overflow:hidden时可能line-height多余，可能都要）</p><h2 id="vertical-align"><a href="#vertical-align" class="headerlink" title="vertical-align"></a>vertical-align</h2><h3 id="基本认识"><a href="#基本认识" class="headerlink" title="基本认识"></a>基本认识</h3><p>inherit<br>线类：baseline（默认）、top、middle、bottom<br>文本类：text-top、text-bottom<br>上标、下标类：sub、super<br>数值百分比类：20px、2em、20%（在basseling对齐的基础上再移动相应距离，支持负值）<br>vertical-align的百分比值是相对于line-height计算的</p><h3 id="vertical-align起作用的前提"><a href="#vertical-align起作用的前提" class="headerlink" title="vertical-align起作用的前提"></a>vertical-align起作用的前提</h3><p>应用于inline水平元素以及table-cell元素<br>默认inline水平元素：img，span,strong,em,未知元素<br>默认inline-block元素：input(IE8+),button(IE8+)<br>默认table-cell元素：td<br>所以默认状态下，可以应用vertical-align的有：图片、按钮、文字、单元格<br>改变元素状态：<br>1.直接display设置<br>2.css声明间接设置（浮动、绝对地位）<br>注意能应用vertical-align时也不一定能居中，如<br>.wrap{height: 300px;border: 1px solid;}<br>.wrap img{vertical-align: middle;}<br>还是需要给wrap设置line-height<br>还需注意display:table-cell元素，需要vertical-align:middle作用于自身，如下设置在img上无效<br>.wrap{height: 300px;display: table-cell;border: 1px solid;}<br>.wrap img{vertical-align: middle;}<br>实例：个数不定文字内容和图片垂直居中</p><pre><code>.wrap&#123;  border-bottom: 1px solid;  width: 300px;  padding: 20px 10px;&#125;.wrap span&#123;  width: 200px;  display: inline-block;  vertical-align: middle;&#125;.wrap img&#123;  vertical-align: middle;&#125;</code></pre><p><a href="https://jsbin.com/buyago/1/edit?html,css,output">查看demo</a></p><h3 id="vertical-align与line-height"><a href="#vertical-align与line-height" class="headerlink" title="vertical-align与line-height"></a>vertical-align与line-height</h3><p>vertical-align的百分比是相对于line-height计算的<br>对于内联元素，vertical-align与line-height虽然看不见，但实际上处处都是<br>近似垂直居中：vertical-align:middle;</p><pre><code>&lt;span class=&quot;baseline&quot;&gt;&lt;/span&gt;&lt;span class=&quot;baseline&quot;&gt;x-baseline&lt;/span&gt;.baseline&#123;  height: 150px;  width: 150px;  display: inline-block;  background: #ccc;&#125;</code></pre><p><a href="https://jsbin.com/julobem/1/edit?html,css,output">查看对齐情况</a><br>根据css2的可视化格式模型文档：inline-block的基线是正常流最后一个line box的基线，除非这个line box里面既没有line boxes（line box是空的）或者本身overflow属性的计算值不是visible，这种情况下基线是margin底边缘<br>设置line-height:0，会再下沉，因为字符高度为0，实际占据的高度为0，高度区域为字符串垂直中心线，盒子上边缘为1/2x高度处<br>text-align:justify任意数目列表两端对齐<br>下方空白一般可以通过line-height:0;vertical-align:top;一起解决</p><h3 id="vertical-align线性类属性值"><a href="#vertical-align线性类属性值" class="headerlink" title="vertical-align线性类属性值"></a>vertical-align线性类属性值</h3><p>1.vertical-align:bottom的定义<br>inline/inline=block元素：元素底部和整行的底部对齐<br>table-cell元素：单元格底padding边缘和表格行的底部对齐<br>2.vertical-align:top的定义<br>inline/inline=block元素：元素顶部和整行的顶部对齐<br>table-cell元素：单元格上padding边缘和表格行的顶部对齐<br>3.vertical-align:middle的定义<br>inline/inline=block元素：元素的垂直中心点和父元素基线上1/2x height对齐<br>table-cell元素：单元格填充盒子相对于外面的表格行居中对齐<br>字符的中心不是x文字的中心（因为字符有下沉效应，不同字体下沉程度不一致），即context area高度的中心线和基线上1/2x height线不对齐，所以img要完全居中，还需要设置font-size:0;</p><h3 id="vertical-align文本类"><a href="#vertical-align文本类" class="headerlink" title="vertical-align文本类"></a>vertical-align文本类</h3><p>与前后元素无关，与line-height无关，只与font-size有关<br>text-top:盒子的顶部和父级content area的顶部对齐<br>text-bottom:盒子的底部和父级content area的底部对齐<br>实际作用：表情图片（或原始尺寸背景图标）与文字的对齐效果<br>1.使用顶部/底线的问题在于受其他内联元素的影响<br>2.使用中线也不错，但需要恰好的字体大小<br>3.使用文本底部较合适，不受行高及其他内联元素影响<br>###vertical-align上标、下标类<br>sup标签 vertical-align: super;<br>sub标签vertical-align: sub;</p><h3 id="vertical-align前后不一的作用机制"><a href="#vertical-align前后不一的作用机制" class="headerlink" title="vertical-align前后不一的作用机制"></a>vertical-align前后不一的作用机制</h3><p>关注当前元素和父级，前后并没有直接影响<br><a href="https://jsbin.com/suwebu/2/edit?html,css,output">查看demo</a><br>近似垂直居中：</p><pre><code>p&#123;line-height: 200px;&#125;p img&#123;vertical:middle;&#125;p img::after&#123;content:&#39;&#39;,vertical-align:middle;&#125;</code></pre><h3 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h3><p>IE7有很多兼容性问题，可以认为IE7下图文一体（后面文字套层span标签，并display:inline-block可解决），middle解释有问题</p><h3 id="vertical-align的实际应用"><a href="#vertical-align的实际应用" class="headerlink" title="vertical-align的实际应用"></a>vertical-align的实际应用</h3><p>1.小图标和文字的对齐<br>vertical-align负值，无兼容性问题<br>2.不定尺寸图片或多行文本的垂直居中<br>主体元素inline-block<br>0宽度100%高度辅助元素<br>vertical-align:middle;</p><pre><code>&lt;div class=&quot;parent&quot;&gt;    &lt;div class=&quot;vertical-center&quot;&gt;        &lt;p&gt;文字&lt;/p&gt;        &lt;p&gt;文字&lt;/p&gt;        &lt;p&gt;文字&lt;/p&gt;        &lt;p&gt;文字&lt;/p&gt;    &lt;/div&gt;    &lt;i&gt;&lt;/i&gt;&lt;/div&gt;.parent&#123;  height: 200px;  background: #ccc;  text-align: center;&#125;.parent .vertical-center&#123;  display: inline-block;  vertical-align: middle;&#125;.parent i&#123;  display: inline-block;  height: 100%;  vertical-align: middle;&#125;</code></pre><p><a href="https://jsbin.com/geyiri/1/edit?html,css,output">查看demo</a></p><h2 id="relative"><a href="#relative" class="headerlink" title="relative"></a>relative</h2><h3 id="relative与absolute"><a href="#relative与absolute" class="headerlink" title="relative与absolute"></a>relative与absolute</h3><p>限制作用<br>1.限制left/top/right/bottom定位<br>2.限制z-index层级，当relative层级不是auto时，里面的absolute层级不起作用<br>3.限制在overflow下的嚣张气焰，防止absolute超出<br>对于fixed元素只能限制z-index层级</p><h3 id="relative与定位"><a href="#relative与定位" class="headerlink" title="relative与定位"></a>relative与定位</h3><p>1.相对自身<br>2.无侵入：不影响其他元素，可以用于自定义拖动<br>top和bottom同时存在，top优先级高<br>left和right同时存在，left优先级高</p><h3 id="relative与z-index层级"><a href="#relative与z-index层级" class="headerlink" title="relative与z-index层级"></a>relative与z-index层级</h3><p>1.提高层叠上下文：如果有两张图片层叠在一起，像让下面的图片放到上面来，就可以设置下面的图片的position为relative<br>2.新建层叠上下文与层级控制：如果子元素设置了absolute，z-index：4；父元素设置了relative，z-index：1；另外一个子元素设置了absolute，z-index：2；父元素设置了relative，z-index：3；则结果会使后者显示在上面<br>将父元素的z-index：auto是不会限制内部absolute元素层叠问题，不包括IE6/IE7</p><h3 id="relative的最小化影响原则"><a href="#relative的最小化影响原则" class="headerlink" title="relative的最小化影响原则"></a>relative的最小化影响原则</h3><p>指的是尽量降低relative对其他元素的影响<br>1.尽量避免使用relative：absolute定位不依赖relative<br>2.relative最小化原则：放在空div里</p><h2 id="z-index"><a href="#z-index" class="headerlink" title="z-index"></a>z-index</h2><h3 id="z-index基础"><a href="#z-index基础" class="headerlink" title="z-index基础"></a>z-index基础</h3><p>z-index:auto 或者 整数值 inherit<br>1.支持负值<br>2.支持css3 animation动画<br>3.在css2.1时代，需要和定位元素配合使用</p><h3 id="z-index与定位元素"><a href="#z-index与定位元素" class="headerlink" title="z-index与定位元素"></a>z-index与定位元素</h3><p>z-index在定位元素中起作用<br>z-index:auto近似z-index:0<br>原则:谁大谁上，祖先优先<br>如果定位元素z-index没有发生嵌套：<br>a.后来者居上<br>b.谁大谁上<br>如果定位z-index发生嵌套：祖先优先（前提是z-index是数值，不是auto），按照祖先的层级再遵循a，b规则<br>z-index:auto当前层叠上下文的生成盒子层叠水平是0，盒子（除非是根元素）不会创建一个新的层叠上下文<br>3.层叠上下文和层叠水平<br>stacking context（层叠上下文）：是html中的一个三维概念，意味着元素在z轴（人的视线穿过显示器的直线轴）上可以“高人一等”<br>1、页面根元素具有层叠上下文<br>2、z-index值为数值时也具有层叠<br>3、其他属性<br>层叠水平：stacking leavel层叠上下文中的每个元素都有一个层叠水平，决定了同一个层叠上下文中元素在z轴上的显示顺序。遵循谁大谁上，后来居上的层叠原则<br>层叠水平与z-index区别：<br>普通元素也有层叠水平<br>z-index只在定位元素起作用<br>层叠上下文特性：<br>1.层叠上下文可嵌套成一个分层次的层叠上下文<br>2.层叠上下文与兄弟元素独立。层叠上下文变化渲染，只考虑后代元素<br>3.每个层叠上下文自成体系：被层叠后，元素被认为在父层层叠顺序中</p><h3 id="层叠顺序"><a href="#层叠顺序" class="headerlink" title="层叠顺序"></a>层叠顺序</h3><p>层叠顺序（stacking order）表示元素发生层叠时候有着特定的垂直显示顺序<br>著名的七阶层叠水平(stacking level)<br>从低到高：层叠上下文background/border,负z-index,block块状水平盒子,float浮动盒子,inline/inline-block水平盒子,z-index:auto或看成z-index:0,正z-index<br>1.意义：规范元素重叠时的呈现规则<br>2.为什么？<br>更符合页面加载的功能和视觉呈现，装饰——布局——内容<br>内容是页面最重要的实体，因此层叠水平要高<br><a href="https://jsbin.com/qehatom/1/edit?html,css,output">查看demo</a><br>demo解释：背景色覆盖是层叠顺序，文字覆盖是后来居上（因为文字是inline水平的，和inline-block平级）</p><h3 id="z-index与层叠上下文"><a href="#z-index与层叠上下文" class="headerlink" title="z-index与层叠上下文"></a>z-index与层叠上下文</h3><p>1.定位元素默认z-index:auto，可以看成是z-index:0;<br>2.z-index不为auto的定位元素会创建层叠上下文；<br>3.z-index层叠顺序的比较止步于父级层叠上下文<br>从层叠顺序上讲，z-index可以看成z-index，但是从层叠上下文来讲，两者有着本质区别（但不包括IE7）<br>z-index:auto 不会创建层叠山下文<br>z-index:0 会创建<br>如果不创建层叠上下文，默认为根元素<br><a href="https://jsbin.com/xipiye/1/edit?html,css,output">查看demo</a></p><h3 id="其他属性和层叠上下文"><a href="#其他属性和层叠上下文" class="headerlink" title="其他属性和层叠上下文"></a>其他属性和层叠上下文</h3><p>1.z-index值不为auto的flex项（父元素display：flexinline-flex）。<br>2.元素的opacity值不是1.<br>3.元素的transform值不是none。<br>4.元素mix-blend-mode值不是normal，<br>5.元素的filter值不是none。<br>6.元素的isolation值不是isolate。<br>7.position：fixed声明（chrome等blink/webkit内核）<br>8.will-change指定的属性值为上面任意一个<br>9.元素的-webkit-overflow-scrolling设为touch</p><h3 id="z-index与其他css属性层叠上下文"><a href="#z-index与其他css属性层叠上下文" class="headerlink" title="z-index与其他css属性层叠上下文"></a>z-index与其他css属性层叠上下文</h3><p>1.不支持z-index的层叠上下文元素层叠顺序均是z-index:auto级别<br>2.依赖z-index的层叠上下文元素的层叠顺序取决于z-index值<br>（1）position:relative/absolute/fixed（部分浏览器）<br>（2）display:flex/inline-flex值的子元素flex项<br>常见淡入动画文字变化</p><h3 id="相关实践分享"><a href="#相关实践分享" class="headerlink" title="相关实践分享"></a>相关实践分享</h3><p>1.最小化影响原则<br>2.不犯二准则<br>3.组件层级计算器<br>4.可访问性隐藏<br>（1）最小化影响原则<br>目的：避免z-index嵌套混乱<br>原因：元素的层叠水平主要是由所在的层叠上下文决定的，IE7 z-index:auto也会创建层叠上下文<br>做法：避免使用定位属性，定位属性从大容器平级分离为私有小容器<br>（2）不犯二准则<br>避免z-index混乱，一山比一山高的样式问题<br>原因：多人协作以及后期维护<br>做法：对非浮层元素，避免设置z-index值，z-index值没有任何道理需要超过2<br>（3）组件层级计数器<br>目的：避免浮层组件因z-index被覆盖的问题<br>原因：总会遇到意想不到的高层级元素，组件的覆盖规则具有动态性<br>做法：组件层级计数器<br>通过js获取body下子元素的最大z-index值<br>（4）负值z-index与可访问性隐藏<br>text-indent: -9999px;clip剪裁等可以进行可访问性隐藏<br>人肉眼不可见，但是辅助设备可识别</p><pre><code>&lt;form&gt;    &lt;input type=&quot;text&quot;&gt;    &lt;input type=&quot;submit&quot; id=&quot;submit&quot;&gt;    &lt;label for=&quot;submit&quot;&gt;提交&lt;/label&gt;&lt;/form&gt;[type=submit]&#123;    position: absolute;    z-index: -1;&#125;</code></pre><p>可以避免submit的复杂样式兼容问题，高级浏览器可直接display:none</p><h2 id="margin"><a href="#margin" class="headerlink" title="margin"></a>margin</h2><h3 id="margin与容器的尺寸"><a href="#margin与容器的尺寸" class="headerlink" title="margin与容器的尺寸"></a>margin与容器的尺寸</h3><p>可视尺寸-clientWidth(标准)；<br>占据尺寸，可以理解为outerWidth（yy，非标准，jquery有）<br>margin与可视尺寸：<br>1.适用于没有设定width/height的普通block水平元素，float元素、absolute/fixed元素等不可以<br>2.只适用于水平方向<br>应用：单侧顶宽的自适应布局<br>margin与占据尺寸<br>1.block、inline-block水平元素均适用<br>2.与有没有设定width/height无关<br>3.适用于水平方向和垂直方向<br>应用：滚动容器内上下留白，非chrome浏览器容器加padding底部无留白，overflow那节有讲</p><h3 id="css-margin与百分比单位"><a href="#css-margin与百分比单位" class="headerlink" title="css margin与百分比单位"></a>css margin与百分比单位</h3><p>普通元素的百分比margin的计算规则：都是相对于容器的宽度计算的<br>绝对定位元素的百分比margin：是相对于第一个定位祖先元素（relative/absolute/fixed）的宽度计算的<br>应用：如宽高2:1的自适应矩形<br><a href="https://jsbin.com/denuvov/1/edit?html,css,output">查看demo</a></p><h3 id="margin重叠"><a href="#margin重叠" class="headerlink" title="margin重叠"></a>margin重叠</h3><p>margin重叠通常特性<br>1.block水平元素（不包括float和absolute元素）<br>2.不考虑writing-mode，只发生在垂直方向上<br>margin重叠3种情境<br>1.相邻的兄弟元素<br>2.父级和第一个/最后一个子元素<br>3.空的block元素</p><pre><code>&lt;div class=&quot;father&quot; style=&quot;background: #ccc;overflow: hidden;&quot;&gt;    &lt;div class=&quot;child&quot; style=&quot;margin: 1em 0;&quot;&gt;&lt;/div&gt;    &lt;!--高度只有1em，而非2em--&gt;&lt;/div&gt;</code></pre><p>父子之间margin-top合并：<br>1.父元素非块级格式化上下文元素<br>2.父元素没有border-top设置<br>3.父元素没有padding-top值<br>4.父元素和第一个子元素没有inline元素分隔<br>父子之间margin-bottom合并：<br>1.父元素非块级格式化上下文元素<br>2.父元素没有border-top设置<br>3.父元素没有padding-top值<br>4.父元素和第一个子元素没有inline元素分隔<br>5.父元素没有height，min-height，max-height等限制<br>margin 计算<br>1、正正取大值；<br>2、正负值相加；<br>3、负负最负值；<br>实践：善用margin层叠</p><pre><code>.list&#123;    margin-top: 15px;    margin-bottom: 15px;&#125;</code></pre><p>更具有健壮性，最后一个元素移除或者位置调换，均不会影响原来的布局</p><h3 id="margin-auto"><a href="#margin-auto" class="headerlink" title="margin:auto"></a>margin:auto</h3><p>自动计算填充剩余空间<br>垂直居中：<br>1.可以writing-model:vertical-lr，更改流为垂直方向，可以垂直居中<br>2.absolue与margin:auto</p><pre><code>.father&#123;  height: 200px;  position: relative;  background-color: #ccc;&#125;.son&#123;  position: absolute;  top: 0;  left: 0;  right: 0;  bottom: 0;  width: 500px;  height: 100px;  background: blue;  margin: auto;&#125;</code></pre><h3 id="css-margin负值定位"><a href="#css-margin负值定位" class="headerlink" title="css margin负值定位"></a>css margin负值定位</h3><p>1.margin负值下的两端对齐：margin改变元素尺寸<br>2.margin 负值下的等高布局：改变元素占据空间<br>注：其实就是所谓的padding补偿法，很大的margin-bottom负值加很大的padding-bottom填充缺失的空间，容器必须设置overflow:hidden,focus时可能有副作用<br>3.margin负值下的两栏自适应布局：元素占据空间随margin移动</p><h3 id="css-margin无效"><a href="#css-margin无效" class="headerlink" title="css margin无效"></a>css margin无效</h3><p>1.inline水平元素垂直方向margin无效<br>两个前提：非替换元素，如不是img元素，正常书写模式（没有设置writing-mode等）<br>2.margin重叠<br>3.display:table-cell与margin，替换元素display:table-cell时margin有效，各浏览器有差异<br>display为table相关类型margin无效<br>4.绝对定位元素的非定位方向margin“无效”，看似无效，实则微妙，其实绝对定位的margin值一直有效，只是不像普通元素那样可以和兄弟元素插科打诨<br>5.鞭长莫及导致的margin无效<br>6.内联特性导致的margin无效</p><pre><code>&lt;div style=&quot;height: 200px;background: #ccc;&quot;&gt;    &lt;img src=&quot;test.jpg&quot; style=&quot;margin-top: -248px;&quot;&gt;&lt;/div&gt;</code></pre><p>内联默认x不能超出容器</p><h3 id="margin-start和margin-end"><a href="#margin-start和margin-end" class="headerlink" title="margin-start和margin-end"></a>margin-start和margin-end</h3><p>正常的流向，margin-start等同于margin-left，两者重叠不累加<br>如果水平流是从右到左的，margin-start等同于margin-right<br>在垂直流下，margin-start等同于margin-top<br>webkit：margin-before，margin-after，margin-collapse</p><h2 id="padding"><a href="#padding" class="headerlink" title="padding"></a>padding</h2><h3 id="padding与尺寸"><a href="#padding与尺寸" class="headerlink" title="padding与尺寸"></a>padding与尺寸</h3><p>对于block水平元素<br>1.padding值暴走，一定会影响尺寸；<br>2.width非auto，padding影响尺寸；<br>3.width为auto或box-sizing为border-box，同时padding值没有暴走，不影响尺寸；<br>对于inline水平元素<br>水平padding影响尺寸，垂直padding不影响尺寸，但是会影响背景色（占据空间）<br>利用：高度可控的分隔线</p><h3 id="padding负值和百分比值"><a href="#padding负值和百分比值" class="headerlink" title="padding负值和百分比值"></a>padding负值和百分比值</h3><p>不支持任何形式的负值<br>padding百分比均是相对于屏幕宽度计算的<br>利用padding轻松实现一个正方形<br>inline水平元素的padding百分比值：<br>1.同样相对于宽度计算<br>2.默认的高度和宽度有差异<br>3.padding会换行<br>空的inline水平元素加padding高度和宽度默认也不相等，inline元素的垂直padding高度会让幽灵空白节点显现，也就是规范中的strut，要把字体的大小设置为0</p><h3 id="标签元素的默认padding"><a href="#标签元素的默认padding" class="headerlink" title="标签元素的默认padding"></a>标签元素的默认padding</h3><p>1.ol/ul：内置padding-left，但单位不是em，是固定的px<br>比较好的实践：padding-left:22px-25px 对齐<br>2.表单内置padding<br>所有浏览器input、textarea输入框内置padding<br>所有浏览器button按钮内置padding<br>部分浏览器select下拉内置padding，如Firefox、IE8+可以设置padding<br>所有浏览器radio/checkbox单复选框无内置padding，设置无效<br>button按钮的padding最难控制，可以用label模拟</p><h3 id="padding与布局"><a href="#padding与布局" class="headerlink" title="padding与布局"></a>padding与布局</h3><p>1.使用百分比单位构建固定比例的布局结构<br>2.配合margin等高布局<br>3.两栏自适应布局，padding可以在父元素也可以在子元素</p>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机 </tag>
            
            <tag> 前端 </tag>
            
            <tag> 积累 </tag>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML5学习总结</title>
      <link href="/posts/57973.html"/>
      <url>/posts/57973.html</url>
      
        <content type="html"><![CDATA[<h2 id="html5与html4区别"><a href="#html5与html4区别" class="headerlink" title="html5与html4区别"></a>html5与html4区别</h2><h3 id="语法的改变"><a href="#语法的改变" class="headerlink" title="语法的改变"></a>语法的改变</h3><p>DOCTYPE声明：&amp;lt!DOCTYPE html&amp;gt</p><p>指定字符编码：&amp;ltmeta charset=”UTF-8”&amp;gt,HTML5开始推荐UTF-8</p><p>所谓的字符是对各种文字和符号的总称，涵盖了各国文字、标点符号、图形符号和数字等。字符集是对多个字符的集合，常用的字符集有ASCII、GB2312、Unicode、ISO等。科学家为了让计算机准确处理各种字符集，需要对字符进行编码，以便计算机能够识别和存储各种文字。</p><p>在HTML5出现之前，浏览器会根据三种方式确认页面的编码方式，按优先级排列如下：<br>1)获取HTTP请求头中的Content-Type字符对于的值。<br>2)使用meta标签声明，语法格式如下：</p><pre><code>&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=utf-8&quot;&gt;</code></pre><p>3)外链资源使用charset属性声明编码格式，如在script标签中使用语法格式如下：</p><pre><code>&lt;script type=&quot;text/javascript&quot; src=&quot;myscript.js&quot; charset=&quot;UTF-8&quot;&gt;&lt;/script&gt;</code></pre><p>HTML5出现后，对字符集的使用做了大量的简化，可以使用以下语法进行字符声明：</p><pre><code>&lt;meta charset=&quot;utf-8&quot;&gt;</code></pre><p>对于日常网站开发，结合HTML5的字符集使用，建议：<br>1)最优先使用HTTP请求头指定编码。<br>2)统一全站字符集编码，HTML5推荐使用UTF-8字符集。<br>3)使用meta标签确认字符集编码，尽可能放在html标签的第一个子元素位置<br>4)第三方引用的脚本，在不确认字符编码时，加上charset属性设置编码格式</p><p>为什么会产生乱码？<br>乱码产生的根本原因是你保存的编码格式和浏览器解析时的解码格式不匹配导致的。<br>乱码一般是英文以外的字符才会出现。</p><p>可以省略标记的元素：<br>1)不允许写结束标记的元素有：area、base、br、col、command、embed、hr、img、input、keygen、link、meta、param、source、track、wbr<br>2)可以省略结束标记的元素有：li、dt、dd、p、rt、rp、optgroup、option、colgroup、thead、tbody、bfoot、tr、td、th<br>3)可以省略全部标记的元素有：html、head、body、colgroup、tbody。</p><p>具有boolean值的属性：对于具有boolean之的属性，例如disabled与readonly等，当只写属性而不指定属性值时，表示属性值为true，如果想要将属性值设为false，可以不使用该属性值。</p><p>属性值可以省略引号</p><h3 id="新增的元素和废除的元素"><a href="#新增的元素和废除的元素" class="headerlink" title="新增的元素和废除的元素"></a>新增的元素和废除的元素</h3><p>新增的元素：section、article、aside、header、hgroup、footer、nav、figure、vedio、audio、embed、mark、progress、time、ruby、rt、rp、wbr、canvas、command、details、datalist、datagrid、keygen、output、source、menu</p><p>新增的input类型：email、url、number、range、Date Pickers</p><p>废除的元素：<br>1)能用css替代的元素：basefont、big、center、font、s、strike、tt、u<br>2)不再使用frame框架，只支持iframe框架<br>3)只有部分浏览器支持的元素：applet、bgsound、blink、marquee<br>4)其他废除的元素：rb、acronym、dir、isindex、listing、xmp、nextid、plaintext</p><h3 id="新增的属性和废除的属性"><a href="#新增的属性和废除的属性" class="headerlink" title="新增的属性和废除的属性"></a>新增的属性和废除的属性</h3><p>新增的属性：<br>1)表单相关的属性：autofocus、placeholder、form、required、autocomplete、min、max、multiple、pattern、step、formaction、formenctype、formmethod、formnovalidate、formtarget、novalidate<br>2)链接相关的属性：<br>为a与area元素增加了media属性<br>为area元素增加了hreflang和rel属性，主要目的是保持与a元素、link元素的一致性<br>为link元素增加了新属性sizes。该属性可以与icon元素结合使用（通过rel属性），该属性指定关联图标（icon元素）的大小<br>为base元素增加了target属性，主要目的是保持与a元素的一致性<br>a元素还有download属性<br>3)其他属性<br>为ol元素增加了reversed属性<br>为meta元素增加了charset属性<br>为munu元素增加了type与label<br>为style元素增加了scoped属性<br>为script元素增加了async属性<br>为html元素增加了manifest属性<br>为iframe增加了sandbox、seamless、srcdoc属性</p><p>废除的属性：很多，略</p><h3 id="全局属性"><a href="#全局属性" class="headerlink" title="全局属性"></a>全局属性</h3><p>1)contentEditable<br>2)designMode: on或off<br>3)hidden属性<br>4)spellcheck: 必须声明属性值为true或false<br>5)tabindex</p><h2 id="html5-结构"><a href="#html5-结构" class="headerlink" title="html5 结构"></a>html5 结构</h2><h3 id="新增的主体结构元素"><a href="#新增的主体结构元素" class="headerlink" title="新增的主体结构元素"></a>新增的主体结构元素</h3><p>article元素<br>article元素代表文档、页面或应用程序中独立的、完整的可以被外部引用的内容。article元素也可以用来表示插件，它的作用是使插件看起来好像内嵌在页面中一样。<br>section元素<br>section元素用于对网站或应用程序中页面上的内容进行分块。在HTML5中，article元素可以看成是一种特殊种类的section元素，它比section元素更强调独立性。即section元素强调分段或分块，而article元素强调独立性。<br>section元素使用禁忌：<br>1）不要将section元素用作设置样式的页面容器，那是div的工作；<br>2）如果article元素、aside元素或nav元素更符合使用条件，不要使用section元素；<br>3）不要为没有标题的内容区块使用section元素。<br>nav元素<br>nav元素是一个可以用作页面导航的链接组<br>aside元素<br>aside元素用来表示当前页面或文章的附属信息部分。典型应用是侧边栏<br>time元素和微格式<br>pubdate属性</p><h3 id="新增的非主体结构元素"><a href="#新增的非主体结构元素" class="headerlink" title="新增的非主体结构元素"></a>新增的非主体结构元素</h3><p>header元素<br>hgroup元素<br>footer元素<br>address元素</p><h2 id="表单与文件"><a href="#表单与文件" class="headerlink" title="表单与文件"></a>表单与文件</h2><h3 id="新增元素和属性"><a href="#新增元素和属性" class="headerlink" title="新增元素和属性"></a>新增元素和属性</h3><p>新增属性<br>1)form属性<br>当一个input元素被用于多个元素时，可以在form属性上将各表单id值以空格符分隔开来<br>2)formaction属性<br>3)formmethod属性<br>4)placeholder属性<br>5)autofocus属性<br>6)autocomplete属性<br>autocomplete属性规定输入字段是否应该启用自动完成功能。<br>自动完成允许浏览器预测对字段的输入。当用户在字段开始键入时，浏览器基于之前键入过的值，应该显示出在字段中填写的选项。<br>注释：autocomplete属性适用于form，以及下面的input类型：text,search,url,telephone,email,password,datepickers,range以及color。</p><p>大幅度增加和改良的input种类<br>1)url类型<br>2)email类型<br>3)date类型<br>4)time类型<br>5)datetime类型<br>6)datetime-local类型<br>7)month类型<br>8)week类型<br>9)number类型<br>10)range类型<br>11)search类型<br>12)tel类型<br>13)color类型</p><p>output元素的追加</p><h3 id="表单验证"><a href="#表单验证" class="headerlink" title="表单验证"></a>表单验证</h3><p>自动验证: required pattern min和max step<br>显示验证：checkValidity()方法<br>取消验证：<br>1)form的novalidate属性<br>2)input元素或submit元素的formnovalidate属性</p><h3 id="HTML5表单验证插件"><a href="#HTML5表单验证插件" class="headerlink" title="HTML5表单验证插件"></a>HTML5表单验证插件</h3><p><a href="http://www.zhangxinxu.com/wordpress/2012/12/jquery-html5validate-html5-form-validate-plugin/">html5Validate</a><br>自定义错误信息：setCustomValidity()方法</p><h3 id="增强的页面元素"><a href="#增强的页面元素" class="headerlink" title="增强的页面元素"></a>增强的页面元素</h3><p>新增的figure元素和figcaption元素<br>新增的details元素和summary元素<br>input和datalist</p><pre><code>&lt;input type=&quot;text&quot; list=&quot;province&quot;&gt;    &lt;datalist id=&quot;province&quot;&gt;        &lt;option value=&quot;北京&quot;&gt;&lt;/option&gt;        &lt;option value=&quot;上海&quot;&gt;&lt;/option&gt;        &lt;option value=&quot;浙江&quot;&gt;&lt;/option&gt;    &lt;/datalist&gt;</code></pre><p>新增的mark元素：用来在搜索结果中高亮关键词，也常用来文章引用后加的标示，与em（）、strong不同<br>新增的progess元素：表示任务的进度，如Windows系统中软件的安装、文件的复制等场景的进度。<br>新增的meter元素：表示某种计量，适用于温度、重量、金额等量化的表现。<br>新增的menu和command元素: menu在html4被弃用，在html5中重定义，command为html5新增，这两个标签目前基本没有浏览器支持<br>改良的ol列表：新增了start属性和reversed属性<br>改良的dl列表：html4为定义列表(definition lists)，html5为描述列表(description list)<br>加以严格限制的cite元素：定义引用。可使用该标签对参考文献的引用进行定义，比如书籍或杂志的标题。不用来表示作者，除非标题是作者<br>重新定义的small元素：The small element represents side comments such as small print.而非通用展示性元素，通常用在诸如免责声明、注意事项、法律法规、版权声明等声明文字中，不应该应用在页面主体内容中</p><h3 id="文件API"><a href="#文件API" class="headerlink" title="文件API"></a>文件API</h3><p>FileList对象和file对象：files返回一个FileList对象<br>Blob对象：Blob对象有两个属性，size属性表示一个Blob对象的字节长度，type属性表示MIME类型，file对象也继承了这个对象<br>FilReader接口：FileReader接口有4个方法，其中3个用来读取文件，一个用来中断读取。无论读取成功还是失败，方法不返回读取结果，结果保存在result属性中。<br>4个接口方法：readAsDataURL、readAsBinaryString、readAsText、abort<br>FileReader接口事件：onabort、onerror、onloadstart、onprogress、onload、onloadend<br>FileSystem<br>在使用FileSystem对象的相关应用接口时，首先要获得对沙箱文件系统的访问权限。<br>通过这个接口，可以进行文件的新建、修改、删除。</p><pre><code>//获取兼容文件请求对象window.requestFileSystem = window.requestFileSystem || window.webkitRequestFileSystem;//请求获取浏览器沙箱文件系统//window.webkitStorageInfo.requestQuota is deprecated navigator.webkitPersistentStorage.requestQuota(5*1024*1024,function(bytes)&#123;     window.requestFileSystem(window.PERSISTENT,bytes,function(file_system)&#123;     console.log(file_system); &#125;,function()&#123;&#125;); &#125;,function(e)&#123;     console.log(&#39;Error&#39;,e); &#125;);</code></pre><p>目前只有chrome支持，需启动本地服务。安装chrome扩展程序HTML5 FileSystem Explorer进行查看验证。</p><h3 id="拖放API"><a href="#拖放API" class="headerlink" title="拖放API"></a>拖放API</h3><p>实现拖放的步骤<br>在HTML5中要实现拖放操作，至少要经过以下两个步骤：<br>1)将想要拖放的对象元素的draggable属性设为true(draggable=”true”)。这样才能将元素进行拖放。另外img元素与a元素（必须指定href）默认拖放。<br>2)编写与拖放有关的事件处理代码。拖放的几个事件：<br>dragstart：被拖放的元素<br>drag：被拖放的元素<br>dragenter：拖放过程中鼠标经过的元素<br>dragover：拖放过程中鼠标经过的元素<br>dragleave：拖放过程中鼠标经过的元素<br>drop：拖放的目标元素<br>dragend：拖放的目标元素</p><pre><code>&lt;h2&gt;drag示例&lt;/h2&gt;&lt;div id=&quot;dragme&quot; draggable=&quot;true&quot; style=&quot;width:200px;height:200px;border: 1px solid;&quot;&gt;请拖放&lt;/div&gt;&lt;div id=&quot;text&quot; style=&quot;width:200px;height:200px;border: 1px solid;&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;    function init()&#123;        //自定义图标        var dragIcon = document.createElement(&#39;img&#39;);        dragIcon.src = &#39;http://www.iconpng.com/png/miui-fruitsugar/twelvekeydialer.png&#39;;        var source = document.getElementById(&#39;dragme&#39;);        var dest = document.getElementById(&#39;text&#39;);        //(1)拖放开始        source.addEventListener(&#39;dragstart&#39;,function(e)&#123;            //向dataTransfer对象追加数据            var dt = e.dataTransfer;            dt.effectAllowed = &#39;all&#39;;            dt.setDragImage(dragIcon,-10,-10);            dt.setData(&#39;text/plain&#39;,&#39;你好&#39;); //setData一般采用两种两种数据格式，用于文本数据存储的&quot;text/plain&quot;和用于URL信息存储的&quot;text/uri-list&quot;        &#125;,false);        //(2)拖放事件        dest.addEventListener(&#39;drop&#39;,function(e)&#123;            var dt = e.dataTransfer;            var text = dt.getData(&#39;text/plain&#39;);            dest.textContent += text;        &#125;,false);        //(3)不执行默认处理（拒绝被拖放）        dest.addEventListener(&#39;dragover&#39;,function(e)&#123;            e.preventDefault(); //必须，阻止默认行为        &#125;,false);    &#125;    init();&lt;/script&gt;</code></pre><h2 id="处理浏览器兼容性与Modernizr库"><a href="#处理浏览器兼容性与Modernizr库" class="headerlink" title="处理浏览器兼容性与Modernizr库"></a>处理浏览器兼容性与Modernizr库</h2><h3 id="处理浏览器兼容性"><a href="#处理浏览器兼容性" class="headerlink" title="处理浏览器兼容性"></a>处理浏览器兼容性</h3><p>一般较为常见的安全检测手段有4种：<br>1)检测全局对象，如window、navigator是否拥有指定的属性，如离线存储、地址位置信息等<br>2)通过创建新元素，检查元素对象上是否拥有指定的属性，如Canvas等。<br>3)通过创建新元素，检查元素对象上是否拥有指定的方法，同时调用该方法，并判断返回值，如检查video元素支持的视频格式<br>4)通过创建新元素，设置元素对象上的指定属性值，并判断设定后的值是否被保留。</p><h3 id="Modernizr库概述"><a href="#Modernizr库概述" class="headerlink" title="Modernizr库概述"></a>Modernizr库概述</h3><p>随着HTML5和CSS3加入越来越多的模块，检查各种浏览器是否支持这些模块，成了一大难题。Modernizr就是用来解决这个问题的一个JavaScript库。<br>首先，从modernizr.com下载这个库。下载的时候，可以选择所需要的模块。然后，将它插入HTML页面的头部，放在head标签之中。</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html class=&quot;no-js&quot; lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;utf-8&quot;&gt;  &lt;script src=&quot;js/modernizr.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;/html&gt;</code></pre><h3 id="Modernizr库CSS的新增class"><a href="#Modernizr库CSS的新增class" class="headerlink" title="Modernizr库CSS的新增class"></a>Modernizr库CSS的新增class</h3><p>使用Modernizr以后，首先会把html元素的class替换掉。以chrome浏览器为例，新增的class大概是下面的样子。</p><pre><code>&lt;html class=&quot;js no-touch postmessage history multiplebgs boxshadow opacity cssanimations csscolumns cssgradients csstransforms csstransitions fontface localstorage sessionstorage svg inlinesvg blobbuilder blob bloburls download formdata&quot;&gt;</code></pre><p>IE 7则是这样：</p><pre><code>&lt;html class=&quot;js no-touch postmessage no-history no-multiplebgs no-boxshadow no-opacity no-cssanimations no-csscolumns no-cssgradients no-csstransforms no-csstransitions fontface localstorage sessionstorage no-svg no-inlinesvg wf-loading no-blobbuilder no-blob no-bloburls no-download no-formdata&quot;&gt;</code></pre><p>然后，就可以针对不同的CSS class，指定不同的样式。</p><pre><code>.button &#123;   background: #000;   opacity: 0.75;&#125;.no-opacity .button &#123;   background: #444;&#125;</code></pre><h3 id="Modernizr库JavaScript侦测"><a href="#Modernizr库JavaScript侦测" class="headerlink" title="Modernizr库JavaScript侦测"></a>Modernizr库JavaScript侦测</h3><p>除了提供新增的CSS class，Modernizr还提供JavaScript方法，用来侦测浏览器是否支持某个功能。</p><pre><code>Modernizr.cssgradients; //True in Chrome, False in IE7Modernizr.fontface; //True in Chrome, True in IE7Modernizr.geolocation; //True in Chrome, False in IE7if (Modernizr.canvas)&#123;    // 支持canvas&#125; else &#123;   // 不支持canvas&#125;if (Modernizr.touch)&#123;    // 支持触摸屏&#125; else &#123;   // 不支持触摸屏&#125;</code></pre><h3 id="Modernizr库加载器"><a href="#Modernizr库加载器" class="headerlink" title="Modernizr库加载器"></a>Modernizr库加载器</h3><p>Modernizr允许根据Javascript侦测的不同结果，加载不同的脚本文件。</p><pre><code>Modernizr.load(&#123;  test :        Modernizr.localstorage,  yep  :        &#39;localStorage.js&#39;,  nope :        &#39;alt-storageSystem.js&#39;,  complete :    function () &#123; enableStorgeSaveUI();&#125;&#125;);</code></pre><p>Modernizr.load方法用来加载脚本。它的属性如下：<br>test：用来测试浏览器是否支持某个属性。<br>yep：如果浏览器支持该属性，加载的脚本。<br>nope：如果浏览器不支持该属性，加载的脚本。<br>complete：加载完成后，运行的JavaScript代码。<br>可以指定在支持某个功能的情况，所要加载的JavaScript脚本和CSS样式。</p><pre><code>Modernizr.load(&#123;  test : Modernizr.touch,  yep :  [&#39;js/touch.js&#39;, &#39;css/touchStyles.css&#39;]&#125;);</code></pre><p>本章Modernizr部分来自阮一峰的JavaScript标准参考教程的<a href="http://javascript.ruanyifeng.com/library/modernizr.html">Modernizr</a></p><h2 id="绘制图形"><a href="#绘制图形" class="headerlink" title="绘制图形"></a>绘制图形</h2><h3 id="canvas元素的基础知识"><a href="#canvas元素的基础知识" class="headerlink" title="canvas元素的基础知识"></a>canvas元素的基础知识</h3><p>canvas：画布<br>检测Canvas强化版：</p><pre><code>function isSupportCanvas()&#123;    var cvs = document.createElement(&#39;canvas&#39;);    // 首先判断getContext方法是否存在    if(!cvs.getContext)&#123;        return false;    &#125;    // 判断是否含有fillText方法    return typeof cvs.getContext(&#39;2d&#39;).fillText == &#39;function&#39;;&#125;</code></pre><p>绘制矩形<br>用canvas绘制图形时，需要经过几道步骤：<br>1)取得canvas元素<br>2)取得上下文(context)：getContent方法<br>3)设定绘图样式(style)：fillStyle、strokeStyle<br>4)指定线宽：lineWidth<br>5)context.fillRect(x,y,width,height)<br>context.strokeRect(x,y,width,height)<br>context.clearRect(x,y,width,height)<br>填充(fill)和绘制边框(stroke)</p><h3 id="使用路径"><a href="#使用路径" class="headerlink" title="使用路径"></a>使用路径</h3><p>绘制圆形<br>开始创建路径：beginPath方法<br>创建图形的路径：context.arc(x,y,radius,startAngle,endAngle,anticlockwise)<br>路径创建完成后关闭路径: closePath方法<br>设定绘制样式，调用绘制方法，绘制路径。</p><p>如果路径没有关闭：已经创建的路径会永远保留着，即使绘制完毕后，因此会进行重叠绘制，因此要对路径进行管理</p><p>moveTo(x,y)和lineTo(x,y)</p><p>使用bezierCurveTo绘制曲线：context.bezierCurveTo(cp1x,cp1y,cp2x,cp2y,x,y);<br>二次样条曲线：context.quadraticCurveTo(in float cpx,in float cpy,in float x,in float y);</p><h3 id="绘制渐变图形"><a href="#绘制渐变图形" class="headerlink" title="绘制渐变图形"></a>绘制渐变图形</h3><p>绘制线性渐变：context.createLinearGradient(xStart,ySTart,xEnd,yEnd)<br>设定渐变颜色：context.addColorStop(offset,color)，渐变起点offset为0,渐变结束点为1。然后将style设定为LinearGradient对象。<br>绘制径向渐变：context.createRadialGradient(xStart,yStart,radiusStart,xEnd,yEnd,radiusEnd);</p><h3 id="绘制变形图形"><a href="#绘制变形图形" class="headerlink" title="绘制变形图形"></a>绘制变形图形</h3><p>坐标变换</p><ol><li>平移：context.translate(x,y);</li><li>缩放：context.scale(x,y);</li><li>旋转：context.rotate(angle);<br>坐标变换与路径的结合使用：另外写一个创建路径的函数，然后在坐标变换的同时调用该函数</li></ol><p>矩阵变换<br>context.transform(a,b,c,d,e,f);<br>这个方法与css3 matrix方法差不多<br>1)矩阵与translate(x,y)：(1,0,0,1,x,y)<br>2)矩阵与scale(x,y)：(x,0,0,y,0,0)<br>3)矩阵与rotate(angle)：(Math.cos(angle * Math.PI / 180),Math.sin(angle * Math.PI / 180),-Math.cos(angle * Math.PI / 180),Math.sin(angle * Math.PI / 180),0,0)<br>4)矩阵与skew(anglex,angley)：(1,Math.tan(angley * Math.PI / 180),Math.tan(anglex * Math.PI / 180),1,0,0)（css3 非context方法）</p><p>矩阵是一种高级应用，可以做一些没有提供的效果，比如镜像对称效果：((1-k<em>k) / (1+k</em>k), 2k / (1 + k<em>k), 2k / (1 + k</em>k), (k<em>k - 1) / (1+k</em>k), 0, 0)</p><p>可以用setTransform(a,b,c,d,e,f)方法来重置变换矩阵</p><h3 id="图形组合"><a href="#图形组合" class="headerlink" title="图形组合"></a>图形组合</h3><p>context.globalCompositeOperation = type;<br>type值：”source-over”,”destination-over”,”source-in”,”destination-in”,”souce-out”,”destination-out”,”source-atop”,”destination-atop”,”lighter”,”copy”,”xor”</p><h3 id="给图形绘制阴影"><a href="#给图形绘制阴影" class="headerlink" title="给图形绘制阴影"></a>给图形绘制阴影</h3><p>shadowOffsetX(),shadowOffsetY(),shadowColor(),shadowBlur()。如果想要后面的图形不再有阴影，只要把shadowColor设定为rgba(0,0,0,0)就可以了。</p><h3 id="使用图像"><a href="#使用图像" class="headerlink" title="使用图像"></a>使用图像</h3><p>绘制图像</p><pre><code>context.drawImage(image,x,y)context.drawImage(image,x,y,w,h)context.drawImage(image,sx,sy,sw,sh,dx,dy,dw,dh)var image = new Image();image.src = &quot;img/17.jpg&quot;;image.onload = function()&#123;&#125;;</code></pre><p> 图像平铺<br>一是使用drawImage方法循环处理，二是使用context.createPattern(image,type);<br>type: no-repeat,repeat-x,repeat-y,repeat<br>使用createPattern方法创建填充样式，然后将该样式指定给图形上下文对象的fillStyle属性，最后再填充画布。</p><p>图像裁剪<br>使用图形上下文不带参数的clip方法来实现canvas元素的图像裁剪功能。该方法使用路径来对canvas画布设置一个裁剪区域。因此先创建路径，设置裁剪区域，再绘制图像。<br>如何取消裁剪区域：使用绘制状态的保存和恢复功能。save方法和restore方法。</p><p>像素处理<br>反显：</p><pre><code>var imagedata;var i;var n = imagedata.data.length;context.drawImage(image,0,0);imagedata = context.getImageData(0,0,image.width,image.height);for( i = 0; i &lt; n; i += 4)&#123;    imagedata.data[i] = 255 - imagedata.data[i];    imagedata.data[i+1] = 255 - imagedata.data[i+1];    imagedata.data[i+2] = 255 - imagedata.data[i+2];&#125;context.putImageData(imagedata,0,0);</code></pre><h3 id="绘制文字"><a href="#绘制文字" class="headerlink" title="绘制文字"></a>绘制文字</h3><p>fillText(text,x,y,[maxWidth]);<br>strokeText(text,x,y,[maxWidth]);<br>font属性、fontAlign属性、fontBaseline属性<br>context.measureText(text);</p><h3 id="补充知识"><a href="#补充知识" class="headerlink" title="补充知识"></a>补充知识</h3><p>保存与恢复状态<br>图形上下文对象的当前状态的保存与恢复可以应用在以下场合：<br>1)图像或图形变形<br>2)图像裁剪<br>3)改变图形上下文以下属性时：<br>fillStyle<br>font<br>globalAlpha<br>globalCompositionOperation<br>lineCap<br>lineJoin<br>lineWidth<br>miterLimit<br>shadowBlur<br>shadowColor<br>shadowOffsetX<br>shadowOffsetY<br>strokeStyle<br>textAlign<br>textBaseline<br>clipping区域<br>转换矩阵等<br>最后保存的最先还原</p><p>保存文件<br>canvas API保存文件的原理实际上是把当前的绘画状态输出到一个data URL地址所指向的数据中的过程。<br>canvas.toDataURL(type);<br>type表示输出数据的MIME类型</p><p>简单动画的制作<br>1)预先编写好用来绘图的函数，在改函数中先用clearRect方法将画布整体或局部擦除<br>2)使用setInterval方法设置动画的间隔时间</p><p>canvas动画学习参考：<br>1.<a href="https://www.pureweber.com/article/html5-cavas-animation/">HTML5-Canvas动画原理</a><br>2.<a href="http://taobaofed.org/blog/2016/02/22/canvas-performance/">Canvas 最佳实践（性能篇）</a></p><h3 id="其他相关"><a href="#其他相关" class="headerlink" title="其他相关"></a>其他相关</h3><p>SVG<br>SVG是Scalable Vecotor Graphics的缩写，即可缩放矢量图形，是基于XML(可扩展标记语言)用来描述二维矢量图形的一种图形格式。<br>SVG有如下优点：<br>1.基于XML，继承了XML的扩平台和可扩展的特性<br>2.采用文本描述图形对象，利用搜索引擎通过文本内容搜索图片信息<br>3.良好的交互和动态特性，可以在其中嵌入动画，通过脚本收缩、旋转调整图形<br>4.对DOM支持完整，可以通过脚本获取元素，监听元素事件<br>5.体积小下载快，在互联网上传输有明显优势<br>WebGL</p><h2 id="媒体播放"><a href="#媒体播放" class="headerlink" title="媒体播放"></a>媒体播放</h2><pre><code>&lt;video id=&quot;player&quot; width=&quot;600&quot; height=&quot;450&quot; controls preload&gt;您的浏览器不支持HTML5    &lt;source src=&quot;./videos/echo-hereweare.mp4&quot;&gt;&lt;/source&gt;  &lt;!-- 提供默认的播放视频  --&gt;&lt;/video&gt;</code></pre><p>1)video播放相关API</p><p>只读属性：<br>video.duration：整个媒体文件的播放时长，单位s<br>video.paused ：如果媒体文件被暂停，则返回true；如果还没开始播放，默认返回true<br>video.ended ：如果媒体文件播放完毕，则返回true</p><p>可写属性：<br>video.currentTime：以s为单位返回从开始播放到现在所用的时间。在播放过程中，设置currentTime来进行搜索，并定位到媒体文件的特定位置<br>video.volume ：在0.0到1.0之间设置音频音量的相对值，或者查询当前音量相对值<br>video.muted ：检测当前是否为静音，是则为true；为文件设置静音或消除静音</p><p>控制函数：<br>video.play() ：播放视频文件<br>video.pause() ：暂停处于播放状态的视频文件<br>video.canPlayType() ：测试video元素是否支持给定MIME类型的文件</p><p>监听事件：<br>ontimeupdate ：当video.currentTime发生改变时触发该事件</p><p>2)全屏控制API<br>说明：这里只给出webkit的全屏API，本代码没有做兼容性处理，主要应用了webkit的一些高级API和chrome的伪元素，所以前面请大家用chrome打开演示地址。</p><p>video.webkitRequestFullScreen()：全屏显示<br>document.webkitCancelFullScreen()：退出全屏<br>document.webkitIsFullScreen：如果当前处于全屏状态，则返回true,否则返回false<br>document.addEventListener(‘webkitfullscreenchange’, handler)：当在全屏和非全屏状态切换时，触发该事件</p><p>3)本地文件读取API<br>说明：我的这个视频播放器支持从本地添加视频文件播放，支持的格式在webkit浏览器支持的html5视频播放标准范围内。本地文件读取API是html5的新标准。</p><p>window.URL.createObjectURL(file)：file为文件对象，该函数返回指向文件的对象URL，通过该URL可以访问文件。</p><p>video.src = window.URL.createObjectURL(file);</p><p>音视频的实时通信：WebRTC技术，该技术主要用于支持浏览器进行实时的语音对话和视频通信。</p><p>视频播放学习参考：<br>1.<a href="https://segmentfault.com/a/1190000000380064">打造自己的html5视频播放器</a><br>2.<a href="http://taobaofed.org/blog/2016/05/23/video-player/">视频播放的那些事</a></p><h2 id="本地存储"><a href="#本地存储" class="headerlink" title="本地存储"></a>本地存储</h2><h3 id="Web-Storage"><a href="#Web-Storage" class="headerlink" title="Web Storage"></a>Web Storage</h3><p>cookie会带来什么问题：<br>1)cookie大小限制在4k左右，不适合存业务数据<br>2)cookie每次随HTTP事务一起发送，浪费带宽<br>localstorage可以说是对cookie的优化，使用它可以方便在客户端存储数据，并且不会随着HTTP传输，但也不是没有问题：</p><p>1)localstorage大小限制在5m左右，各个浏览器不一致<br>2)localstorage在隐私模式下不可读取<br>3)localstorage本质是在读写文件，数据多的话会比较卡（firefox会一次性将数据导入内存，想想就觉得吓人啊）<br>4)localstorage不能被爬虫爬取，不要用它完全取代URL传参</p><p>sessionStorage：<br>保存数据：sessionStorage.setItem(key,value);<br>读取数据：sessionStorege.getItem(key);<br>localStorage:<br>保存数据：localStorage.setItem(key,value);<br>读取数据：localStorege.getItem(key);<br>localStorage.length<br>localStorage.key(index)<br>localStorage.clear()</p><h3 id="本地数据库"><a href="#本地数据库" class="headerlink" title="本地数据库"></a>本地数据库</h3><h3 id="SQLLite"><a href="#SQLLite" class="headerlink" title="SQLLite"></a>SQLLite</h3><p>要使用SQLLite数据库，有两个必要的步骤：<br>1)创建访问数据库的对象<br>2)使用事务处理<br>var db = openDatabase(‘mydb’,’1.0’,’Test DB’,2 * 1024 *1024);<br>db.transaction(function(tx){<br>    tx.executeSql(‘CREATE TABLE IF EXISTS LOGS (id unique Log)’);<br>});<br>transaction方法中的处理<br>1)追加数据<br>tx.executeSql(‘INSERT INFO MsgData VALUES(?,?,?)’,[name,message,time],function(tx,rs){},function(tx,error));<br>2)创建数据表<br>tx.executeSql(‘CREATE TABLE IF NOT EXISTS MsgData(name TEXT,message TEXT,tiem INTEGER)’,[]);<br>3)获取全部数据<br>tx.ececuteSql(‘SELECT * FROM MsgData’,[],…);</p><h3 id="indexedDB"><a href="#indexedDB" class="headerlink" title="indexedDB"></a>indexedDB</h3><p>indexedDb是HTML5推出的一种轻量级的NoSQL数据库，即常说的非关系型数据库。比起传统的关系型数据库，NoSQL数据库具有易扩展、读写快速、成本低廉等特点。HTML5的IndexedDB还包含了常见的数据库构造，如事务、索引、游标等，在API的使用上分为同步和异步两种形态。</p><pre><code>// 创建一个数据库var request = indexedDB.open(&#39;Html5IndexedDB&#39;,2);request.onerror = function(e)&#123;    console.log(e);&#125;;//监听事务事件request.onupgradeneeded = function(e)&#123;    // 获取数据库对象    var db = e.target.result;    // 创建对象存储空间存放用户信息    objectStore = db.createObjectStore(&#39;users&#39;,&#123;keyPath:&quot;html5&quot;&#125;);    // 创建索引来通过name搜索客户    objectStore.createIndex(&#39;name&#39;,&#39;name&#39;,&#123;unique:false&#125;);    objectStore.createIndex(&#39;id&#39;,&#39;id&#39;,&#123;unique:true&#125;);    objectStore.add(&#123;html5:&#39;1&#39;,name:&#39;小王&#39;,sex:&#39;女&#39;,id:&#39;3323&#39;,age:23&#125;);&#125;</code></pre><h2 id="离线应用程序"><a href="#离线应用程序" class="headerlink" title="离线应用程序"></a>离线应用程序</h2><p>离线Web应用程序是指：当客户端本地与Web应用程序的服务器没有建立连接时，也能正常在客户端使用该Web应用程序进行有关操作。</p><h3 id="本地缓存和浏览器缓存的区别："><a href="#本地缓存和浏览器缓存的区别：" class="headerlink" title="本地缓存和浏览器缓存的区别："></a>本地缓存和浏览器缓存的区别：</h3><p>1)本地缓存为整个web应用程序服务的，而浏览器的网页缓存只服务于单个网页。任何网页都具有网页缓存。而本地缓存至缓存那些指定的缓存的页面。</p><p>2)网页缓存不安全不可靠，因为我们不知道在网站中到底缓存了哪些网页，以及缓存了网页上的哪些资源。而本地缓存可靠，我们可以控制对哪些内容进行缓存，不对哪些内容进行缓存，开发人员还可以利用编程的手段来控制缓存的更新，利用缓存对象的各种属性、状态和事件来开发出更加强大的离线应用程序。</p><p>3)（有些）浏览器会主动保存自己的缓存文件以加快网站加载速度。但是要实现浏览器缓存必须要满足一个前提，那就是网络必须要保持连接。如果网络没有连接，即使浏览器启用了对一个站点的缓存，依然无法打开这个站点。只会收到一条错误信息。而使用离线web应用，我们可以主动告诉浏览器应该从网站服务器中获取或缓存哪些文件，并且在网络离线状态下依然能够访问这个网站。</p><h3 id="实现HTML5应用程序缓存"><a href="#实现HTML5应用程序缓存" class="headerlink" title="实现HTML5应用程序缓存"></a>实现HTML5应用程序缓存</h3><p>实现HTML5应用程序缓存非常简单，只需三步，并且不需要任何API。只需要告诉浏览器需要离线缓存的文件，并对服务器和网页做一些简单的设置即可实现。<br>1)创建一个 cache.manifest 文件，并确保文件具有正确的内容。<br>2)在服务器上设置内容类型。<br>3)所有的HTML文件都指向 cache.manifest。</p><p>具体实现：<br>首先我们建立一个名为cache.manifest的文件，Windows平台下用记事本即可（也可用其他的IDE）。文件内容如下：</p><pre><code>CACHE MANIFEST#version1CACHE:index.html404.htmlfavicon.icorobots.txthumans.txtapple-touch-icon.pngcss/normalize.min.csscss/main.csscss/bootmetro-icons.min.cssimg/pho-cat.jpgimg/pho-huangshan.jpg FALLBACK:online.js local.js NETWORK:*</code></pre><p>注意事项：<br>1)第一行必须是”CACHE DMANIFEST”文字，以把本文件的作用告知浏览器，即对本地缓存中的资源文件进行具体设置。<br>2)在manifest文件中，可以加上注释来进行一些必要说明或解释。注释行以”#”文字开头。<br>3)在CACHE之后的部分为列出我们需要缓存的文件。<br>4)在FALLBACK之后的部分每一行中指定两个资源文件，第一个资源文件为能够在线访问时使用的资源文件，第二个资源文件为不能在线访问时使用的备用资源文件。<br>5)在NETWORK之后可以指定在线白名单，即列出我们不希望离线存储的文件，因为通常它们的内容需要互联网访问才有意义。另外，在此部分我们可以使用快捷方式：通配符*。这将告诉浏览器，应用服务器中获取没有在显示部分中提到的任何文件或URL。</p><p>服务器上设置内容类型。<br>真正运行或测试离线web应用程序的时候，需要对服务器进行配置，让服务器支持text/cache-manifest这个MIME类型（在h5中规定manifest文件的MIME类型是text/cache-manifest）。例如对Apache服务器进行配置的时候，需要找到｛apache_home｝/conf/mime.type这个文件(.htaccess)，并在文件最后添加如下所示代码：</p><pre><code>text/cache-manifest .manifest </code></pre><p>在微软的IIS服务器中的步骤如下所示：<br>(1).右键选择默认网站或需要添加类型的网站，弹出属性对话框<br>(2).选择”http头”标签<br>(3).在MIME映射下，单击文件类型按钮<br>(4).在打开的MIME类型对话框中单击新建按钮<br>(5).在关联扩展名文本中输入”manifest”，在内容类型文本框中输入”text/cache-manifest”,然后点击确定按钮。</p><p>设置HTML文件的指向。<br>完成这一步后，就完成了web离线缓存的所有步骤。由于浏览的文件内容都没有更改且存储在本地，因此现在网页的打开速度会更快（即使是在线状态也如此）。</p><p>注意事项：<br>1)网站的每一个html页面都必须设置html元素的manifest属性。<br>2)在你的整个网站应用中，只能有一个cache.manifest文件（建议放在网站根目录下）；<br>3)部分浏览器（如IE8-）不支持HTML5离线缓存；<br>4)“#” 开头的注释行可满足其他用途。应用的缓存会在其manifest文件更改时被更新。如果您编辑了一幅图片，或者修改了一个JavaScript 函数，这些改变都不会被重新缓存。更新注释行中的日期和版本号是一种使浏览器重新缓存文件的办法。</p><h3 id="applicationCache的两个方法"><a href="#applicationCache的两个方法" class="headerlink" title="applicationCache的两个方法"></a>applicationCache的两个方法</h3><p>applicationCache的update方法<br>显式调用了更新缓存算法以检测是否有最新版本的的应用程序。这导致浏览器检测同一个清单文件（并触发相同的事件），这和第一次载入应用程序时的效果是一样的。<br>applicationCache的swapCache方法：<br>它告诉浏览器可以弃用老缓存，所有的请求都从新缓存中获取。注意，这并不会重新载入应用程序：所有已经载入的html文件、图片、脚本等资源都不会改变。但是，之后的请求将从最新的缓存中获取。这会导致“版本错乱”的问题，因此一般不推荐使用，除非应用程序设计得很好，确保这样的方式没有问题。只有ApplicationCache.UPDATEREADY和ApplicationCache.ABSOLETE 时调用swapCache()才有意义（当状态OBSOLETE时，调用它可以立即弃用废弃的缓存，让之后所有的请求都通过网络获取）。如果状态属性是其他数值的时候调用swapCache()方法，它就会抛出异常。</p><pre><code>function init()&#123;    setInterval(function()&#123;        //手工检查是否更新        applicationCache.update();    &#125;,5000);    applicationCache.addEventListener(&#39;updateready&#39;,function()&#123;        if( confirm(&quot;本地缓存已被更新，需要刷新页面来获取应用程序最新版本，是否刷新？&quot;) )&#123;            // 手工更新本地缓存            applicationCache.swapCache();            // 重置画面            location.reload();        &#125;    &#125;,true);&#125;init();</code></pre><h3 id="applicationCache对象的事件"><a href="#applicationCache对象的事件" class="headerlink" title="applicationCache对象的事件"></a>applicationCache对象的事件</h3><p>1.checking事件<br>2.downloading事件<br>3.progress事件<br>4.cached事件<br>5.noupdate事件<br>6.updateready事件<br>7.obsolete事件<br>8.error事件</p><p>(1).没有可用更新<br>如果应用程序已经缓存并且清单文件没有动，则浏览器会触发noupdate事件<br>(2).有可用更新<br>如果应用程序已经缓存并且清单元件有改动，则浏览器会触发downloading事件并开始下载和缓存清单文件中列举的所有资源。随着下载过程的进行浏览器还会触发”progress”事件，在下载完成后，会触发”updateready”事件。<br>(3).首次载入新的应用程序<br>如果还未缓存应用程序，如上所述downloading，progress事件都会触发。但是，当下载完成后，浏览器会触发”cached”事件而不是updateready事件<br>(4).浏览器处于离线状态<br>如果浏览器处于离线状态，它无法检查清单文件，同时它会触发“error”事件。如果一个未缓存的应用程序引用了不存的清单文件，浏览器也会触发该事件<br>(5).清单文件不存在<br>如果浏览器处理在线状态，应用程序也已经缓存起来，但是清单文件不存在，浏览器会触发obsolete事件，并将该应用程序从缓存中移除。</p><h3 id="如何判断在线还是离线状态？"><a href="#如何判断在线还是离线状态？" class="headerlink" title="如何判断在线还是离线状态？"></a>如何判断在线还是离线状态？</h3><p>navigator.onLine是HTML5定义用来检测设备是在线还是离线。对应的值为false或true。<br>HTML5定义了online和offline事件用于监听网络状态变化。</p><pre><code>window.addEventListener(&#39;online&#39;, callback); // 离线到上线window.addEventListener(&#39;offline&#39;, callback); // 上线到离线</code></pre><h2 id="通信API"><a href="#通信API" class="headerlink" title="通信API"></a>通信API</h2><h3 id="跨文档消息传输"><a href="#跨文档消息传输" class="headerlink" title="跨文档消息传输"></a>跨文档消息传输</h3><p>跨文档消息传递（Cross Document Messaging），有时候简称XDM。指的是来自不同域的页面间传递消息。比如：abc.com与内联框架中的efg.com进行通信。</p><p>XDM的核心是postMessage()方法，这是HTML5规范的api，意思就是向另一个地方发送消息，除了XDM中有postMessage()方法，在HTML5规范中，其他地方也有相同的方法名，比如web worker中、WebSockets以及Server-SentEvents中。但目的都是向另一个地方发送数据，只不过在XDM中，另一个地方指的是页面中的iframe框架，或者由当前页面弹出的窗口。</p><p>postMessage()方法</p><p>postMessage()方法接收两个参数：postMessage(message, targetOrigin):</p><p>message：传递的消息，可以是任意的数据类型，不过为了保证兼容性，最好只传递字符串（部分浏览器智能处理字符串），对于对象的数据，可以先用JSON.stingify()方法转成字符串，然后再通过JSON.parse()方法转成对象。在低版本的浏览器中，可以使用json2.js实现相同的效果。<br>targetOrigin：消息接收方的域（URL地址）。postMessage会将message发送到该窗口，如果不指定目标源，可以设置成*，表示消息发送到任意窗口。第二个参数对保障安全通信非常重要，可以防止浏览器把消息传递到不安全的地方。</p><p>postMessage()方法实践</p><p>本地建立一个html文件：</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;postMessage&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;input type=&quot;text&quot; id=&quot;message&quot;&gt;&lt;button&gt;发送消息&lt;/button&gt;&lt;iframe src=&quot;http://localhost:63342/post%20text/iframe.html&quot; id=&quot;iframe1&quot;&gt;&lt;/iframe&gt;&lt;script&gt;    window.onload = function()&#123;        var message = document.getElementById(&quot;message&quot;),                btn = document.getElementsByTagName(&quot;button&quot;)[0],                iframe = document.getElementById(&quot;iframe1&quot;);        var iWin = iframe.contentWindow;        btn.onclick = function()&#123;            iWin.postMessage(message.value,&quot;http://localhost:63342/post%20text/test.html&quot;);        &#125;    &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>iframe页面</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;script&gt;        window.onmessage = function(e)&#123;            console.log(e);            document.body.innerHTML = &quot;&quot;;            document.body.innerHTML = e.data;        &#125;    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>这样，当我在文本框中输入内容并且点击发送的时候，框架就可以获取到我发送的信息，从而可以进行相应的操作。</p><p>onmessage事件<br>当接收到XDM消息时，触发window对象的onmessage事件，这个事件是以异步形式触发的。onmessage事件有三个重要的参数：data，origin，source。</p><p>data：postMessage传递进来的值<br>origin：发送消息的文档所在的域<br>source：发送消息文档的window对象的代理，如果是来自同一个域，则该对象就是window，可以使用其所有方法，如果是不同的域，则该window是不能使用的，除了调用postMessage()方法之外。<br>接收到消息后，验证消息的来源是很重要的，就像给postMessage()方法指定第二个参数，以确保浏览器不会把消息发送给其他框架一样。判断其origin即可判断来源：</p><pre><code>//iframe页面window.onmessage = function(e)&#123;    if(e.origin === &#39;http://sandbox.runjs.cn&#39;)&#123;        //处理数据        //接收相应        e.source.postMessage(&quot;已经收到信息！&quot;, &quot;http://localhost:63342/post%20text/test.html&quot;&quot;);    &#125;&#125;</code></pre><p>浏览器兼容性<br>就像localStorage一样，IE8也支持。</p><p>总结</p><p>postMessage方法进行跨文档信息传递简单方便<br>在不同域时，event.source中的window对象为代理window对象，只能调用postMessage()方法<br>onmessage事件是window对象上得事件，在使用时注意IE的事件处理程序，attachEvent </p><p>原文：<a href="http://youthol.top/2016/01/19/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%93%8D%E4%BD%9Ciframe-postmessage%E8%B7%A8%E6%96%87%E6%A1%A3%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92/">操作iframe–postMessage跨文档消息传递</a></p><h3 id="XMLHttpRequest-Level-2"><a href="#XMLHttpRequest-Level-2" class="headerlink" title="XMLHttpRequest Level 2"></a>XMLHttpRequest Level 2</h3><p>XMLHttpRequest Level 2是早期XMLHttpRquest的升级版，最初的XMLHttpRquest被设计为仅限于同源通信，不能跨域进行数据传输，导致后续演变出JSONP方法。XMLHttpRquest Level 2对同源策略进行了修改，允许跨域的数据请求，同时还添加了progress事件用于监听请求进度，返回进度信息。XMLHttpRquest Level 2要求所有跨域的请求都要使用HTTP协议中的origin信息头，同时数据接收服务器需要具备CORS策略，各种服务器的CORS策略设置可以参考网站<a href="http://enable-cors.org/">http://enable-cors.org/</a><br>兼容性：IE10+<br>客户端：</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    数据：&lt;input type=&quot;text&quot;&gt;&lt;button&gt;获取&lt;/button&gt;    &lt;script type=&quot;text/javascript&quot;&gt;        document.querySelector(&#39;button&#39;).addEventListener(&#39;click&#39;,function(e)&#123;            e.preventDefault()            var xhr = new XMLHttpRequest()            if( typeof xhr.withCredentials == undefined)&#123;                console.log(&#39;浏览器不支持html5 XMLHttpRequst Level 2的跨域请求支持&#39;)            &#125;else&#123;                xhr.onload = function()&#123;                    var data = JSON.parse(xhr.responseText)                    document.querySelector(&#39;input&#39;).value = data.data                &#125;                xhr.onerror = function(e)&#123;console.log(e)&#125;                xhr.open(&#39;GET&#39;,&#39;http://localhost:8080&#39;,true);                xhr.send();            &#125;        &#125;,false);    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>服务端(nodejs)：</p><pre><code>var http = require(&#39;http&#39;)http.createServer(function(req,res)&#123;    res.setHeader(&#39;Access-Control-Allow-Origin&#39;,&#39;http://localhost:63342&#39;)    res.setHeader(&#39;Access-Control-Allow-Methods&#39;,&#39;GET&#39;,&#39;POST&#39;)    req.setEncoding(&#39;utf-8&#39;)    res.end(JSON.stringify(&#123;data:&#39;Hello World!&#39;&#125;))&#125;).listen(8080,function()&#123;    console.log(&#39;listing on http://localhost:8080&#39;)&#125;)</code></pre><p>XMLHttpRequest Level 2对远端请求的服务器有一定的要求，需要在服务器端返回的HTTP信息头中指明支持的域名。如果想对所有请求都通过处理，可以设置为”*”号。如果要指定多个，一般会认为使用以下写法：</p><pre><code>res.setHeader(&#39;Access-Control-Allow-Origin&#39;,&#39;http://localhost,http://test.com&#39;); //域名之间使用逗号res.setHeader(&#39;Access-Control-Allow-Origin&#39;,&#39;http://localhost http://test.com&#39;); //域名之间使用空格</code></pre><p>非常不幸的是，浏览器无法识别这两种返回头，推荐先对请求域名做判断，如果符合业务要求，再设置对于域名的Access-Control-Allow-Origin头信息。</p><h3 id="Web-Socket通信"><a href="#Web-Socket通信" class="headerlink" title="Web Socket通信"></a>Web Socket通信</h3><p>在讲Websocket之前，先讲讲long poll和ajax轮询的原理。<br>首先是ajax轮询，ajax轮询的原理非常简单，让浏览器隔个几秒就发送一次请求，询问服务器是否有新信息。<br>long poll其实原理跟ajax轮询差不多，都是采用轮询的方式，不过采取的是阻塞模型（一直打电话，没收到就不挂电话），也就是说，客户端发起连接后，如果没消息，就一直不返回Response给客户端。直到有消息才返回，返回完之后，客户端再次建立连接，周而复始。<br>从上面可以看出其实这两种方式，都是在不断地建立HTTP连接，然后等待服务端处理，可以体现HTTP协议的另外一个特点，被动性。<br>何为被动性呢，其实就是，服务端不能主动联系客户端，只能有客户端发起。<br>通过上面这个例子，我们可以看出，这两种方式都不是最好的方式，需要很多资源。<br>一种需要更快的速度，一种需要更多的’电话’。这两种都会导致’电话’的需求越来越高。<br>哦对了，忘记说了HTTP还是一个无状态协议。</p><p>所以在这种情况下出现了，Websocket出现了。<br>他解决了HTTP的这几个难题。<br>首先，被动性，当服务器完成协议升级后（HTTP-&gt;Websocket），服务端就可以主动推送信息给客户端啦。<br>就变成了这样，只需要经过一次HTTP请求，就可以做到源源不断的信息传送了。（在程序设计中，这种设计叫做回调，即：你有信息了再来通知我，而不是我傻乎乎的每次跑来问你）<br>这样的协议解决了上面同步有延迟，而且还非常消耗资源的这种情况。<br>同时，在传统的方式上，要不断的建立，关闭HTTP协议，由于HTTP是非状态性的，每次都要重新传输identity info（鉴别信息），来告诉服务端你是谁。<br>同时由客户主动询问，转换为服务器（推送）有信息的时候就发送（当然客户端还是等主动发送信息过来的。。），没有信息的时候就交给接线员（Nginx），不需要占用本身速度就慢的客服（Handler）了<br><a href="https://www.zhihu.com/question/20215561">知乎参考</a><br><a href="http://javascript.ruanyifeng.com/htmlapi/websocket.html">进一步学习</a></p><h3 id="Socket-IO通信框架"><a href="#Socket-IO通信框架" class="headerlink" title="Socket.IO通信框架"></a>Socket.IO通信框架</h3><p>Socket.IO是Guillermo Rauch开发的基于Node.js的应用项目，以实现跨浏览器和跨平台应用为目标。Socket.IO针对不同的浏览器会做自动优雅降级，选择当前浏览器最合适的实现方式，如在一些不支持HTML5 WebSocket的浏览器上，会使用长连接的Ajax技术。同时Socket.IO提供了一套平台统一的应用程序接口，开发者在使用时完全不用考虑浏览器的兼容问题。</p><h2 id="Web-Workers"><a href="#Web-Workers" class="headerlink" title="Web Workers"></a>Web Workers</h2><p>JavaScript语言采用的是单线程模型，也就是说，所有任务排成一个队列，一次只能做一件事。随着电脑计算能力的增强，尤其是多核CPU的出现，这一点带来很大的不便，无法充分发挥JavaScript的潜力。</p><p>Web Worker的目的，就是为JavaScript创造多线程环境，允许主线程将一些任务分配给子线程。在主线程运行的同时，子线程在后台运行，两者互不干扰。等到子线程完成计算任务，再把结果返回给主线程。因此，每一个子线程就好像一个“工人”（worker），默默地完成自己的工作。这样做的好处是，一些高计算量或高延迟的工作，被worker线程负担了，所以主进程（通常是UI进程）就会很流畅，不会被阻塞或拖慢。<br>在现实开发中Web Worker常常被用于处理大型密集型数据任务，可以有效的避免阻塞主UI线程渲染交互。</p><p>Worker线程分成好几种。<br>1)普通的Worker：只能与创造它们的主进程通信。<br>2)Shared Worker：能被所有同源的进程获取（比如来自不同的浏览器窗口、iframe窗口和其他Shared worker），它们必须通过一个端口通信。<br>3)ServiceWorker：实际上是一个在网络应用与浏览器或网络层之间的代理层。它可以拦截网络请求，使得离线访问成为可能。</p><p>Web Worker有以下几个特点：<br>1)同域限制。子线程加载的脚本文件，必须与主线程的脚本文件在同一个域。<br>2)DOM限制。子线程所在的全局对象，与主进程不一样，它无法读取网页的DOM对象，即document、window、parent这些对象，子线程都无法得到。（但是，navigator对象和location对象可以获得。）<br>3)脚本限制。子线程无法读取网页的全局变量和函数，也不能执行alert和confirm方法，不过可以执行setInterval和setTimeout，以及使用XMLHttpRequest对象发出AJAX请求。<br>4)文件限制。子线程无法读取本地文件，即子线程无法打开本机的文件系统（file://），它所加载的脚本，必须来自网络。</p><p>注意线程嵌套在chrome中有bug</p><p>线程中可用的变量、函数与类：<br>self：self关键词用来表示本线程范围内的作用域<br>postMessage(message)：向创建线程的源窗口发送信息<br>worker.postMessage()：向子线程中提交信息<br>onmessage：获取接收信息的事件句柄<br>importScripts(urls)：导入其他JavaScript脚本文件importScript(‘script1.js’,’scripts\script2.js’,’scripts\script3.js’);<br>navigator对象<br>sessionStorage、localStorage<br>XMLHttpRequest<br>Web Workers<br>setTimeout()/setInterval()<br>close：可用结束本线程<br>eval()、isNaN()、escape()等，可以使用所有JavaScript核心函数<br>object：可以创建和使用本地对象<br>WebSockets：可以使用WebSockets API来向服务器发送和接收信息</p><h2 id="获取地理位置"><a href="#获取地理位置" class="headerlink" title="获取地理位置"></a>获取地理位置</h2><h3 id="有哪些定位数据"><a href="#有哪些定位数据" class="headerlink" title="有哪些定位数据"></a>有哪些定位数据</h3><p>1.IP地址<br>2.GPS(Global Positioning System)<br>3.RFID(Radio Frequency IDentification，即射频识别)<br>4.Wi-Fi地址<br>5.GSM或CDMA手机的ID<br>6.用户自定义的地理位置数据</p><h3 id="Geolocation-API的基本知识"><a href="#Geolocation-API的基本知识" class="headerlink" title="Geolocation API的基本知识"></a>Geolocation API的基本知识</h3><p>获取当前的地理位置</p><pre><code>navigator.geolocation.getCurrentPosition(success,error,options);</code></pre><p>第一个参数为获取当前地理位置成功时所执行的回调函数，第二个参数为获取失败时所执行的回调函数，第三个参数为一些可选属性的列表。<br>若成功，则getCurrentPosition()方法返回对象。始终会返回latitude、longitude以及accuracy属性。如果可用，则会返回其他下面的属性。<br>coords.latitude    十进制数的纬度<br>coords.longitude    十进制数的经度<br>coords.accuracy    位置精度<br>coords.altitude    海拔，海平面以上以米计<br>coords.altitudeAccuracy    位置的海拔精度<br>coords.heading    方向，从正北开始以度计<br>coords.speed    速度，以米/每秒计<br>timestamp    响应的日期/时间</p><p>获取当前地理位置失败<br>该回调函数使用一个error对象作为参数，这个参数具有以下两个属性：<br>code属性：<br>用户拒绝了位置服务（属性值为1）<br>获取不到位置信息（属性值为2）<br>获取信息超时错误（属性值为3）<br>message属性<br>message属性为一个字符串，在该字符串中包含了错误信息</p><p>getCurrentPosition方法中的第三个参数可以省略，它是一些可先属性的列表：<br>enableHighAccuracy：是否要求高精度的地理位置信息。在很多设备上设置了都没用，多数情况下把该属性设为默认。<br>timeout：超时设置<br>maximumAge：对地理位置信息进行缓存的有效时间。</p><p>持续监视当前地理位置信息</p><pre><code>watchCurrentPosition(onSuccess,onError,options);</code></pre><p>停止获取用户的当前地理位置信息<br>    clearWatch(watchId)<br>使用方法和clearTimeout差不多</p><h2 id="微数据"><a href="#微数据" class="headerlink" title="微数据"></a>微数据</h2><p>HTML5微数据规范是一种标记内容以描述特定类型的信息，例如评论、人物信息或事件。每种信息都描述特定类型的项，例如人物、事件或评论。例如，事件可以包含venue、starting time、name和category属性。<br>微数据使用HTML标记（常为span或div）中的简单属性为项和属性指定简要的描述性名称。<br><a href="http://www.zhangxinxu.com/wordpress/2011/12/html5%E6%89%A9%E5%B1%95-%E5%BE%AE%E6%95%B0%E6%8D%AE-%E4%B8%B0%E5%AF%8C%E7%BD%91%E9%A1%B5%E6%91%98%E8%A6%81/">HTML5扩展之微数据与丰富网页摘要</a></p><h2 id="History-API"><a href="#History-API" class="headerlink" title="History API"></a>History API</h2><p>HTML5中给History新增了两个方法，允许开发者逐条地添加和修改历史记录，方法如下：<br>pushState：在历史堆栈的顶部添加一条记录，history.pushState({}, “页面标题”, “xxx.html”);<br>replaceState：更改当前页面的历史记录，参数同pushState方法<br>在HTML5 History出现之前，要记录页面状态和浏览器记录只能通过Hash和iFrame两种方式。可以借助第三方类库History.js进行兼容。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机 </tag>
            
            <tag> 前端 </tag>
            
            <tag> 积累 </tag>
            
            <tag> HTML5 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javaScript篇01--javascript事件</title>
      <link href="/posts/30021.html"/>
      <url>/posts/30021.html</url>
      
        <content type="html"><![CDATA[<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p>JavaScript和HTML的交互是通过事件实现的。JavaScript采用异步事件驱动编程模型，当文档、浏览器、元素或与之相关对象发生特定事情时，浏览器会产生事件。我们可以给这个事件注册相应的事件处理程序，事件处理程序也就是事件发生后的处理动作。</p><h2 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h2><p>事件流描述的是从页面中接收事件的顺序。<br>DOM2级事件规定事件流包含三个阶段<br>1.document往事件触发地点，捕获前进，遇到相同注册事件立即触发执行<br>2.到达事件位置，触发事件，如果该处既注册了冒泡事件，也注册了捕获事件，按照注册顺序执行<br>3.事件触发地点往document方向，冒泡前进，遇到相同注册事件立即触发<br>IE8及IE8以下不支持事件捕获，只支持事件冒泡，早期Netscape只支持事件捕获，现代浏览器采用DOM2级事件流模型。</p><h2 id="事件处理程序"><a href="#事件处理程序" class="headerlink" title="事件处理程序"></a>事件处理程序</h2><p>响应某个事件的函数叫做事件处理程序或事件侦听器（listener），事件处理程序的名字以“on”开头。</p><h2 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h2><p>在触发DOM上某个事件时，会产生一个事件对象event，它包含着所有与事件有关的信息。只有在事件处理程序执行期间event对象才会存在，执行完毕后event对象被销毁。</p><h3 id="DOM中的事件对象："><a href="#DOM中的事件对象：" class="headerlink" title="DOM中的事件对象："></a>DOM中的事件对象：</h3><p>无论指定事件处理程序时使用了哪种方法，兼容DOM的浏览器都会将一个event对象传入到事件处理程序中。<br>HTML方法添加时，变量event中保存着event对象。<br>event对象通用的属性和方法中比较常用的有：<br>currentTarget：其事件处理程序当前正处理事件的元素<br>target：事件的目标<br>preventDefault()：阻止事件的默认行为<br>stopPropagation()：阻止事件的进一步捕获或冒泡<br>type：被触发的事件类型</p><h3 id="IE中的事件对象："><a href="#IE中的事件对象：" class="headerlink" title="IE中的事件对象："></a>IE中的事件对象：</h3><p>DOM0级方法添加事件处理程序时，event对象是window的属性；<br>IE方法添加时，event对象会像DOM中一样，作为参数被传递到事件处理程序函数中。<br>HTML方法添加时，和DOM相同，event对象保存在变量event中。<br>常用方法和属性：<br>srcElement：等于target，默认目标<br>returnValue：等于preventDefault()，阻止默认行为<br>cancelBubble：设为true取消事件冒泡，等于stopPropagation()<br>type：被触发的事件类型</p><h3 id="跨浏览器的事件对象"><a href="#跨浏览器的事件对象" class="headerlink" title="跨浏览器的事件对象"></a>跨浏览器的事件对象</h3><p>虽然DOM和IE的event对象不同，但基于它们的相似性，我们还是可以写出跨浏览器的事件对象方案</p><pre><code>function getEvent(e) &#123;    return e || window.event;&#125;function getTarget(e) &#123;    return e.target || e.scrElement;&#125;function preventDefault(e) &#123;    if (e.preventDefault)        e.preventDefault();    else        e.returnValue = false;&#125;function stopPropagation(e) &#123;    if (e.stopPropagation)        e.stopPropagation();    else        e.cancelBubble = true;&#125;</code></pre><h2 id="事件模拟"><a href="#事件模拟" class="headerlink" title="事件模拟"></a>事件模拟</h2><p>DOM：<br>(1) 创建：用document.createEvent()方法创建event对象，该方法接受一个参数，即要创建的事件类型的字符串。<br>(2) 初始化：不同类型的event有不同名字的初始化方法：<br>鼠标事件：”MouseEvents”，”initMouseEvent()”，接受15个参数<br>键盘事件：”KeyboardEvent”，”initKeyEvent()”，接受10个参数。键盘事件只有支持DOM3的浏览器才能用，要先检测。<br>其他事件：变动事件，HTML事件，方法类似，很少使用。<br>自定义DOM事件：”CustonEvent”，”initCustonEvent()”，接受4个参数（type字符串、bubbles布尔值、cancelable布尔值、detail对象）。<br>(3) 触发：dispatchEvent()方法，接受一个参数，即要触发事件的event对象。<br>IE9+开始支持DOM方式。</p><p>IE：<br>(1) 创建：document.createEventObject()创建event对象。<br>(2) 初始化：用event.propertyName = …的形式手动添加信息，没有特别的方法。<br>(3) 触发：fireEvent()方法，接受两个参数：事件处理程序的名称、event对象。</p><h2 id="绑定事件处理程序的方法"><a href="#绑定事件处理程序的方法" class="headerlink" title="绑定事件处理程序的方法"></a>绑定事件处理程序的方法</h2><p>共有四种方法：HTML、DOM0、DOM2、IE，也可将后三种整合为跨浏览器方法。<br>(1) HTML：<br>对于不同元素，它支持的事件可以用一个与相应事件处理程序同名的HTML attribute来指定。如</p><pre><code>&lt;input type=&quot;button&quot; value=&quot;click here&quot; onclick=&quot;alert(&#39;hi&#39;)&quot;/&gt;</code></pre><p>两个缺点：从HTML元素出现到事件处理程序就绪之间存在时差；HTML和JS代码紧密耦合。</p><p>(2) DOM0：<br>先取得一个对象的引用，再将一个函数赋值给该引用的一个事件处理程序属性。</p><pre><code>var btn = document.getElementById(&quot;myBtn&quot;);btn.onclick = function()&#123;    alert(&quot;Clicked&quot;);&#125;</code></pre><p>DOM0是元素的方法，事件处理程序是在元素的作用域中运行，在冒泡阶段被处理。在代码运行到它们前不会指定事件处理程序，和HTML方法一样存在时差，可能某段时间内怎么点都没反应。</p><p>(3) DOM2：<br>绑定事件处理程序：addEventListener()<br>删除事件处理程序：removeEventListener()<br>三个参数：要处理的事件名、作为事件处理程序的函数、表示调用事件处理程序阶段的布尔值（true捕获阶段，false冒泡阶段，一般都设为false以保证兼容性）。<br>好处：可以添加多个事件处理程序（按添加他们的顺序触发）。<br>注意事项：通过addEventListener()添加的匿名函数无法移除。<br>备注：IE9起支持DOM2方法。</p><pre><code>//&lt;div id=&quot;div&quot;&gt;click this division&lt;/div&gt;var div = document.getElementById(&quot;div&quot;);function sayHi()&#123;console.log(&quot;hi&quot;);&#125;function sayHi2()&#123;console.log(&quot;hi again&quot;);&#125;div.addEventListener(&quot;click&quot;,sayHi,false);div.addEventListener(&quot;click&quot;,sayHi2,false);</code></pre><p>(4) IE：<br>绑定：attachEvent()<br>删除：detachEvent()<br>参数：事件处理名称（以“on”开头，不同于DOM）、事件处理函数<br>注意事项：<br>[1] 匿名函数同样不能移除；<br>[2] 跟使用DOM0方法事件处理程序的作用域不同。DOM0方法中事件处理程序在其所属元素的作用域上运行，IE方法在全局作用域运行，this等于window；<br>[3] 执行顺序跟添加顺序相反；<br>[4] 老版本IE只支持冒泡，所以事件处理程序都会被添加到冒泡阶段；<br>[5] IE9开始不建议使用IE专属方法，IE11彻底取消支持。</p><p>(5) 在添加事件处理程序事addEventListener和attachEvent主要有几个区别</p><p>1.参数个数不相同，这个最直观，addEventListener有三个参数，attachEvent只有两个，attachEvent添加的事件处理程序只能发生在冒泡阶段，addEventListener第三个参数可以决定添加的事件处理程序是在捕获阶段还是冒泡阶段处理（我们一般为了浏览器兼容性都设置为冒泡阶段）</p><p>2.第一个参数意义不同，addEventListener第一个参数是事件类型（比如click，load），而attachEvent第一个参数指明的是事件处理函数名称（onclick，onload）</p><p>3.事件处理程序的作用域不相同，addEventListener的作用域是元素本身，this是指的触发元素，而attachEvent事件处理程序会在全局变量内运行，this是window，所以刚才例子才会返回undefined，而不是元素id</p><p>4.为一个事件添加多个事件处理程序时，执行顺序不同，addEventListener添加会按照添加顺序执行，而attachEvent添加多个事件处理程序时顺序无规律(添加的方法少的时候大多是按添加顺序的反顺序执行的，但是添加的多了就无规律了)，所以添加多个的时候，不依赖执行顺序的还好，若是依赖于函数执行顺序，最好自己处理，不要指望浏览器</p><p>(6) 跨浏览器：<br>function addEvent(node, type, handler) {<br>    if (!node) return false;<br>    if (node.addEventListener) {<br>        node.addEventListener(type, handler, false);<br>        return true;<br>    }<br>    else if (node.attachEvent) {<br>        node.attachEvent(‘on’ + type, function() { handler.apply(node); });<br>        return true;<br>    }<br>    return false;<br>}<br>这样处理就可以解决handler中有this的问题了，但是新的问题又来了，我们这样等于添加了一个匿名的事件处理程序，无法用detachEvent取消事件处理程序，有很多解决方案，我们可以借鉴大师的处理方式，jQuery创始人John Resig很巧妙地利用了闭包，是这样做的</p><pre><code>function addEvent(node, type, handler) &#123;    if (!node) return false;    if (node.addEventListener) &#123;        node.addEventListener(type, handler, false);        return true;    &#125;    else if (node.attachEvent) &#123;        node[&#39;e&#39; + type + handler] = handler;        node[type + handler] = function() &#123;            node[&#39;e&#39; + type + handler](window.event);        &#125;;        node.attachEvent(&#39;on&#39; + type, node[type + handler]);        return true;    &#125;    return false;&#125;</code></pre><p>在取消事件处理程序的时候</p><pre><code>function removeEvent(node, type, handler) &#123;    if (!node) return false;    if (node.removeEventListener) &#123;        node.removeEventListener(type, handler, false);        return true;    &#125;    else if (node.detachEvent) &#123;        node.detachEvent(&#39;on&#39; + type, node[type + handler]);        node[type + handler] = null;    &#125;    return false;&#125;</code></pre><h2 id="事件委托（事件代理）是什么？"><a href="#事件委托（事件代理）是什么？" class="headerlink" title="事件委托（事件代理）是什么？"></a>事件委托（事件代理）是什么？</h2><p>事件委托的意义：<br>1.委托事件有一个优势，他们能在后代元素添加到文档后，可以处理这些事件。在确保所选择的元素已经存在的情况下，进行事件绑定时，可以使用委派的事件，以避免频繁的绑定事件及解除绑定事件。<br>2.除了可以给未创建的后代元素绑定事件外，代理事件的另一个好处就是，当需要监视很多元素的时候，代理事件的开销更小。<br>原理：<br>事件委托利用了事件冒泡，只绑定一个事件处理程序，就可以管理某一类型的所有事件。<br>使用事件委托只需要在DOM树中尽量高的层次上添加一个使用了switch-case的事件处理程序。<br>适用情况：<br>所有用到按钮的事件都适合采用事件委托，最适合的有click、mousedown、mouseup、keydown、keyup、keypress。<br>移除事件处理程序：<br>内存中留有过时不用的空事件处理程序会造成性能问题：<br>1.文档中移除带有事件处理程序的元素（removeChild()、replaceChild()、innerHTML）<br>2.卸载页面<br>针对1：如果知道某个元素即将被移除，最好手工移除事件处理程序，如bt.onclick = null;<br>针对2：在页面卸载前通过onunload事件处理程序移除所有事件处理程序。这时使用事件委托会有明显优势，即需要跟踪的事件处理程序越少，移除越容易。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>1.stopImmediatePropagation的使用<br>这玩意儿是w3c的东西，使用的也不是特别多，我们知道stopPropagation 可以阻止事件的进一步传播，但是他阻止不了该元素上绑定的其他函数的执行，比如我们在obj上绑定了func1和func2，如果我们在func1中使用了stopPropagation，那func2依然还是会执行出来。倘若这里使用stopImmediatePropagation，结果就不一样了，他不仅阻止事件的传播，还阻止func2的执行。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机 </tag>
            
            <tag> 前端 </tag>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS3学习总结</title>
      <link href="/posts/6917.html"/>
      <url>/posts/6917.html</url>
      
        <content type="html"><![CDATA[<p>在CSS3中，并没有采用总体结构，而是采用了分工协作的模块化结构</p><h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><h3 id="属性选择器："><a href="#属性选择器：" class="headerlink" title="属性选择器："></a>属性选择器：</h3><p>[att*=val]<br>[att^=val]<br>[att$=val]</p><h3 id="伪类和伪元素"><a href="#伪类和伪元素" class="headerlink" title="伪类和伪元素"></a>伪类和伪元素</h3><p>a:link<br>a:visited<br>a:hover<br>a:active</p><p>:first-line<br>:first-letter<br>:after<br>:before</p><p>:root<br>:not()<br>:empty<br>:target</p><p>:first-child  (css2)<br>:last-child   (css3)<br>:nth-child()<br>:nth-last-child()<br>:nth-of-type()<br>:nth-last-of-type()<br>:only-child</p><p>:hover<br>:active<br>:focus</p><p>:enabled<br>:disabled<br>:read-only<br>:read-write<br>:checked</p><p>::selection</p><h2 id="使用选择器在页面中插入内容"><a href="#使用选择器在页面中插入内容" class="headerlink" title="使用选择器在页面中插入内容"></a>使用选择器在页面中插入内容</h2><p>利用before伪元素和after伪元素的content属性插入内容</p><h3 id="插入文字"><a href="#插入文字" class="headerlink" title="插入文字"></a>插入文字</h3><pre><code>h2:before&#123;    content: &#39;COLUMN&#39;;    color：#fff;    background: orange;    font-family: &#39;Comic Sans MS&#39;,Helvetica,sans-serif;    padding: 1px 5px;    margin-right: 10px;&#125;</code></pre><p>指定个别元素不进行插入：none属性和normal属性</p><h3 id="插入图像文件"><a href="#插入图像文件" class="headerlink" title="插入图像文件"></a>插入图像文件</h3><pre><code>h2:before&#123;    content: url(https://www.baidu.com/img/bd_logo1.png);&#125;</code></pre><p>content: attr(name);</p><pre><code>img:after&#123;    content: attr(alt);&#125;a:after&#123;    content: &quot;(&quot;attr(href)&quot;)&quot;;&#125;</code></pre><h3 id="使用content属性来插入项目编号"><a href="#使用content属性来插入项目编号" class="headerlink" title="使用content属性来插入项目编号"></a>使用content属性来插入项目编号</h3><p>指定编号的种类</p><pre><code>h1&#123;    counter-increment: mycounter;&#125;h1:before&#123;    content: counter(mycounter,upper-roman)&#39;.&#39;;    color: blue;    font-size: 42px;&#125;</code></pre><p>编号嵌套：</p><pre><code>h1&#123;    counter-increment: mycounter;    counter-reset: subcounter;&#125;h1:before&#123;    content: counter(mycounter)&#39;.&#39;;&#125;h2&#123;    counter-increment: subcounter;&#125;h2:before&#123;    content: counter(mycounter)&#39;-&#39;counter(subcounter)&#39;.&#39;;&#125;</code></pre><p>在字符串两边添加嵌套文字符号</p><pre><code>h1&#123;    quotes:&#39;(&#39;&#39;)&#39;;&#125;h1:before&#123;    content: open-quote;&#125;h1:after&#123;    content: close-quote;&#125;</code></pre><h2 id="文字与字体"><a href="#文字与字体" class="headerlink" title="文字与字体"></a>文字与字体</h2><h3 id="阴影：text-shadow"><a href="#阴影：text-shadow" class="headerlink" title="阴影：text-shadow"></a>阴影：text-shadow</h3><p>多个阴影：</p><pre><code>div&#123;    text-shadow: 5px 5px 5px gray,        10px 10px 5px red,        15px 15px 5px blue;    font-size: 50px;&#125;</code></pre><h3 id="word-break"><a href="#word-break" class="headerlink" title="word-break"></a>word-break</h3><p>当word-break属性为break-all时，对于西文来说，允许在单词内换行，对于标点符号，实测在Firefox中允许标点符号位于行首，其他浏览器不允许。</p><h3 id="word-wrap"><a href="#word-wrap" class="headerlink" title="word-wrap"></a>word-wrap</h3><p>word-wrap:break-word;<br>word-wrap 是用来决定允不允许英文单词内断句的，如果不允许的话长单词就会溢出。最重要的一点是它还是会首先尝试挪到下一行，看看下一行的宽度够不够，不够的话就进行单词内的断句。<br>而word-break:break-all则更变态，因为它断句的方式非常粗暴，它不会尝试把长单词挪到下一行，而是直接进行单词内的断句</p><h3 id="font-face"><a href="#font-face" class="headerlink" title="@font-face"></a>@font-face</h3><h3 id="font-size-adjust"><a href="#font-size-adjust" class="headerlink" title="font-size-adjust"></a>font-size-adjust</h3><p>font-size-adjust属性为某个元素规定一个aspect值，这样就可以保持首选字体的x-height。字体的小写字母 “x” 的高度与”font-size”高度之间的比率被称为一个字体的aspect值。</p><h2 id="盒相关的样式"><a href="#盒相关的样式" class="headerlink" title="盒相关的样式"></a>盒相关的样式</h2><h3 id="display"><a href="#display" class="headerlink" title="display"></a>display</h3><p>none     此元素不会被显示。<br>block     此元素将显示为块级元素，此元素前后会带有换行符。<br>inline     默认。此元素会被显示为内联元素，元素前后没有换行符。<br>inline-block     行内块元素。<br>list-item     此元素会作为列表显示。<br>table     此元素会作为块级表格来显示（类似table），表格前后带有换行符。<br>inline-table     此元素会作为内联表格来显示（类似table），表格前后没有换行符。<br>table-cell     此元素会作为一个表格单元格显示（类似td和th）</p><h3 id="box-shadow"><a href="#box-shadow" class="headerlink" title="box-shadow"></a>box-shadow</h3><h3 id="box-sizing-IE8"><a href="#box-sizing-IE8" class="headerlink" title="box-sizing(IE8+)"></a>box-sizing(IE8+)</h3><h2 id="背景和边框相关的样式"><a href="#背景和边框相关的样式" class="headerlink" title="背景和边框相关的样式"></a>背景和边框相关的样式</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>background    在一个声明中设置所有的背景属性。<br>background-attachment    设置背景图像是否固定或者随着页面的其余部分滚动。<br>background-color    设置元素的背景颜色。<br>background-image    设置元素的背景图像。<br>background-position    设置背景图像的开始位置。<br>background-repeat    设置是否及如何重复背景图像。<br>background-clip    规定背景的绘制区域。css3默认为border-box<br>background-origin    规定背景图片的定位区域。<br>background-size    规定背景图片的尺寸。</p><h3 id="border-radius"><a href="#border-radius" class="headerlink" title="border-radius"></a>border-radius</h3><h3 id="border-image"><a href="#border-image" class="headerlink" title="border-image"></a>border-image</h3><p>JavaScript 语法：object.style.borderImage=”url(border.png) 30 30 round”<br>border-image-repeat: repeat/round/stretch</p><h2 id="CSS3中的变形处理"><a href="#CSS3中的变形处理" class="headerlink" title="CSS3中的变形处理"></a>CSS3中的变形处理</h2><p>translate()<br>rotate()<br>scale()<br>skew()<br>matrix()<br>transform    向元素应用2D或3D转换<br>transform-origin    允许你改变被转换元素的位置</p><p><em>注意：这些方法只对block水平元素有效</em></p><h2 id="过渡与动画"><a href="#过渡与动画" class="headerlink" title="过渡与动画"></a>过渡与动画</h2><h3 id="过渡"><a href="#过渡" class="headerlink" title="过渡"></a>过渡</h3><p>CSS3 过渡是元素从一种样式逐渐改变为另一种的效果。<br>要实现这一点，必须规定两项内容：<br>规定您希望把效果添加到哪个 CSS 属性上<br>规定效果的时长</p><h3 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h3><p>当您在 @keyframes 中创建动画时，请把它捆绑到某个选择器，否则不会产生动画效果。<br>通过规定至少以下两项 CSS3 动画属性，即可将动画绑定到选择器：<br>规定动画的名称<br>规定动画的时长</p><h2 id="多列"><a href="#多列" class="headerlink" title="多列"></a>多列</h2><p>column-count<br>column-gap<br>column-rule</p><h2 id="弹性盒子"><a href="#弹性盒子" class="headerlink" title="弹性盒子"></a>弹性盒子</h2><p><a href="https://css-tricks.com/snippets/css/a-guide-to-flexbox/">A Complete Guide to Flexbox</a><br>Properties for the Parent(flex container):<br>display: flex; /* or inline-flex */<br>flex-direction: row | row-reverse | column | column-reverse;<br>flex-wrap: nowrap | wrap | wrap-reverse;<br>flex-flow: &lt;‘flex-direction’&gt; || &lt;‘flex-wrap’&gt;<br>justify-content: flex-start | flex-end | center | space-between | space-around;<br>align-items: flex-start | flex-end | center | baseline | stretch;<br>align-content: flex-start | flex-end | center | space-between | space-around | stretch;</p><p>Properties for the Children(flex items):<br>1)order: integer;<br>2)flex-grow: number; /* default 0 <em>/<br>设置或检索弹性盒的扩展比率,根据弹性盒子元素所设置的扩展因子作为比率来分配剩余空间.3<br>3)flex-shrink: number; /</em> default 1 <em>/<br>flex-shrink的默认值为1，如果没有显示定义该属性，将会自动按照默认值1在所有因子相加之后计算比率来进行空间收缩。<br>4)flex-basis: length | auto; /</em> default auto */<br>auto：无特定宽度值，取决于其它属性值<br>length：用长度值来定义宽度。不允许负值<br>percentage：用百分比来定义宽度。不允许负值<br>5)flex: none | [ &lt;’flex-grow’&gt; &lt;’flex-shrink’&gt;? || &lt;’flex-basis’&gt; ]<br>This is the shorthand for flex-grow, flex-shrink and flex-basis combined.<br>6)align-self: auto | flex-start | flex-end | center | baseline | stretch;<br>Note that float, clear and vertical-align have no effect on a flex item. </p><h2 id="媒体查询"><a href="#媒体查询" class="headerlink" title="媒体查询"></a>媒体查询</h2><p>CSS 2<br>实际上在很早之前，CSS就支持媒体查询了<br>页面有些部分需要在打印的时候隐藏或者变大，这时候可以使用media使某些style只在打印的时候生效</p><pre><code>@media print &#123;   /* 适用于印刷的样式 */&#125;</code></pre><p>常用的媒体类型有</p><ol><li>all（所有），适用于所有设备。</li><li>handheld（手持），用于手持设备。</li><li>print（印刷），用于分页材料以及打印预览模式下在屏幕上的文档视图。</li><li>projection（投影），用于投影演示文稿，例如投影仪。</li><li>screen（屏幕） ，主要用于计算机屏幕。</li></ol><p>在使用的时候可以在样式表直接书写 @media指令+空格+媒体类型（多个逗号隔开）</p><pre><code>@media print &#123;   body &#123; font-size: 10pt &#125; &#125; @media screen &#123;   body &#123; font-size: 13px &#125;parsing-errors &#125; @media screen, print &#123;   body &#123; line-height: 1.2 &#125; &#125;</code></pre><p>CSS 3<br>但是CSS 2的媒体类型应用场景极为有限，CSS3大大拓展了这一能力</p><pre><code>@media screen and (max-width: 990px)&#123;    .container&#123;        background: orange;    &#125;&#125;</code></pre><p>当媒体类型匹配且表达式为真的时候，对应style就会其作用，除非使用not或者only操作符，否则媒体类型不是必需的，默认代表所有媒体类型。</p><h3 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h3><p>1)and<br>and操作符用于将多个media feature组合成一个查询，同时用于组合media type 和media feature，一个基本的media query类似这样，一个meidia feature作用于所有media type</p><pre><code>@media (min-width: 700px) &#123; ... &#125;</code></pre><p>但是如果只想在横向显示时应用就可以使用and操作符把media type和media feature结合起来<br>    @media (min-width: 700px) and (orientation: landscape) { … }<br>这样上面的media query只有在可视窗口（viewport）最小是700px并且是横向显示的时候才返回true，如果还想进一步限制设备为tv可以这样<br>    @media tv and (min-width: 700px) and (orientation: landscape) { … }<br>2)逗号分隔的列表<br>在使用逗号分隔的查询列表中每个查询都被视为一个独立的查询，任何本查询中的作用符不影响其他查询，只要有一个查询返回true，style就会被作用。<br>举例来说，如果希望特定style在viewport最小宽度为700px或手持式设备上生效，可以这么写：</p><pre><code>@media (min-width: 700px), handheld and (orientation: landscape) &#123; ... &#125;</code></pre><p>3)not<br>not操作符作用域整个查询，所以只有在整个查询返回false的情况下使用not后才会返回true。当使用逗号分隔的列表的时候not作用于邻近的查询，而不会作用于每个查询</p><pre><code>@media not all and (monochrome) &#123; ... &#125;</code></pre><p>查询其实会这样起作用</p><pre><code>@media not (all and (monochrome)) &#123; ... &#125;</code></pre><p>而不是这样</p><pre><code>@media (not all) and (monochrome) &#123; ... &#125;</code></pre><p>对于逗号分隔的列表</p><pre><code>@media not screen and (color), print and (color)</code></pre><p>查询是这样子的</p><pre><code>@media (not (screen and (color))), print and (color)</code></pre><p>4)only<br>only操作符用于阻止不支持带有media feature的media queries的浏览器应用特定style</p><pre><code>&lt;link rel=&quot;stylesheet&quot; media=&quot;only screen and (color)&quot; href=&quot;example.css&quot; /&gt;</code></pre><h3 id="media-features"><a href="#media-features" class="headerlink" title="media features"></a>media features</h3><p>有以下常用的media feature<br>    width：浏览器宽度<br>    height：浏览器高度<br>    device-width：设备屏幕分辨率的宽度值<br>    device-height：设备屏幕分辨率的高度值<br>    orientation：浏览器窗口的方向纵向还是横向，当窗口的高度值大于等于宽度时该特性值为portrait，否则为landscape<br>    aspect-ratio：比例值，浏览器的纵横比<br>    device-aspect-ratio：比例值，屏幕的纵横比<br>    color：设备使用多少位的颜色值，如果不是彩色设备，值为0<br>    color-index：色彩表的色彩数<br>    monochrome：单色帧缓冲器每个像素的字节<br>    resolution：分辨率值，设备分辨率值<br>    scan：电视机类型设备扫描方式，progressive或interlace<br>    grid：只能指定两个值0或1，是否基于栅格的设备</p><h3 id="如何引入media"><a href="#如何引入media" class="headerlink" title="如何引入media"></a>如何引入media</h3><p>有两种常用的引入方式<br>link方法引入</p><pre><code>&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;styleB.css&quot;  media=&quot;screen and (min-width: 600px) and (max-width: 800px)&quot;&gt;</code></pre><p>@media引入</p><pre><code>@media screen and (min-width: 600px) and (max-width: 800px)&#123;    选择器&#123;        属性：属性值；    &#125;&#125;</code></pre><h2 id="CSS3其他"><a href="#CSS3其他" class="headerlink" title="CSS3其他"></a>CSS3其他</h2><h3 id="颜色相关的样式"><a href="#颜色相关的样式" class="headerlink" title="颜色相关的样式"></a>颜色相关的样式</h3><p>1)增加rgba、hsl、hsla<br>alpha通道和opacity属性区别：使用alpha通道时，可以单独针对元素的背景色和文字样式等指定透明度，而opacity只能指定整个元素的透明度。<br>2)指定颜色值为transparent<br>CSS2中，可以在background-color、border-color属性中指定transparent值，在CSS3中，可以在一切指定属性值的属性中指定transparent值。</p><h3 id="用户界面相关"><a href="#用户界面相关" class="headerlink" title="用户界面相关"></a>用户界面相关</h3><p>1)outline与outline-offset<br><a href="http://www.zhangxinxu.com/wordpress/2015/04/css3-radius-outline/">CSS3如何实现圆角的outline效果</a><br>offset支持负值<br>2)resize<br>与overflow：auto或overflow：hidden配合使用。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机 </tag>
            
            <tag> 前端 </tag>
            
            <tag> css </tag>
            
            <tag> css3 </tag>
            
            <tag> 积累 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【翻译】CSS水平和垂直居中的12种方法</title>
      <link href="/posts/63277.html"/>
      <url>/posts/63277.html</url>
      
        <content type="html"><![CDATA[<p><a href="http://tinyfinch.com/horizontal-and-vertical-centering-in-css/">原文链接</a></p><p>在CSS中有许多不同的方法能够做到水平和垂直居中，但很难去选择合适的那个。我会向你展示我所看到的所有的方法，帮助你在所面对的情境下选择最棒的那一个。 </p><h3 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h3><p>此方法将只能垂直居中单行文本。只需将行高设置为对象的高度，文本就会居中。</p><pre><code>&lt;div class=&quot;container&quot;&gt;content&lt;/div&gt;</code></pre><p>CSS:</p><pre><code>.container &#123;    height: 100px;    line-height: 100px;/*与div等高*/&#125;</code></pre><p>优点：<br>1.兼容所有浏览器<br>2.当没有足够的空间时，文字不会被切断</p><p>缺点：<br>1.只对文本有效（不能块级元素）<br>2.当为多行文字而不只一行时（如文字换行），这种方法破坏十分严重</p><p>此方法对小的元素非常有用，比如将按钮或单行文本字段中的文本垂直居中。</p><h3 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h3><p>此方法使用绝对定位的div，它的top为50%，上边距设置为内容高度一半的负值。这意味着对象必须有一个固定的高度，这是被CSS定义了的。因为它有一个固定的高度，你可能需要给容器div设置overflow：hidden，因此如果内部有太多的内容时，滚动条就会出现，而不是内容在在div外继续排列！</p><pre><code>&lt;div class=&quot;container&quot;&gt;content&lt;/div&gt;</code></pre><p>CSS:</p><pre><code>.container &#123;    height: 100px;    position: absolute;    top: 50%;    margin-top: -50px;/* 负的高度的一半 */&#125;</code></pre><p>优点：<br>1.兼容所有浏览器<br>2.不需要嵌套的标签</p><p>缺点：<br>1.当没有足够的空间时，内容会消失（比如当div在body内部并且用户缩小浏览器窗口，滚动条不会出现）</p><p>我们可以修改上面的CSS代码使div垂直和水平居中。<br>CSS:</p><pre><code>#wrap &#123;    width: 200px;    height:200px;    position: absolute;    left: 50%;    margin-left: -100px;/* 宽度/2 */    top:50%;    margin-top: -100px;&#125;</code></pre><h3 id="方法3"><a href="#方法3" class="headerlink" title="方法3"></a>方法3</h3><p>此方法设置一些div的display和table类似，所以我们可以使用table的veitical-align属性（这个属性对其他元素的效果很不一样）。</p><pre><code>&lt;div id=&quot;container&quot;&gt;    &lt;div id=&quot;content&quot;&gt;content&lt;/div&gt;&lt;/div&gt;</code></pre><p>CSS:</p><pre><code>#container &#123;    height: 300px;    display: table;&#125;#content &#123;    display:table-cell;    vertical-align: middle;&#125;</code></pre><p>优点：<br>1.内容可以动态改变高度（这样不用一定得在CSS中定义）<br>2.当容器没有足够的空间时，内容不会被切断。</p><p>缺点：<br>1.IE低版本不支持<br>2.需要很多嵌套的标签（真的不好，这是一个很主观的话题）</p><p>由于这种方法不支持ie6-7，所以如果你想解决这个问题，只需添加一个新的div来使用hack方式。</p><pre><code>&lt;div class=&quot;table&quot;&gt;    &lt;div class=&quot;tableCell&quot;&gt;        &lt;div class=&quot;content&quot;&gt;content&lt;/div&gt;    &lt;/div&gt;&lt;/div&gt;</code></pre><p>CSS:</p><pre><code>.table &#123;    height: 300px;/    width: 300px;    display: table;    position: relative;    float:left;&#125;        .tableCell &#123;    display: table-cell;    vertical-align: middle;    text-align: center;                padding: 10px;    *position: absolute;    *top: 50%;    *left: 50%;&#125;.content &#123;    *position:relative;    *top: -50%;    *left: -50%;&#125;    </code></pre><h3 id="方法4"><a href="#方法4" class="headerlink" title="方法4"></a>方法4</h3><p>在这种方法中，我们将在内容元素前加一个div。这个div将设置为height:50%;并且margin-bottom为内容高度的一半。然后内容清除浮动，内容将会居中。<br>你应该注意到，如果内容元素在body内，我们需要设置height:100%。</p><pre><code>&lt;body&gt;    &lt;div id=&quot;floater&quot;&gt;&lt;!--This block have empty content --&gt;&lt;/div&gt;        &lt;div id=&quot;content&quot;&gt;Content section&lt;/div&gt;&lt;/body&gt;</code></pre><p>CSS:</p><pre><code>html,body &#123;height: 100%;&#125;    #floater&#123;        float:left;        height:50%;        margin-bottom: -120px;/*240px/2*/&#125;#content &#123;    clear:both;    height: 240px;    position: relative;&#125;</code></pre><p>优点：<br>1.兼容所有浏览器<br>2.当没有足够的空间（即窗口缩小）时我们的内容不会被切断，滚动条会出现。</p><p>缺点：<br>1.需要一个额外的空元素</p><p><a href="http://jsbin.com/faqimif/1/edit?html,css,output">查看demo</a></p><h3 id="方法5"><a href="#方法5" class="headerlink" title="方法5"></a>方法5</h3><p>该方法设置一些div来像table一样显示，所以我们可以像方法3一样使用table的vertical-align属性，但是对于IE，我们需要添加一个inline水平的标签，块级水平的标签是没有任何用的。</p><pre><code>&lt;p class=&quot;table&quot;&gt;    &lt;span class=&quot;tableCell&quot;&gt;Centering multiple lines &lt;br&gt;in a block container.&lt;/span&gt;    &lt;!--[if lte IE 7]&gt;&lt;b&gt;&lt;/b&gt;&lt;![endif]--&gt;&lt;/p&gt;</code></pre><p>CSS:</p><pre><code>&lt;style type=&quot;text/css&quot;&gt;                .table &#123;    border: 1px solid orange;    display: table;    height: 200px;    width: 200px;    text-align: center;&#125;.tableCell &#123;    display: table-cell;    vertical-align: middle;&#125;&lt;/style&gt;&lt;!--[if lte ie 7]&gt;&lt;style type=&quot;text/css&quot;&gt;.tableCell &#123;    display: inline-block;&#125;b &#123;    display: inline-block;    height: 100%;    vertical-align: middle;    width: 1px;&#125;&lt;/style&gt;&lt;![endif]--&gt;</code></pre><p>优点：<br>内容可以动态改变高度</p><p>缺点：<br>很多嵌套标签</p><h3 id="方法6"><a href="#方法6" class="headerlink" title="方法6"></a>方法6</h3><p>此方法设置display:inline-block，添加父元素的高度为固定数值或百分比。 </p><pre><code>&lt;div id=&quot;parent&quot;&gt;    &lt;div id=&quot;vertically_center&quot;&gt;        &lt;p&gt;I am vertically centered!&lt;/p&gt;    &lt;/div&gt;    &lt;div id=&quot;extra&quot;&gt;&lt;!-- ie comment --&gt;&lt;/div&gt;&lt;/div&gt;</code></pre><p>CSS:</p><pre><code>&lt;style type=&quot;text/css&quot;&gt;html,body&#123;    height: 100%;&#125;#parent &#123;    height: 500px;    border: 1px solid red;&#125;#vertically_center,#extra &#123;    display: inline-block;    vertical-align: middle;&#125;#extra &#123;    height: 100%; &#125;&lt;/style&gt;&lt;!--[if lt IE 8]&gt;&lt;style type=&quot;text/css&quot;&gt;/*IE6-7not  support display:inline-block,so we need a hack*/#vertically_center,#extra &#123;    display: inline;    zoom: 1;&#125;#extra &#123;    width: 1px;&#125;&lt;/style&gt;&lt;![endif]--&gt;</code></pre><p>优点：<br>兼容所有浏览器</p><p>缺点：<br>需要添加父级的高度，并为IE写一个hack，另外，需要很多标签。</p><p><a href="http://jsbin.com/cenefib/1/edit?html,css,output">查看demo</a></p><h3 id="方法7"><a href="#方法7" class="headerlink" title="方法7"></a>方法7</h3><p>该方法用于多行文本和高度是可变的时候，我们需要设置给顶部和底部同样的padding。 </p><pre><code>&lt;div class=&quot;columns&quot;&gt;    &lt;div class=&quot;item&quot;&gt;test&lt;/div&gt;&lt;/div&gt;</code></pre><p>CSS:</p><pre><code>.item &#123;padding-top:30px;padding-bottom:30px;&#125;</code></pre><p>优点：<br>简单且兼容所有浏览器</p><p>缺点：<br>如果高度是固定的，此方法无效的。</p><h3 id="方法8"><a href="#方法8" class="headerlink" title="方法8"></a>方法8</h3><p>现在让我们来看看如何使用jQuery来居中。</p><pre><code>&lt;div class=&quot;container&quot;&gt;    &lt;p&gt;Centered in the middle of the page with jQuery&lt;/p&gt;&lt;/div&gt;</code></pre><p>CSS:</p><pre><code>.container&#123;    background-color:#338BC7;    width:270px;    height:150px;&#125;</code></pre><p>jQuery:</p><pre><code>$(document).ready(function()&#123;    $(window).resize(function()&#123;        $(&#39;.container&#39;).css(&#123;            position:&#39;absolute&#39;,            left: ($(window).width() -$(&#39;.container&#39;).outerWidth())/2,            top: ($(window).height() - $(&#39;.container&#39;).outerHeight())/2        &#125;);    &#125;)    $(window).resize();&#125;);</code></pre><p>优点：<br>简单且兼容所有浏览器</p><p>缺点：<br>需要jQuery，如果JavaScript被禁用将会失效</p><h3 id="方法9"><a href="#方法9" class="headerlink" title="方法9"></a>方法9</h3><p>在这种方法中，我们使用CSS3的新属性：flexbox。 </p><pre><code>&lt;body&gt;    &lt;img src=&quot;//vertical.jpg&quot; alt=&quot;flexbox way&quot; /&gt;&lt;/body&gt;</code></pre><p>CSS:</p><pre><code>*&#123;  margin: 0;  padding:0;  -webkit-box-sizing: border-box;  box-sizing: border-box;&#125;html,body &#123;  height: 100%;&#125;body &#123;  display: flex;  align-items: center;  justify-content: center;  width: 100%;/*for firefox*/&#125;</code></pre><p>优点：<br>简单且在响应式设计中效果十分棒</p><p>缺点：<br>在有些浏览器中不起作用，因为其不支持flexbox</p><h3 id="方法10"><a href="#方法10" class="headerlink" title="方法10"></a>方法10</h3><p>如果网站有弹窗，我们不知道它的大小，但我们总是希望它能在大多数的设备里居中。</p><pre><code>&lt;div class=&quot;container&quot;&gt;    &lt;div class=&quot;cotent-header&quot;&gt;Popup title&lt;/div&gt;    &lt;div class=&quot;content-body&quot;&gt;pop up in the window&lt;/div&gt;&lt;/div&gt;</code></pre><p>CSS:</p><pre><code>*&#123;  margin: 0;  padding:0;  -webkit-box-sizing: border-box;  box-sizing: border-box;&#125;html,body &#123;  height: 100%;&#125;.container &#123;  border: 1px solid #bbb;  border-radius: 5px;  box-shadow: 0 0 3px rgba(0,0,0,.5);  position:absolute;  top:50%;  left: 50%;  -webkit-transform: translate(-50%, -50%);  transform: translate(-50%, -50%);&#125;.content-header &#123;  padding: 10px 20px;  background: rgba(0,0,0,.25);  color:#fff;&#125;.content-body&#123;  padding: 20px;  background: #fff;&#125;</code></pre><p>优点：<br>总是以不同的设备屏幕为中心</p><p>缺点：<br>实现有一点难，在一些浏览器中无效</p><h3 id="方法11"><a href="#方法11" class="headerlink" title="方法11"></a>方法11</h3><p>在这种方法中，我们使用伪元素（:before和:after）来垂直居中网站中的对象。</p><pre><code>&lt;body&gt;    &lt;div&gt;Make it centered in the window&lt;/div&gt;&lt;/body&gt;</code></pre><p>CSS:</p><pre><code>*&#123;  margin:0;  padding:0;  -webkit-box-sizing:border-box;  box-sizing:border-box;&#125;html,body &#123;  height:100%;&#125;div &#123;  display:inline-block;  vertical-align: middle;  width: 99.5%;&#125;body:after &#123;  content:&quot;&quot;;  display: inline-block;  vertical-align: middle;  height: 100%;  width: 0px;&#125;</code></pre><p>优点：<br>在现代浏览器中工作得很好</p><p>缺点：<br>复杂和更多的CSS代码。</p><h3 id="方法12"><a href="#方法12" class="headerlink" title="方法12"></a>方法12</h3><p>这个方法，我认为是使对象在网站中垂直居中最简单的方法。</p><pre><code>&lt;body&gt;    &lt;div&gt;Make it centered in the window&lt;/div&gt;&lt;/body&gt;</code></pre><p>CSS:</p><pre><code>#center &#123;    position: absolute;    top:0;    left:0;    right:0;    bottom:0;    margin: auto;&#125;</code></pre><p>优点：<br>容易，在现代浏览器中工作得很好</p><p>缺点：<br>也需要height: 100%;(其实是指用absolute定位需要，用fixed定位不需要)</p><h3 id="兼容性注意事项"><a href="#兼容性注意事项" class="headerlink" title="兼容性注意事项"></a>兼容性注意事项</h3><p>正如你所知，IE是唯一给你带来问题的主要浏览器，你需要测试IE的旧版本去解决兼容性问题。</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>除了上面我收集的，还有其他的一些方法可以做到垂直和水平居中的网站，如果你有其他的方法，请在评论区分享。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机 </tag>
            
            <tag> 前端 </tag>
            
            <tag> css </tag>
            
            <tag> 翻译 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用js</title>
      <link href="/posts/34587.html"/>
      <url>/posts/34587.html</url>
      
        <content type="html"><![CDATA[<p>1.类数组（Array-like）对象/集合转换成一个数组</p><pre><code>function list() &#123;  return Array.prototype.slice.call(arguments);&#125;</code></pre><p>或者</p><pre><code>[].slice.call(arguments)</code></pre><p>或者</p><pre><code>var unboundSlice = Array.prototype.slice;var slice = Function.prototype.call.bind(unboundSlice);function list() &#123;  return slice(arguments);&#125;var list1 = list(1, 2, 3); // [1, 2, 3]</code></pre><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/slice">更可靠地跨浏览器</a></p><p>2.验证是否是数字</p><pre><code>function isNumber(n)&#123;    return !isNaN(parseFloat(n)) &amp;&amp; isFinite(n);&#125;isFinite(null) //true</code></pre><p>或者用正则</p><p>3.验证是否是数组<br>可以使用Array.isArray()方法<br>Polyfill:假如不存在Array.isArray()，则在其他代码之前运行下面的代码将创建该方法。</p><pre><code>if (!Array.isArray) &#123;  Array.isArray = function(arg) &#123;    return Object.prototype.toString.call(arg) === &#39;[object Array]&#39;;  &#125;;&#125;</code></pre><p>如果toString()方法被重写过，就行不通了。简单环境也可以使用instanceof。</p><p>4.获取数组中的最大值和最小值</p><pre><code>Math.max.apply(null,arr);Math.min.apply(null,arr);</code></pre><p>如数组太大，会遇到方法参数个数越界的问题，<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/apply">参考MDN</a></p><p>5.保留指定小数位数字<br>var numStr = num.toFixed(2); //注意返回的是字符串，不改变num</p><p>6.不要用delete删除数组元素，否则会留坑，只是将元素位置变为了undefined，应该使用splice。删除对象属性时可以使用delete</p><p>6.</p>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机 </tag>
            
            <tag> 前端 </tag>
            
            <tag> 积累 </tag>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS篇02--margin和padding</title>
      <link href="/posts/4963.html"/>
      <url>/posts/4963.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、margin"><a href="#一、margin" class="headerlink" title="一、margin"></a>一、margin</h2><p>1.负margin位移自己：<a href="http://jsbin.com/zemava/3/edit?html,css,output">demo</a>；</p><p>2.负margin-right/margin-bottom位移别人：<a href="http://jsbin.com/zemava/5/edit?html,css,output">demo</a>；</p><p>3.负margin扩大面积：经常用来解决inline-block li的margin超出父容器的问题；</p><p>4.margin collapse（margin 合并）<br>本节参考自知乎作者貘吃馍香<br>链接：<a href="http://www.zhihu.com/question/24563593/answer/28254084">http://www.zhihu.com/question/24563593/answer/28254084</a></p><p>w3c <a href="https://www.w3.org/TR/CSS2/box.html#collapsing-margins">collapsing margins</a><br>基本上这节意思是说，比邻元素的边距总是折叠。<br>但是得除了以下几种情况：</p><p>Margins of the root element’s box do not collapse.（根元素不折叠）<br>If the top and bottom margins of an element with clearance are adjoining, its margins collapse with the adjoining margins of following siblings but that resulting margin does not collapse with the bottom margin of the parent block.（有间隙不折叠）</p><p>Margins between a floated box and any other box do not collapse (not even between a float and its in-flow children). （浮动不折叠）<br>Margins of elements that establish new block formatting contexts (such as floats and elements with ‘overflow’ other than ‘visible’) do not collapse with their in-flow children.（创建BFC与子不折叠）<br>Margins of absolutely positioned boxes do not collapse (not even with their in-flow children).（positioned 不折叠）<br>Margins of inline-block boxes do not collapse (not even with their in-flow children).（inline-box 不折叠）<br>The bottom margin of an in-flow block-level element always collapses with the top margin of its next in-flow block-level sibling, unless that sibling has clearance.（兄弟有间隙不折叠）<br>The top margin of an in-flow block element collapses with its first in-flow block-level child’s top margin if the element has no top border, no top padding, and the child has no clearance.（父子间有padding 和 border 不折叠）</p><p>5.margin居中：margin-left: auto; margin-right: auto；</p><p>6.注意margin-top 值为百分比时也以width为基准。</p><h2 id="二、padding"><a href="#二、padding" class="headerlink" title="二、padding"></a>二、padding</h2><p>1.negative value are not allowed；<br>2.利用padding来保持高宽比：<a href="http://jsbin.com/zevejuj/1/edit?html,css,output">图片保持比例超出隐藏</a>和<a href="http://jsbin.com/zevejuj/2/edit?html,css,output">图片保持比例缩放</a>；<br>3.padding与绝对定位：如果parent设定了margin，border，padding等属性，那么这个定位点将忽略padding，将会从padding开始的地方(即只从padding的左上角开始)进行定位。<a href="http://jsbin.com/zevejuj/3/edit?html,css,output">demo</a>;<br>4.padding补偿法：利用超大内边距和相同的负外边距实现<a href="http://jsbin.com/xoguhi/edit?html,css,console,output">三列等高</a>。优点是比较简单，纯css实现，缺点是无法看到下边，需再套一层div。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机 </tag>
            
            <tag> 前端 </tag>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS篇01--从清除浮动说起</title>
      <link href="/posts/3992.html"/>
      <url>/posts/3992.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们知道元素浮动后其容器高度会塌陷，这常常不是我们想要的，因此我们需要清除浮动，更确切的说法是清除因为浮动带来的效果。而我们一般通过触发BFC或者利用clear来清除浮动，IE则通过触发haslayout来实现。接下来我将谈谈自己对容器高度塌陷和这两种方法的理解。</p><h2 id="为什么元素浮动后其容器高度会塌陷？"><a href="#为什么元素浮动后其容器高度会塌陷？" class="headerlink" title="为什么元素浮动后其容器高度会塌陷？"></a>为什么元素浮动后其容器高度会塌陷？</h2><h3 id="文档流"><a href="#文档流" class="headerlink" title="文档流"></a>文档流</h3><p>经常听到文档流的说法，但是在W3C规范中并没有发现document flow这个概念，只有常规流(normal flow)。在常规流中，元素按照其在 HTML 中的先后位置至上而下布局，在这个过程中，行内元素水平排列，直到当行被占满然后换行，块级元素则会被渲染为完整的一个新行，除非另外指定，否则所有元素默认都是普通流定位，也可以说，普通流中元素的位置由该元素在 HTML 文档中的位置决定。文档流也可以认为是一层一层嵌套的，因此n多个空div嵌套，最外面那个div高度仍为0（本文float元素容器默认都是指div，其他块级元素其实效果一样，只是可能会有默认的样式，因此高度不一定为0）。</p><h3 id="浮动-float"><a href="#浮动-float" class="headerlink" title="浮动(float)"></a>浮动(float)</h3><p>float的引入最初是为了解决图文混排的，元素float后会脱离文档流，而div的高度默认是里面文档流的高度，因此容器内若没有其他文档流，容器高度为0。</p><h2 id="清除浮动的两种方法"><a href="#清除浮动的两种方法" class="headerlink" title="清除浮动的两种方法"></a>清除浮动的两种方法</h2><h3 id="触发BFC来清除浮动"><a href="#触发BFC来清除浮动" class="headerlink" title="触发BFC来清除浮动"></a>触发BFC来清除浮动</h3><p>BFC(block formatting context)俗称块级格式化上下文。下图是MDN的一些总结。<br><img src="../../../../img/bfc.png" alt="BFC"><br>BFC有一下特性：<br>1.内部的Box会在垂直方向，从顶部开始一个接一个地放置。<br>2.Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生叠加<br>3.每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。<br>4.BFC的区域不会与float box叠加。<br>5.BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之亦然。<br>6.计算BFC的高度时，浮动元素也参与计算。</p><p>正因为性质6，可以利用BFC来清除浮动。<br>参考：<br>1.<a href="http://www.html-js.com/article/1866">CSS之BFC详解</a></p><h3 id="通过clear-both来清除浮动"><a href="#通过clear-both来清除浮动" class="headerlink" title="通过clear:both来清除浮动"></a>通过clear:both来清除浮动</h3><p>1.底部加html block水平元素：</p><pre><code>&lt;div style=&quot;clear:both;&quot;&gt;&lt;/div&gt;</code></pre><p>2.css after伪元素底部生成：</p><pre><code>.clearfix::after&#123;content: &quot;&quot;; display: block; clear: both;&#125;.clearfix&#123;*zoom: 1;&#125; // IE hack</code></pre><p>PS.我们常见的是clearfix:after这种写法,中间不是两个:，两个是css3的写法，是一种改进，一个是css2的设计失误，不够优雅，一个表示状态,是伪类，两个是伪元素，CSS3对这两种进行了区分。如不用兼容IE8，最好用两个:的写法。</p><p>为什么可以通过clear:both来清除浮动呢？<br>1.如前所诉，容器高度默认是里面文档流的高度<br>2.带有clear:both的元素左右不能有浮动元素，元素加上clear:both能让它在所有浮动元素的下面，从而撑起了容器高度。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机 </tag>
            
            <tag> 前端 </tag>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>命令行与git常用命令</title>
      <link href="/posts/31653.html"/>
      <url>/posts/31653.html</url>
      
        <content type="html"><![CDATA[<h2 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h2><h3 id="什么是命令行"><a href="#什么是命令行" class="headerlink" title="什么是命令行"></a>什么是命令行</h3><p>命令行：command-line interfere(cli)<br>图形用户界面: Graphical User Interface(GUI)</p><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><pre><code>pwd        显示当前工作目录          process working directorycd        切换目录                  change directorymkdir    创建目录                  make directorymkdir -p    递归创建多个目录    --parents     no error if existing, make parent directories as neededls      列出目录内容              listls -a      可以显示.开头的文件      allls -l      列出文件的详细信息        long listing formattouch    创建文件                rm/rmdir  删除文件/目录            removerm -r    删除目录                --recursively 递归地mv        文件或目录的移动或更名    movecp      将文件拷贝至另一文件    copyecho                             like echo 1 &gt; test.txtcat        显示文件内容和合并多个文件    like cat test.txt,also like cat file1 file2 &gt; fileless    按页显示文件  j - 向前移动一行,k - 向后移动一行,G - 移动到最后一行,g - 移动到第一行clear      清屏du      统计目录／文件所占磁盘空间的大小    disk usage                                    du -sh     以易读的方式显示总共大小    --summarize --human-readableps      报告程序状况            process statushead     显示开头某个数量的文字区块    like head -n 3 test.txttail    显示结尾某个数量的文字区块xxx -h    至少可以通过以下三种中的一种获取命令的帮助信息xxx --helpman    xxx</code></pre><h3 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h3><pre><code>Alt + .     使用上一条命令的最后一个参数!!             执行上一条命令.             当前目录..             上一层目录~            根目录-            上一次目录多个命令之间可以用;或&amp;&amp;分隔，前者命令错误不中断</code></pre><h3 id="管道-pipe"><a href="#管道-pipe" class="headerlink" title="管道(pipe)"></a>管道(pipe)</h3><p>前一个命令的输出为后一个命令的输入，like cat test.txt | less</p><h3 id="Path"><a href="#Path" class="headerlink" title="Path"></a>Path</h3><p>告诉命令行去哪找命令，用英文分号分隔加路径，Windows在高级系统设置中</p><h3 id="vi与vim"><a href="#vi与vim" class="headerlink" title="vi与vim"></a>vi与vim</h3><p>vi是一种计算机文本编辑器，是“Visual”的不正规的缩写。vi是一种模式编辑器。不同的按钮和键击可以更改不同的“模式”。Vim（Vi IMproved）是一种升级版。<br>默认为不可编辑模式，i：输入模式  Windows中Esc：退出  输入:切至命令模式  w:write  q:quit  wq:保存并退出<br>深入学习请<a href="http://coolshell.cn/articles/5426.html">参考</a></p><h2 id="git"><a href="#git" class="headerlink" title="git"></a>git</h2><p>git日常使用的6个命令，如图所示<br><img src="../../../../img/git.png" alt="git常用操作"><br>图中的几个专有名词：<br>Workspace：工作区<br>Index / Stage：暂存区<br>Repository：仓库区（或本地仓库）<br>Remote：远程仓库</p><h3 id="一、创建新仓库"><a href="#一、创建新仓库" class="headerlink" title="一、创建新仓库"></a>一、创建新仓库</h3><p><font style="color:#ccc;">在当前目录</font><br>    git init</p><h3 id="二、配置"><a href="#二、配置" class="headerlink" title="二、配置"></a>二、配置</h3><p><font style="color:#ccc;">显示当前的Git配置</font><br>    git config –list<br><font style="color:#ccc;">编辑Git配置文件</font><br>    git config -e [–global]<br><font style="color:#ccc;">设置提交代码时的用户信息</font><br>    git config [–global] user.name “[name]”<br>    git config [–global] user.email “[email address]”</p><h3 id="三、检出仓库"><a href="#三、检出仓库" class="headerlink" title="三、检出仓库"></a>三、检出仓库</h3><p>创建一个本地仓库的克隆版本：<br>    git clone /path/to/repository<br>如果是远端服务器上的仓库：<br>    git clone username@host:/path/to/repository</p><h3 id="四、添加和提交"><a href="#四、添加和提交" class="headerlink" title="四、添加和提交"></a>四、添加和提交</h3><p><font style="color:#ccc;">添加到暂存区</font><br>    git add [filename]<br>    git add *<br>    git add .<br><font style="color:#ccc;">改动已经提交到了HEAD，但是还没到你的远端仓库</font><br>    git commit -m “代码提交信息”<br><font style="color:#ccc;">提交工作区自上次commit之后的变化，直接到仓库区</font><br>    git commit -a<br><font style="color:#ccc;">提交时显示所有diff信息</font><br>    git commit -v</p><h3 id="五、推送改动"><a href="#五、推送改动" class="headerlink" title="五、推送改动"></a>五、推送改动</h3><p><font style="color:#ccc;">上传本地指定分支到远程仓库</font><br>    git push origin master<br><font style="color:#ccc;">强行推送当前分支到远程仓库，即使有冲突</font><br>    git push origin master –force</p><p>1.git支持本地仓库有多个远程仓库<br>2.git远程仓库需有名字，默认为origin<br>3.每个仓库可以有多个分支，默认分支为master<br>4.本地分支与远程分支可以不同，例如：git push origin master1:master2</p><h3 id="六、分支"><a href="#六、分支" class="headerlink" title="六、分支"></a>六、分支</h3><p><font style="color:#ccc;">列出所有本地分支</font><br>    git branch<br><font style="color:#ccc;">列出所有本地分支和远程分支</font><br>    git branch -a<br><font style="color:#ccc;">切换到指定分支，并更新工作区</font><br>    git checkout [branch-name]<br><font style="color:#ccc;">新建一个分支，并切换到该分支</font><br>    git checkout -b [branch]<br><font style="color:#ccc;">删除分支</font><br>    git branch -d [branch-name]<br><font style="color:#ccc;">删除远程分支</font><br>    git push origin :feature</p><h3 id="七、更新与合并"><a href="#七、更新与合并" class="headerlink" title="七、更新与合并"></a>七、更新与合并</h3><p><font style="color:#ccc;">更新本地仓库至最新改动</font><br>    git pull<br><font style="color:#ccc;">合并其他分支到当前分支</font><br>    git merge <branch><br><font style="color:#ccc;">从远程下载但最新代码但不merge，不更改工作目录</font><br>    git fetch</p><h3 id="八、撤销"><a href="#八、撤销" class="headerlink" title="八、撤销"></a>八、撤销</h3><p><font style="color:#ccc;">恢复暂存区的指定文件到工作区</font><br>    git checkout [file]<br><font style="color:#ccc;">恢复某个commit的指定文件到暂存区和工作区</font><br>    git checkout [commit] [file]<br><font style="color:#ccc;">恢复暂存区的所有文件到工作区</font><br>    git checkout .<br><font style="color:#ccc;">重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</font><br>    git reset 版本号<br><font style="color:#ccc;">重置暂存区与工作区，与上一次commit保持一致</font><br>    git reset –hard 版本号<br><font style="color:#ccc;">重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</font><br>    git reset [commit]<br><font style="color:#ccc;">重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</font><br>    git reset –hard [commit]</p><p>可以使用git reflog找回，只要commit过就不会丢失</p><h3 id="查看信息"><a href="#查看信息" class="headerlink" title="查看信息"></a>查看信息</h3><p><font style="color:#ccc;">显示有变更的文件</font><br>    git status<br>    git status -s    show status concisely<br>    git status -b    show branch information<br><font style="color:#ccc;">显示当前分支的版本历史</font><br>    git log<br><font style="color:#ccc;">显示当前分支的最近几次提交</font><br>    git reflog<br><font style="color:#ccc;">显示暂存区和工作区的差异</font><br>    git diff<br><font style="color:#ccc;">显示暂存区和上一个commit的差异</font><br>    git diff –cached [file]<br><font style="color:#ccc;">显示工作区与当前分支最新commit之间的差异</font><br>    git diff HEAD</p><h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><p>1.<a href="http://rogerdudler.github.io/git-guide/index.zh.html">git简明指南</a>;<br>2.<a href="http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html">常用Git命令清单</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机 </tag>
            
            <tag> git </tag>
            
            <tag> 计算机基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的第一篇博客</title>
      <link href="/posts/63785.html"/>
      <url>/posts/63785.html</url>
      
        <content type="html"><![CDATA[<p>我的第一篇博客说什么好呢？一个走在转行路上的菜鸟，内心充满了迷茫，希望自己能内心始终向往光明！</p>]]></content>
      
      
      <categories>
          
          <category> 生活琐事 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
